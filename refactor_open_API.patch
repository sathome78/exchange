Index: Controller/src/main/java/me/exrates/controller/exception/ValidationException.java
===================================================================
--- Controller/src/main/java/me/exrates/controller/exception/ValidationException.java	(revision Shelved Version)
+++ Controller/src/main/java/me/exrates/controller/exception/ValidationException.java	(revision Shelved Version)
@@ -0,0 +1,18 @@
+package me.exrates.controller.exception;
+
+import lombok.Getter;
+import lombok.Setter;
+import org.springframework.validation.ObjectError;
+
+import java.util.List;
+
+@Getter
+@Setter
+public class ValidationException extends Exception {
+
+    private List<ObjectError> errors;
+
+    public ValidationException(List<ObjectError> errors) {
+        this.errors = errors;
+    }
+}
Index: Controller/src/main/java/me/exrates/controller/merchants/CommonMerchantsController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/java/me/exrates/controller/merchants/CommonMerchantsController.java	(revision Local Version)
+++ Controller/src/main/java/me/exrates/controller/merchants/CommonMerchantsController.java	(revision Shelved Version)
@@ -73,7 +73,7 @@
       Payment payment = new Payment();
       payment.setOperationType(operationType);
       modelAndView.addObject("payment", payment);
-      BigDecimal minRefillSum = currencyService.retrieveMinLimitForRoleAndCurrency(userService.getUserRoleFromSecurityContext(), operationType, currency.getId());
+      BigDecimal minRefillSum = currencyService.getMinLimitForRoleAndCurrency(userService.getUserRoleFromSecurityContext(), operationType, currency.getId());
       modelAndView.addObject("minRefillSum", minRefillSum);
       Integer scaleForCurrency = currencyService.getCurrencyScaleByCurrencyId(currency.getId()).getScaleForRefill();
       modelAndView.addObject("scaleForCurrency", scaleForCurrency);
@@ -109,7 +109,7 @@
       Payment payment = new Payment();
       payment.setOperationType(operationType);
       modelAndView.addObject("payment", payment);
-      BigDecimal minWithdrawSum = currencyService.retrieveMinLimitForRoleAndCurrency(userService.getUserRoleFromSecurityContext(), operationType, currency.getId());
+      BigDecimal minWithdrawSum = currencyService.getMinLimitForRoleAndCurrency(userService.getUserRoleFromSecurityContext(), operationType, currency.getId());
       modelAndView.addObject("minWithdrawSum", minWithdrawSum);
       Integer scaleForCurrency = currencyService.getCurrencyScaleByCurrencyId(currency.getId()).getScaleForWithdraw();
       modelAndView.addObject("scaleForCurrency", scaleForCurrency);
@@ -144,7 +144,7 @@
       Payment payment = new Payment();
       payment.setOperationType(operationType);
       modelAndView.addObject("payment", payment);
-      BigDecimal minTransferSum = currencyService.retrieveMinLimitForRoleAndCurrency(userService.getUserRoleFromSecurityContext(), operationType, currency.getId());
+      BigDecimal minTransferSum = currencyService.getMinLimitForRoleAndCurrency(userService.getUserRoleFromSecurityContext(), operationType, currency.getId());
       modelAndView.addObject("minTransferSum", minTransferSum);
       Integer scaleForCurrency = currencyService.getCurrencyScaleByCurrencyId(currency.getId()).getScaleForWithdraw();
       modelAndView.addObject("scaleForCurrency", scaleForCurrency);
Index: Controller/src/main/java/me/exrates/controller/mobile/MobileDashboardController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/java/me/exrates/controller/mobile/MobileDashboardController.java	(revision Local Version)
+++ Controller/src/main/java/me/exrates/controller/mobile/MobileDashboardController.java	(revision Shelved Version)
@@ -313,7 +313,7 @@
         result.setCommissions(orderService.getAllCommissions());
         result.setCurrencyPairs(currencyService.findCurrencyPairsWithLimitsForUser().stream().filter(p->p.getType() == CurrencyPairType.MAIN).collect(Collectors.toList()));
         List<Integer> currencyIds = currencyId == null ? Collections.EMPTY_LIST : Collections.singletonList(currencyId);
-        result.setTransferLimits(currencyService.retrieveMinTransferLimits(currencyIds));
+        result.setTransferLimits(currencyService.getMinTransferLimits(currencyIds));
         result.setMerchants(merchantService.findNonTransferMerchantCurrencies(currencyId));
         result.setTransferMerchants(merchantService.findTransferMerchants());
         return result;
@@ -1155,7 +1155,7 @@
     @RequestMapping(value = "/transferLimits", method = GET)
     public List<TransferLimitDto> retrieveMinTransferLimits(@RequestParam(required = false) Integer[] currencyIds) {
         List<Integer> currencyIdList = currencyIds == null || currencyIds.length == 0 ? Collections.EMPTY_LIST : Arrays.asList(currencyIds);
-        return currencyService.retrieveMinTransferLimits(currencyIdList);
+        return currencyService.getMinTransferLimits(currencyIdList);
     }
 
     @RequestMapping(value = "/test/currencyPairRates", method = GET, produces = "application/json; charset=UTF-8")
Index: Controller/src/main/java/me/exrates/controller/mobile/MobileEntryController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/java/me/exrates/controller/mobile/MobileEntryController.java	(revision Local Version)
+++ Controller/src/main/java/me/exrates/controller/mobile/MobileEntryController.java	(revision Shelved Version)
@@ -1,7 +1,13 @@
 package me.exrates.controller.mobile;
 
-import me.exrates.controller.exception.*;
-import me.exrates.controller.listener.StoreSessionListener;
+import me.exrates.controller.exception.InvalidAppKeyException;
+import me.exrates.controller.exception.InvalidEmailException;
+import me.exrates.controller.exception.InvalidFileException;
+import me.exrates.controller.exception.InvalidPasswordException;
+import me.exrates.controller.exception.InvalidSessionIdException;
+import me.exrates.controller.exception.NotCreateUserException;
+import me.exrates.controller.exception.NotSupportedLanguageException;
+import me.exrates.controller.exception.WrongUsernameOrPasswordException;
 import me.exrates.model.User;
 import me.exrates.model.dto.UpdateUserDto;
 import me.exrates.model.dto.mobileApiDto.AuthTokenDto;
@@ -14,12 +20,23 @@
 import me.exrates.security.exception.UserNotEnabledException;
 import me.exrates.security.service.AuthTokenService;
 import me.exrates.security.service.IpBlockingService;
-import me.exrates.service.*;
-import me.exrates.service.exception.*;
-import me.exrates.service.exception.api.*;
+import me.exrates.service.ApiService;
+import me.exrates.service.ReferralService;
+import me.exrates.service.UserFilesService;
+import me.exrates.service.UserService;
+import me.exrates.service.exception.AbsentFinPasswordException;
+import me.exrates.service.exception.InvalidNicknameException;
+import me.exrates.service.exception.NotConfirmedFinPasswordException;
+import me.exrates.service.exception.NotImplimentedMethod;
+import me.exrates.service.exception.WrongFinPasswordException;
+import me.exrates.service.exception.api.ApiError;
+import me.exrates.service.exception.api.ErrorCode;
+import me.exrates.service.exception.api.MissingBodyParamException;
+import me.exrates.service.exception.api.UnconfirmedUserException;
+import me.exrates.service.exception.api.UniqueEmailConstraintException;
+import me.exrates.service.exception.api.UniqueNicknameConstraintException;
 import me.exrates.service.session.UserSessionService;
 import me.exrates.service.util.IpUtils;
-import me.exrates.service.waves.WavesService;
 import org.apache.commons.lang.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -33,24 +50,52 @@
 import org.springframework.http.ResponseEntity;
 import org.springframework.http.converter.HttpMessageNotReadableException;
 import org.springframework.security.core.context.SecurityContextHolder;
-import org.springframework.security.core.userdetails.UserDetails;
 import org.springframework.security.core.userdetails.UsernameNotFoundException;
 import org.springframework.web.bind.MethodArgumentNotValidException;
 import org.springframework.web.bind.MissingServletRequestParameterException;
-import org.springframework.web.bind.annotation.*;
+import org.springframework.web.bind.annotation.ExceptionHandler;
+import org.springframework.web.bind.annotation.RequestBody;
+import org.springframework.web.bind.annotation.RequestHeader;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RequestMethod;
+import org.springframework.web.bind.annotation.RequestParam;
+import org.springframework.web.bind.annotation.ResponseBody;
+import org.springframework.web.bind.annotation.ResponseStatus;
+import org.springframework.web.bind.annotation.RestController;
 import org.springframework.web.context.request.RequestContextHolder;
 import org.springframework.web.multipart.MultipartFile;
-import org.springframework.web.util.WebUtils;
 
 import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpSession;
 import javax.validation.Valid;
 import java.io.IOException;
-import java.util.*;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
 
-import static me.exrates.service.exception.api.ErrorCode.*;
+import static me.exrates.service.exception.api.ErrorCode.ABSENT_FIN_PASSWORD;
+import static me.exrates.service.exception.api.ErrorCode.ACCOUNT_DISABLED;
+import static me.exrates.service.exception.api.ErrorCode.ACCOUNT_NOT_CONFIRMED;
+import static me.exrates.service.exception.api.ErrorCode.BANNED_IP;
+import static me.exrates.service.exception.api.ErrorCode.EXISTING_EMAIL;
+import static me.exrates.service.exception.api.ErrorCode.EXISTING_NICKNAME;
+import static me.exrates.service.exception.api.ErrorCode.INCORRECT_FIN_PASSWORD;
+import static me.exrates.service.exception.api.ErrorCode.INCORRECT_LOGIN_OR_PASSWORD;
+import static me.exrates.service.exception.api.ErrorCode.INVALID_APP_KEY;
+import static me.exrates.service.exception.api.ErrorCode.INVALID_FILE;
+import static me.exrates.service.exception.api.ErrorCode.INVALID_NICKNAME;
+import static me.exrates.service.exception.api.ErrorCode.INVALID_PARAM_VALUE;
+import static me.exrates.service.exception.api.ErrorCode.INVALID_SESSION_ID;
+import static me.exrates.service.exception.api.ErrorCode.LANGUAGE_NOT_SUPPORTED;
+import static me.exrates.service.exception.api.ErrorCode.MISSING_CREDENTIALS;
+import static me.exrates.service.exception.api.ErrorCode.MISSING_REQUIRED_PARAM;
+import static me.exrates.service.exception.api.ErrorCode.REQUEST_NOT_READABLE;
+import static me.exrates.service.exception.api.ErrorCode.UNCONFIRMED_FIN_PASSWORD;
 import static me.exrates.service.util.RestApiUtils.decodePassword;
-import static me.exrates.service.util.RestApiUtils.retrieveParamFormBody;
+import static me.exrates.utils.ApiUtil.getValueByParamName;
 
 /**
  * Created by OLEG on 19.08.2016.
@@ -796,8 +841,8 @@
     @RequestMapping(value = "/api/user/changePass", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)
     public ResponseEntity<Void> changePass(@RequestBody Map<String, String> body) {
 
-        logger.debug(retrieveParamFormBody(body, "password", true));
-        changeUserPasses(retrieveParamFormBody(body, "password", true), null);
+        logger.debug(getValueByParamName(body, "password", true));
+        changeUserPasses(getValueByParamName(body, "password", true), null);
         return new ResponseEntity<>(HttpStatus.OK);
     }
 
@@ -828,8 +873,8 @@
      */
     @RequestMapping(value = "/api/user/changeFinPass", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)
     public ResponseEntity<Void> changeFinPass(@RequestBody Map<String, String> body) {
-        logger.debug(retrieveParamFormBody(body, "finPass", true));
-        changeUserPasses(null, retrieveParamFormBody(body, "finPass", true));
+        logger.debug(getValueByParamName(body, "finPass", true));
+        changeUserPasses(null, getValueByParamName(body, "finPass", true));
         return new ResponseEntity<>(HttpStatus.OK);
     }
 
@@ -882,8 +927,8 @@
      */
     @RequestMapping(value = "/api/user/checkFinPass", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)
     public ResponseEntity<Void> checkFinPass(@RequestBody Map<String, String> body) {
-        logger.debug(retrieveParamFormBody(body, "finPass", true));
-        String decodedFinPass = decodePassword(retrieveParamFormBody(body, "finPass", true), passEncodeKey);
+        logger.debug(getValueByParamName(body, "finPass", true));
+        String decodedFinPass = decodePassword(getValueByParamName(body, "finPass", true), passEncodeKey);
         String userEmail = SecurityContextHolder.getContext().getAuthentication().getName();
         User user = userService.findByEmail(userEmail);
         userService.checkFinPassword(decodedFinPass, user, new Locale(userService.getPreferedLang(user.getId())));
@@ -976,7 +1021,7 @@
      */
     @RequestMapping(value = "/api/user/setLanguage", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)
     public ResponseEntity<Void> setLanguage(@RequestBody Map<String, String> body) {
-        String language = retrieveParamFormBody(body, "language", true);
+        String language = getValueByParamName(body, "language", true);
         Locale locale = new Locale(language);
         logger.debug(locale);
         String userEmail = SecurityContextHolder.getContext().getAuthentication().getName();
Index: Controller/src/main/java/me/exrates/controller/mobile/MobileInputOutputController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/java/me/exrates/controller/mobile/MobileInputOutputController.java	(revision Local Version)
+++ Controller/src/main/java/me/exrates/controller/mobile/MobileInputOutputController.java	(revision Shelved Version)
@@ -1,24 +1,66 @@
 package me.exrates.controller.mobile;
 
-import me.exrates.controller.exception.*;
-import me.exrates.model.*;
-import me.exrates.model.dto.*;
-import me.exrates.model.dto.mobileApiDto.*;
+import me.exrates.controller.exception.CommissionExceedingAmountException;
+import me.exrates.controller.exception.InputRequestLimitExceededException;
+import me.exrates.controller.exception.InvoiceBankNotFoundException;
+import me.exrates.controller.exception.InvoiceNotFoundException;
+import me.exrates.controller.exception.NotEnoughMoneyException;
+import me.exrates.controller.exception.RequestsLimitExceedException;
+import me.exrates.model.ClientBank;
+import me.exrates.model.CreditsOperation;
+import me.exrates.model.InvoiceBank;
+import me.exrates.model.Merchant;
+import me.exrates.model.MerchantCurrency;
+import me.exrates.model.Payment;
+import me.exrates.model.dto.RefillRequestCreateDto;
+import me.exrates.model.dto.RefillRequestFlatDto;
+import me.exrates.model.dto.RefillRequestParamsDto;
+import me.exrates.model.dto.TransferRequestCreateDto;
+import me.exrates.model.dto.TransferRequestFlatDto;
+import me.exrates.model.dto.TransferRequestParamsDto;
+import me.exrates.model.dto.WithdrawRequestCreateDto;
+import me.exrates.model.dto.WithdrawRequestParamsDto;
+import me.exrates.model.dto.mobileApiDto.CryptoAddressDto;
+import me.exrates.model.dto.mobileApiDto.MerchantCurrencyApiDto;
+import me.exrates.model.dto.mobileApiDto.MerchantInputResponseDto;
+import me.exrates.model.dto.mobileApiDto.RefillRequestDetailsDto;
+import me.exrates.model.dto.mobileApiDto.TransferMerchantApiDto;
+import me.exrates.model.dto.mobileApiDto.TransferResponseDto;
 import me.exrates.model.enums.MerchantApiResponseType;
 import me.exrates.model.enums.MerchantProcessType;
 import me.exrates.model.enums.OperationType;
-import me.exrates.model.enums.invoice.*;
+import me.exrates.model.enums.invoice.InvoiceActionTypeEnum;
+import me.exrates.model.enums.invoice.InvoiceStatus;
+import me.exrates.model.enums.invoice.RefillStatusEnum;
+import me.exrates.model.enums.invoice.TransferStatusEnum;
+import me.exrates.model.enums.invoice.WithdrawStatusEnum;
 import me.exrates.model.util.BigDecimalProcessing;
 import me.exrates.model.vo.InvoiceConfirmData;
 import me.exrates.model.vo.WithdrawData;
-import me.exrates.service.*;
-import me.exrates.service.exception.*;
+import me.exrates.service.CommissionService;
+import me.exrates.service.CurrencyService;
+import me.exrates.service.InputOutputService;
+import me.exrates.service.MerchantService;
+import me.exrates.service.RefillService;
+import me.exrates.service.RequestLimitExceededException;
+import me.exrates.service.TransferService;
+import me.exrates.service.UserService;
+import me.exrates.service.WalletService;
+import me.exrates.service.WithdrawService;
+import me.exrates.service.exception.CurrencyPairNotFoundException;
+import me.exrates.service.exception.InvalidAmountException;
+import me.exrates.service.exception.InvalidNicknameException;
+import me.exrates.service.exception.MerchantCurrencyBlockedException;
+import me.exrates.service.exception.MerchantInternalException;
+import me.exrates.service.exception.MerchantNotFoundException;
+import me.exrates.service.exception.NotEnoughUserWalletMoneyException;
+import me.exrates.service.exception.RefillRequestGeneratingAdditionalAddressNotAvailableException;
+import me.exrates.service.exception.UserNotFoundException;
 import me.exrates.service.exception.api.ApiError;
 import me.exrates.service.exception.api.ErrorCode;
 import me.exrates.service.exception.invoice.IllegalInvoiceStatusException;
 import me.exrates.service.exception.invoice.VoucherNotFoundException;
 import me.exrates.service.util.RateLimitService;
-import me.exrates.service.util.RestApiUtils;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -31,23 +73,41 @@
 import org.springframework.security.core.context.SecurityContextHolder;
 import org.springframework.web.bind.MethodArgumentNotValidException;
 import org.springframework.web.bind.MissingServletRequestParameterException;
-import org.springframework.web.bind.annotation.*;
+import org.springframework.web.bind.annotation.ExceptionHandler;
+import org.springframework.web.bind.annotation.RequestBody;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RequestParam;
+import org.springframework.web.bind.annotation.ResponseBody;
+import org.springframework.web.bind.annotation.ResponseStatus;
+import org.springframework.web.bind.annotation.RestController;
 import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
 import org.springframework.web.servlet.ModelAndView;
 
 import javax.servlet.http.HttpServletRequest;
 import javax.validation.Valid;
 import java.math.BigDecimal;
-import java.util.*;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
 import java.util.stream.Collectors;
 
 import static me.exrates.model.enums.OperationType.INPUT;
 import static me.exrates.model.enums.OperationType.USER_TRANSFER;
 import static me.exrates.model.enums.invoice.InvoiceActionTypeEnum.CREATE_BY_USER;
 import static me.exrates.model.enums.invoice.InvoiceActionTypeEnum.PRESENT_VOUCHER;
-import static me.exrates.service.exception.api.ErrorCode.*;
-import static org.springframework.http.HttpStatus.*;
+import static me.exrates.service.exception.api.ErrorCode.BAD_INVOICE_STATUS;
+import static me.exrates.service.exception.api.ErrorCode.INSUFFICIENT_FUNDS;
+import static me.exrates.service.exception.api.ErrorCode.INVALID_PAYMENT_AMOUNT;
+import static me.exrates.service.exception.api.ErrorCode.REQUEST_NOT_READABLE;
+import static me.exrates.utils.ApiUtil.getValueByParamName;
+import static org.springframework.http.HttpStatus.BAD_REQUEST;
 import static org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR;
+import static org.springframework.http.HttpStatus.NOT_ACCEPTABLE;
+import static org.springframework.http.HttpStatus.NOT_FOUND;
+import static org.springframework.http.HttpStatus.OK;
 import static org.springframework.web.bind.annotation.RequestMethod.GET;
 import static org.springframework.web.bind.annotation.RequestMethod.POST;
 
@@ -453,7 +513,7 @@
      */
    @RequestMapping(value = "/transfer/accept", method = POST, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
     public Map<String, String> acceptVoucher(@RequestBody Map<String, String> params) {
-        String code = RestApiUtils.retrieveParamFormBody(params, "code", true);
+        String code = getValueByParamName(params, "code", true);
         String userEmail = getAuthenticatedUserEmail();
         Locale userLocale = userService.getUserLocaleForMobile(userEmail);
         if (!rateLimitService.checkLimitsExceed(userEmail)) {
@@ -732,7 +792,7 @@
      */
     @RequestMapping(value = "/invoice/revoke", method = POST, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)
     public ResponseEntity<Void> revokeInvoice(@RequestBody Map<String, String> params) throws Exception {
-        String invoiceIdString = RestApiUtils.retrieveParamFormBody(params, "invoiceId", true);
+        String invoiceIdString = getValueByParamName(params, "invoiceId", true);
         Integer invoiceId = Integer.parseInt(invoiceIdString);
         InvoiceConfirmData invoiceConfirmData = new InvoiceConfirmData();
         invoiceConfirmData.setInvoiceId(invoiceId);
@@ -863,7 +923,7 @@
     @RequestMapping(value = "/withdraw/revoke", method = POST)
     @ResponseBody
     public ResponseEntity<Void> revokeWithdrawRequest(@RequestBody Map<String, String> params) {
-        Integer id = Integer.parseInt(RestApiUtils.retrieveParamFormBody(params, "invoiceId", true));
+        Integer id = Integer.parseInt(getValueByParamName(params, "invoiceId", true));
         withdrawService.revokeWithdrawalRequest(id);
         return new ResponseEntity<>(OK);
     }
Index: Controller/src/main/java/me/exrates/controller/openAPI/exception_handler/apiExceptionControllerAdvice.java
===================================================================
--- Controller/src/main/java/me/exrates/controller/openAPI/exception_handler/apiExceptionControllerAdvice.java	(revision Shelved Version)
+++ Controller/src/main/java/me/exrates/controller/openAPI/exception_handler/apiExceptionControllerAdvice.java	(revision Shelved Version)
@@ -0,0 +1,127 @@
+package me.exrates.controller.openAPI.exception_handler;
+
+import lombok.extern.log4j.Log4j2;
+import me.exrates.controller.exception.ValidationException;
+import me.exrates.service.exception.AlreadyAcceptedOrderException;
+import me.exrates.service.exception.CurrencyPairNotFoundException;
+import me.exrates.service.exception.OrderNotFoundException;
+import me.exrates.service.exception.api.ErrorCode;
+import me.exrates.service.exception.api.InvalidCurrencyPairFormatException;
+import me.exrates.service.exception.api.OpenApiError;
+import me.exrates.service.exception.api.OrderParamsWrongException;
+import me.exrates.service.exception.api.ValidationOpenApiError;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.converter.HttpMessageNotReadableException;
+import org.springframework.security.access.AccessDeniedException;
+import org.springframework.validation.FieldError;
+import org.springframework.web.HttpRequestMethodNotSupportedException;
+import org.springframework.web.bind.MethodArgumentNotValidException;
+import org.springframework.web.bind.MissingServletRequestParameterException;
+import org.springframework.web.bind.annotation.ControllerAdvice;
+import org.springframework.web.bind.annotation.ExceptionHandler;
+import org.springframework.web.bind.annotation.ResponseBody;
+import org.springframework.web.bind.annotation.ResponseStatus;
+import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
+
+import javax.servlet.http.HttpServletRequest;
+import java.util.List;
+import java.util.stream.Collectors;
+
+@Log4j2
+@ControllerAdvice
+public class apiExceptionControllerAdvice {
+
+    @ResponseStatus(value = HttpStatus.FORBIDDEN)
+    @ExceptionHandler(AccessDeniedException.class)
+    public OpenApiError accessDeniedExceptionHandler(HttpServletRequest req, Exception exception) {
+        return new OpenApiError(ErrorCode.ACCESS_DENIED, req.getServletPath(), exception);
+    }
+
+    @ResponseStatus(value = HttpStatus.BAD_REQUEST)
+    @ExceptionHandler({MethodArgumentNotValidException.class, OrderParamsWrongException.class, MethodArgumentTypeMismatchException.class})
+    @ResponseBody
+    public OpenApiError mismatchArgumentsExceptionHandler(HttpServletRequest req, Exception exception) {
+        if (exception instanceof MethodArgumentTypeMismatchException) {
+            final String detail = "Invalid param value : " + ((MethodArgumentTypeMismatchException) exception).getParameter().getParameterName();
+
+            return new OpenApiError(ErrorCode.INVALID_PARAM_VALUE, req.getServletPath(), detail);
+        }
+        return new OpenApiError(ErrorCode.INVALID_PARAM_VALUE, req.getServletPath(), exception);
+    }
+
+    @ResponseStatus(value = HttpStatus.BAD_REQUEST)
+    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
+    @ResponseBody
+    public OpenApiError notSupportedExceptionHandler(HttpServletRequest req, Exception exception) {
+        return new OpenApiError(ErrorCode.REQUEST_NOT_SUPPORTED, req.getServletPath(), exception);
+    }
+
+    @ResponseStatus(value = HttpStatus.BAD_REQUEST)
+    @ExceptionHandler(HttpMessageNotReadableException.class)
+    @ResponseBody
+    public OpenApiError jsonMappingExceptionHandler(HttpServletRequest req, HttpMessageNotReadableException exception) {
+        return new OpenApiError(ErrorCode.REQUEST_NOT_READABLE, req.getServletPath(), "Invalid request format");
+    }
+
+    @ResponseStatus(value = HttpStatus.BAD_REQUEST)
+    @ExceptionHandler(MissingServletRequestParameterException.class)
+    @ResponseBody
+    public OpenApiError missingServletRequestParameterExceptionHandler(HttpServletRequest req, Exception exception) {
+        return new OpenApiError(ErrorCode.MISSING_REQUIRED_PARAM, req.getServletPath(), exception);
+    }
+
+    @ResponseStatus(value = HttpStatus.NOT_ACCEPTABLE)
+    @ExceptionHandler(CurrencyPairNotFoundException.class)
+    @ResponseBody
+    public OpenApiError currencyPairNotFoundExceptionHandler(HttpServletRequest req, Exception exception) {
+        return new OpenApiError(ErrorCode.CURRENCY_PAIR_NOT_FOUND, req.getServletPath(), exception);
+    }
+
+    @ResponseStatus(value = HttpStatus.NOT_ACCEPTABLE)
+    @ExceptionHandler(InvalidCurrencyPairFormatException.class)
+    @ResponseBody
+    public OpenApiError invalidCurrencyPairFormatExceptionHandler(HttpServletRequest req, Exception exception) {
+        return new OpenApiError(ErrorCode.INVALID_CURRENCY_PAIR_FORMAT, req.getServletPath(), exception);
+    }
+
+    @ResponseStatus(value = HttpStatus.NOT_ACCEPTABLE)
+    @ExceptionHandler(AlreadyAcceptedOrderException.class)
+    @ResponseBody
+    public OpenApiError alreadyAcceptedOrderExceptionHandler(HttpServletRequest req, Exception exception) {
+        return new OpenApiError(ErrorCode.ALREADY_ACCEPTED_ORDER, req.getServletPath(), exception);
+    }
+
+    @ResponseStatus(value = HttpStatus.NOT_ACCEPTABLE)
+    @ExceptionHandler(OrderNotFoundException.class)
+    @ResponseBody
+    public OpenApiError orderNotFoundExceptionHandler(HttpServletRequest req, Exception exception) {
+        return new OpenApiError(ErrorCode.ORDER_NOT_FOUND, req.getServletPath(), exception);
+    }
+
+    @ResponseStatus(value = HttpStatus.UNPROCESSABLE_ENTITY)
+    @ExceptionHandler(ValidationException.class)
+    @ResponseBody
+    public ValidationOpenApiError validationExceptionHandler(HttpServletRequest req,
+                                                             ValidationException exception) {
+        List<String> errors = exception.getErrors()
+                .stream()
+                .map(error -> {
+                    if (error instanceof FieldError) {
+                        FieldError fieldError = (FieldError) error;
+                        return String.format("%s: %s", fieldError.getField(), error.getDefaultMessage());
+                    } else {
+                        return error.getDefaultMessage();
+                    }
+                })
+                .collect(Collectors.toList());
+        return new ValidationOpenApiError(ErrorCode.UNPROCESSABLE_ENTITY, req.getServletPath(), "Validation failed", errors);
+    }
+
+    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
+    @ExceptionHandler({Exception.class, RuntimeException.class})
+    @ResponseBody
+    public OpenApiError exceptionHandler(HttpServletRequest req, Exception exception) {
+        log.error("Internal error", exception);
+        return new OpenApiError(ErrorCode.INTERNAL_SERVER_ERROR, req.getServletPath(), "Internal server error: " + exception.getMessage());
+    }
+}
Index: Controller/src/main/java/me/exrates/controller/openAPI/OpenApiOrderController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/java/me/exrates/controller/openAPI/OpenApiOrderController.java	(revision Local Version)
+++ Controller/src/main/java/me/exrates/controller/openAPI/OpenApiOrderController.java	(revision Shelved Version)
@@ -1,54 +1,39 @@
 package me.exrates.controller.openAPI;
 
+import lombok.extern.log4j.Log4j2;
+import me.exrates.controller.exception.ValidationException;
 import me.exrates.model.dto.OrderCreationResultDto;
 import me.exrates.model.dto.openAPI.OpenOrderDto;
 import me.exrates.model.dto.openAPI.OrderCreationDto;
-import me.exrates.model.dto.openAPI.OrderParamsDto;
+import me.exrates.model.dto.openAPI.OrderParamsRequest;
 import me.exrates.model.enums.OrderType;
 import me.exrates.service.OrderService;
 import me.exrates.service.UserService;
-import me.exrates.service.exception.AlreadyAcceptedOrderException;
-import me.exrates.service.exception.CurrencyPairNotFoundException;
-import me.exrates.service.exception.OrderNotFoundException;
-import me.exrates.service.exception.api.ErrorCode;
-import me.exrates.service.exception.api.InvalidCurrencyPairFormatException;
-import me.exrates.service.exception.api.OpenApiError;
-import me.exrates.service.exception.api.OrderParamsWrongException;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.http.HttpStatus;
 import org.springframework.http.MediaType;
 import org.springframework.http.ResponseEntity;
-import org.springframework.http.converter.HttpMessageNotReadableException;
-import org.springframework.security.access.AccessDeniedException;
 import org.springframework.security.access.prepost.PreAuthorize;
-import org.springframework.validation.Errors;
-import org.springframework.web.bind.MethodArgumentNotValidException;
-import org.springframework.web.bind.MissingServletRequestParameterException;
-import org.springframework.web.bind.annotation.ExceptionHandler;
+import org.springframework.validation.BindingResult;
 import org.springframework.web.bind.annotation.GetMapping;
 import org.springframework.web.bind.annotation.PathVariable;
 import org.springframework.web.bind.annotation.PostMapping;
 import org.springframework.web.bind.annotation.RequestBody;
 import org.springframework.web.bind.annotation.RequestMapping;
-import org.springframework.web.bind.annotation.RequestMethod;
 import org.springframework.web.bind.annotation.RequestParam;
-import org.springframework.web.bind.annotation.ResponseBody;
 import org.springframework.web.bind.annotation.ResponseStatus;
 import org.springframework.web.bind.annotation.RestController;
-import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
 
-import javax.servlet.http.HttpServletRequest;
 import javax.validation.Valid;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
-import static me.exrates.service.util.OpenApiUtils.formatCurrencyPairNameParam;
-import static me.exrates.service.util.RestApiUtils.retrieveParamFormBody;
-import static org.springframework.http.HttpStatus.BAD_REQUEST;
-import static org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR;
-import static org.springframework.http.HttpStatus.NOT_ACCEPTABLE;
+import static me.exrates.utils.ApiUtil.currencyPairNameFormatter;
+import static me.exrates.utils.ApiUtil.getValueByParamName;
 
+@SuppressWarnings("DanglingJavadoc")
+@Log4j2
 @RestController
 @RequestMapping("/openapi/v1/orders")
 public class OpenApiOrderController {
@@ -85,16 +70,26 @@
     @ResponseStatus(HttpStatus.CREATED)
     @PreAuthorize("hasAuthority('TRADE')")
     @PostMapping(value = "/create", consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
-    public ResponseEntity<OrderCreationDto> createOrder(@RequestBody @Valid OrderParamsDto orderParamsDto,
-                                                        Errors errors) {
-        if (errors.hasErrors()) {
-            //todo: throw exception
-        }
-        String currencyPairName = formatCurrencyPairNameParam(orderParamsDto.getCurrencyPair());
-        String userEmail = userService.getUserEmailFromSecurityContext();
-        OrderCreationResultDto resultDto = orderService.prepareAndCreateOrderRest(currencyPairName, orderParamsDto.getOrderType().getOperationType(),
-                orderParamsDto.getAmount(), orderParamsDto.getPrice(), userEmail);
-        return ResponseEntity.ok(new OrderCreationDto(resultDto));
+    public ResponseEntity<OrderCreationDto> createOrder(@Valid @RequestBody OrderParamsRequest orderParamsRequest,
+                                                        BindingResult result) {
+        try {
+            if (result.hasErrors()) {
+                log.warn("Order parameters request has errors: {}", result.getAllErrors());
+                throw new ValidationException(result.getAllErrors());
+            }
+            final String currencyPairName = currencyPairNameFormatter(orderParamsRequest.getCurrencyPair());
+            final String userEmail = userService.getUserEmailFromSecurityContext();
+
+            OrderCreationResultDto resultDto = orderService.prepareAndCreateOrderRest(currencyPairName,
+                    orderParamsRequest.getOrderType().getOperationType(),
+                    orderParamsRequest.getAmount(),
+                    orderParamsRequest.getPrice(),
+                    userEmail);
+            return ResponseEntity.ok(new OrderCreationDto(resultDto));
+        } catch (ValidationException ex) {
+            log.error("Invalid request parameters passed. Not processing request");
+            return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build();
+        }
     }
 
     /**
@@ -103,7 +98,7 @@
      * @apiGroup Order API
      * @apiUse APIHeaders
      * @apiPermission NonPublicAuth
-     * @apiDescription Canceles order
+     * @apiDescription Cancels order
      * @apiParam {String} order_id Id of order to be cancelled
      * @apiParamExample Request Example:
      * /openapi/v1/orders/cancel
@@ -111,14 +106,13 @@
      * @apiSuccess {Map} success Cancellation result
      */
     @PreAuthorize("hasAuthority('TRADE')")
-    @RequestMapping(value = "/cancel", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE,
-            produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
-    public Map<String, Boolean> cancelOrder(@RequestBody Map<String, String> params) {
-        String orderIdString = retrieveParamFormBody(params, "order_id", true);
-        Integer orderId = Integer.parseInt(orderIdString);
-        String userEmail = userService.getUserEmailFromSecurityContext();
+    @PostMapping(value = "/cancel", consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
+    public ResponseEntity<Map<String, Boolean>> cancelOrder(@RequestBody Map<String, String> params) {
+        final Integer orderId = Integer.parseInt(getValueByParamName(params, "order_id", true));
+        final String userEmail = userService.getUserEmailFromSecurityContext();
+
         orderService.cancelOrder(orderId, userEmail);
-        return Collections.singletonMap("success", true);
+        return ResponseEntity.ok(Collections.singletonMap("success", true));
     }
 
     /**
@@ -135,14 +129,13 @@
      * @apiSuccess {Map} success=true Acceptance result
      */
     @PreAuthorize("hasAuthority('TRADE')")
-    @RequestMapping(value = "/accept", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE,
-            produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
-    public Map<String, Boolean> acceptOrder(@RequestBody Map<String, String> params) {
-        String orderIdString = retrieveParamFormBody(params, "order_id", true);
-        Integer orderId = Integer.parseInt(orderIdString);
-        String userEmail = userService.getUserEmailFromSecurityContext();
+    @PostMapping(value = "/accept", consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
+    public ResponseEntity<Map<String, Boolean>> acceptOrder(@RequestBody Map<String, String> params) {
+        final Integer orderId = Integer.parseInt(getValueByParamName(params, "order_id", true));
+        final String userEmail = userService.getUserEmailFromSecurityContext();
+
         orderService.acceptOrder(userEmail, orderId);
-        return Collections.singletonMap("success", true);
+        return ResponseEntity.ok(Collections.singletonMap("success", true));
     }
 
     /**
@@ -164,76 +157,10 @@
      * @apiSuccess {Number} data.price Exchange rate
      */
     @GetMapping(value = "/open/{order_type}", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
-    public List<OpenOrderDto> openOrders(@PathVariable("order_type") OrderType orderType,
-                                         @RequestParam("currency_pair") String currencyPair) {
-        String currencyPairName = formatCurrencyPairNameParam(currencyPair);
-        return orderService.getOpenOrders(currencyPairName, orderType);
-    }
-
-
-    @ResponseStatus(HttpStatus.FORBIDDEN)
-    @ExceptionHandler(value = AccessDeniedException.class)
-    public OpenApiError accessDeniedExceptionHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.ACCESS_DENIED, req.getRequestURL(), exception);
-    }
-
-    @ResponseStatus(BAD_REQUEST)
-    @ExceptionHandler({MethodArgumentNotValidException.class, OrderParamsWrongException.class, MethodArgumentTypeMismatchException.class})
-    @ResponseBody
-    public OpenApiError mismatchArgumentsErrorHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.INVALID_PARAM_VALUE, req.getRequestURL(), exception);
-    }
-
-    @ResponseStatus(BAD_REQUEST)
-    @ExceptionHandler(HttpMessageNotReadableException.class)
-    @ResponseBody
-    public OpenApiError jsonMappingExceptionHandler(HttpServletRequest req, HttpMessageNotReadableException exception) {
-        return new OpenApiError(ErrorCode.REQUEST_NOT_READABLE, req.getRequestURL(), "Invalid request format");
-    }
-
-    @ResponseStatus(BAD_REQUEST)
-    @ExceptionHandler(MissingServletRequestParameterException.class)
-    @ResponseBody
-    public OpenApiError missingServletRequestParameterHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.MISSING_REQUIRED_PARAM, req.getRequestURL(), exception);
-    }
-
-    @ResponseStatus(NOT_ACCEPTABLE)
-    @ExceptionHandler(CurrencyPairNotFoundException.class)
-    @ResponseBody
-    public OpenApiError currencyPairNotFoundExceptionHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.CURRENCY_PAIR_NOT_FOUND, req.getRequestURL(), exception);
-    }
-
-
-    @ResponseStatus(NOT_ACCEPTABLE)
-    @ExceptionHandler(InvalidCurrencyPairFormatException.class)
-    @ResponseBody
-    public OpenApiError invalidCurrencyPairFormatExceptionHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.INVALID_CURRENCY_PAIR_FORMAT, req.getRequestURL(), exception);
-    }
+    public ResponseEntity<List<OpenOrderDto>> openOrders(@PathVariable("order_type") OrderType orderType,
+                                                         @RequestParam("currency_pair") String currencyPair) {
+        final String currencyPairName = currencyPairNameFormatter(currencyPair);
 
-    @ResponseStatus(NOT_ACCEPTABLE)
-    @ExceptionHandler(AlreadyAcceptedOrderException.class)
-    @ResponseBody
-    public OpenApiError alreadyAcceptedOrderExceptionHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.ALREADY_ACCEPTED_ORDER, req.getRequestURL(), exception);
+        return ResponseEntity.ok(orderService.getOpenOrders(currencyPairName, orderType));
     }
-
-    @ResponseStatus(NOT_ACCEPTABLE)
-    @ExceptionHandler(OrderNotFoundException.class)
-    @ResponseBody
-    public OpenApiError orderNotFoundExceptionHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.ORDER_NOT_FOUND, req.getRequestURL(), exception);
-    }
-
-
-    @ResponseStatus(INTERNAL_SERVER_ERROR)
-    @ExceptionHandler(Exception.class)
-    @ResponseBody
-    public OpenApiError OtherErrorsHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.INTERNAL_SERVER_ERROR, req.getRequestURL(), "An internal error occured");
-    }
-
-
 }
Index: Controller/src/main/java/me/exrates/controller/openAPI/OpenApiPublicController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/java/me/exrates/controller/openAPI/OpenApiPublicController.java	(revision Local Version)
+++ Controller/src/main/java/me/exrates/controller/openAPI/OpenApiPublicController.java	(revision Shelved Version)
@@ -1,6 +1,5 @@
 package me.exrates.controller.openAPI;
 
-import me.exrates.service.exception.api.InvalidCurrencyPairFormatException;
 import me.exrates.model.dto.CoinmarketApiDto;
 import me.exrates.model.dto.openAPI.CurrencyPairInfoItem;
 import me.exrates.model.dto.openAPI.OrderBookItem;
@@ -9,32 +8,36 @@
 import me.exrates.model.enums.OrderType;
 import me.exrates.service.CurrencyService;
 import me.exrates.service.OrderService;
-import me.exrates.service.exception.CurrencyPairNotFoundException;
-import me.exrates.service.exception.api.ErrorCode;
-import me.exrates.service.exception.api.OpenApiError;
 import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.web.bind.MissingServletRequestParameterException;
-import org.springframework.web.bind.annotation.*;
-import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
+import org.springframework.http.MediaType;
+import org.springframework.http.ResponseEntity;
+import org.springframework.web.bind.annotation.GetMapping;
+import org.springframework.web.bind.annotation.PathVariable;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RequestParam;
+import org.springframework.web.bind.annotation.RestController;
 
-import javax.servlet.http.HttpServletRequest;
 import java.util.List;
 import java.util.Map;
-import java.util.stream.Collectors;
 
-import static me.exrates.service.util.OpenApiUtils.formatCurrencyPairNameParam;
-import static org.springframework.http.HttpStatus.*;
+import static java.util.Objects.nonNull;
+import static java.util.stream.Collectors.toList;
+import static me.exrates.utils.ApiUtil.currencyPairNameFormatter;
 
 @SuppressWarnings("DanglingJavadoc")
 @RestController
 @RequestMapping("/openapi/v1/public")
 public class OpenApiPublicController {
 
+    private final OrderService orderService;
+    private final CurrencyService currencyService;
+
     @Autowired
-    private OrderService orderService;
-
-    @Autowired
-    private CurrencyService currencyService;
+    public OpenApiPublicController(OrderService orderService,
+                                   CurrencyService currencyService) {
+        this.orderService = orderService;
+        this.currencyService = currencyService;
+    }
 
     /**
      * @api {get} /openapi/v1/public/ticker?currency_pair Ticker Info
@@ -44,7 +47,7 @@
      * @apiDescription Returns array of ticker info objects
      * @apiParam {String} currency_pair Currency pair name (optional)
      * @apiParamExample Request Example:
-     *      /openapi/v1/public/ticker?currency_pair=btc_usd
+     * /openapi/v1/public/ticker?currency_pair=btc_usd
      * @apiSuccess {Array} Ticker Infos result
      * @apiSuccess {Object} data Container object
      * @apiSuccess {Integer} data.id Currency pair id
@@ -74,23 +77,20 @@
      * }
      * ]
      */
-    @RequestMapping("/ticker")
-    public List<TickerJsonDto> getDailyTicker(@RequestParam(value = "currency_pair", required = false) String currencyPair) {
+    @GetMapping(value = "/ticker", produces = MediaType.APPLICATION_JSON_VALUE)
+    public ResponseEntity<List<TickerJsonDto>> getDailyTicker(@RequestParam(value = "currency_pair", required = false) String currencyPair) {
         String currencyPairName = null;
-        if (currencyPair != null) {
-            currencyPairName = formatCurrencyPairNameParam(currencyPair);
-            validateCurrencyPair(currencyPairName);
-        }
-        return formatCoinmarketData(orderService.getDailyCoinmarketData(currencyPairName));
-    }
+        if (nonNull(currencyPair)) {
+            currencyPairName = currencyPairNameFormatter(currencyPair);
 
-    private void validateCurrencyPair(String currencyPairName) {
-        currencyService.findCurrencyPairIdByName(currencyPairName);
-    }
-
-
-    private List<TickerJsonDto> formatCoinmarketData(List<CoinmarketApiDto> data) {
-        return data.stream().map(TickerJsonDto::new).collect(Collectors.toList());
+            currencyService.findCurrencyPairIdByName(currencyPairName);
+        }
+        final List<CoinmarketApiDto> dailyCoinMarketData = orderService.getDailyCoinmarketData(currencyPairName);
+        return ResponseEntity.ok(
+                dailyCoinMarketData.stream()
+                        .map(TickerJsonDto::new)
+                        .collect(toList())
+        );
     }
 
     /**
@@ -107,11 +107,12 @@
      * amount -	order amount in base currency
      * rate	- exchange rate
      */
-    @RequestMapping("/orderbook/{currency_pair}")
-    public Map<OrderType, List<OrderBookItem>> getOrderBook(@PathVariable(value = "currency_pair") String currencyPair,
-                                                            @RequestParam(value = "order_type", required = false) OrderType orderType) {
-        String currencyPairName = formatCurrencyPairNameParam(currencyPair);
-        return orderService.getOrderBook(currencyPairName, orderType);
+    @GetMapping(value = "/orderbook/{currency_pair}", produces = MediaType.APPLICATION_JSON_VALUE)
+    public ResponseEntity<Map<OrderType, List<OrderBookItem>>> getOrderBook(@PathVariable(value = "currency_pair") String currencyPair,
+                                                                            @RequestParam(value = "order_type", required = false) OrderType orderType) {
+        final String currencyPairName = currencyPairNameFormatter(currencyPair);
+
+        return ResponseEntity.ok(orderService.getOrderBook(currencyPairName, orderType));
     }
 
     /**
@@ -122,7 +123,7 @@
      * @apiDescription Provides collection of recent deal info objects
      * @apiParam {String} period period (available values: minute, hour, day, default: hour) (optional)
      * @apiParamExample Request Example:
-     *      openapi/v1/public/history/btc_usd?hour=1
+     * openapi/v1/public/history/btc_usd?hour=1
      * @apiSuccess {Array} Array of recent deals info objects
      * @apiSuccess {Object} data Container object
      * @apiSuccess {Integer} data.order_id Order id
@@ -131,12 +132,12 @@
      * @apiSuccess {Number} data.price Exchange rate
      * @apiSuccess {String} data.order_type Order type (BUY or SELL)
      */
-    @RequestMapping("/history/{currency_pair}")
-    public List<OrderHistoryItem> getRecentHistory(@PathVariable(value = "currency_pair") String currencyPair,
-                                                   @RequestParam(required = false, defaultValue = "hour") String period) {
+    @GetMapping(value = "/history/{currency_pair}", produces = MediaType.APPLICATION_JSON_VALUE)
+    public ResponseEntity<List<OrderHistoryItem>> getRecentHistory(@PathVariable(value = "currency_pair") String currencyPair,
+                                                                   @RequestParam(required = false, defaultValue = "hour") String period) {
+        final String currencyPairName = currencyPairNameFormatter(currencyPair);
 
-        String currencyPairName = formatCurrencyPairNameParam(currencyPair);
-        return orderService.getRecentOrderHistory(currencyPairName, period);
+        return ResponseEntity.ok(orderService.getRecentOrderHistory(currencyPairName, period));
     }
 
     /**
@@ -146,54 +147,14 @@
      * @apiPermission user
      * @apiDescription Provides collection of currency pairs
      * @apiParamExample Request Example:
-     *      openapi/v1/public/currency_pairs
+     * openapi/v1/public/currency_pairs
      * @apiSuccess {Array} Array of currency pairs
      * @apiSuccess {Object} data Container object
      * @apiSuccess {String} data.name Currency pair name
      * @apiSuccess {String} data.url_symbol URL symbol (name to be passed as URL parameter or path variable)
      */
-    @RequestMapping("/currency_pairs")
-    public List<CurrencyPairInfoItem> findActiveCurrencyPairs() {
-        return currencyService.findActiveCurrencyPairs();
-    }
-
-    @ResponseStatus(BAD_REQUEST)
-    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
-    @ResponseBody
-    public OpenApiError mismatchArgumentsErrorHandler(HttpServletRequest req, MethodArgumentTypeMismatchException exception) {
-        String detail = "Invalid param value : " + exception.getParameter().getParameterName();
-        return new OpenApiError(ErrorCode.INVALID_PARAM_VALUE, req.getRequestURL(), detail);
+    @GetMapping(value = "/currency_pairs", produces = MediaType.APPLICATION_JSON_VALUE)
+    public ResponseEntity<List<CurrencyPairInfoItem>> findActiveCurrencyPairs() {
+        return ResponseEntity.ok(currencyService.findActiveCurrencyPairs());
     }
-
-    @ResponseStatus(BAD_REQUEST)
-    @ExceptionHandler(MissingServletRequestParameterException.class)
-    @ResponseBody
-    public OpenApiError missingServletRequestParameterHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.MISSING_REQUIRED_PARAM, req.getRequestURL(), exception);
-    }
-
-    @ResponseStatus(NOT_ACCEPTABLE)
-    @ExceptionHandler(CurrencyPairNotFoundException.class)
-    @ResponseBody
-    public OpenApiError currencyPairNotFoundExceptionHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.CURRENCY_PAIR_NOT_FOUND, req.getRequestURL(), exception);
-    }
-
-
-    @ResponseStatus(NOT_ACCEPTABLE)
-    @ExceptionHandler(InvalidCurrencyPairFormatException.class)
-    @ResponseBody
-    public OpenApiError invalidCurrencyPairFormatExceptionHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.INVALID_CURRENCY_PAIR_FORMAT, req.getRequestURL(), exception);
-    }
-
-
-    @ResponseStatus(INTERNAL_SERVER_ERROR)
-    @ExceptionHandler(Exception.class)
-    @ResponseBody
-    public OpenApiError OtherErrorsHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.INTERNAL_SERVER_ERROR, req.getRequestURL(), exception);
-    }
-
-
 }
Index: Controller/src/main/java/me/exrates/controller/openAPI/OpenApiUserInfoController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/java/me/exrates/controller/openAPI/OpenApiUserInfoController.java	(revision Local Version)
+++ Controller/src/main/java/me/exrates/controller/openAPI/OpenApiUserInfoController.java	(revision Shelved Version)
@@ -6,36 +6,33 @@
 import me.exrates.model.dto.openAPI.WalletBalanceDto;
 import me.exrates.service.OrderService;
 import me.exrates.service.WalletService;
-import me.exrates.service.exception.CurrencyPairNotFoundException;
-import me.exrates.service.exception.api.ErrorCode;
-import me.exrates.service.exception.api.InvalidCurrencyPairFormatException;
-import me.exrates.service.exception.api.OpenApiError;
 import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.http.HttpStatus;
 import org.springframework.http.MediaType;
-import org.springframework.security.access.AccessDeniedException;
-import org.springframework.web.bind.MissingServletRequestParameterException;
-import org.springframework.web.bind.annotation.*;
-import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
+import org.springframework.http.ResponseEntity;
+import org.springframework.web.bind.annotation.GetMapping;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RequestParam;
+import org.springframework.web.bind.annotation.RestController;
 
-import javax.servlet.http.HttpServletRequest;
 import java.util.List;
 
-import static me.exrates.service.util.OpenApiUtils.formatCurrencyPairNameParam;
-import static org.springframework.http.HttpStatus.BAD_REQUEST;
-import static org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR;
-import static org.springframework.http.HttpStatus.NOT_ACCEPTABLE;
+import static java.util.Objects.nonNull;
+import static me.exrates.utils.ApiUtil.currencyPairNameFormatter;
 
 @SuppressWarnings("DanglingJavadoc")
 @RestController
 @RequestMapping("/openapi/v1/user")
 public class OpenApiUserInfoController {
 
+    private final WalletService walletService;
+    private final OrderService orderService;
+
     @Autowired
-    private WalletService walletService;
-
-    @Autowired
-    private OrderService orderService;
+    public OpenApiUserInfoController(WalletService walletService,
+                                     OrderService orderService) {
+        this.walletService = walletService;
+        this.orderService = orderService;
+    }
 
     /**
      * @apiDefine NonPublicAuth
@@ -49,7 +46,7 @@
      * @apiPermission NonPublicAuth
      * @apiDescription Returns array of wallet objects
      * @apiParamExample Request Example:
-     *           /openapi/v1/user/balances
+     * /openapi/v1/user/balances
      * @apiSuccess {Array} Wallet objects result
      * @apiSuccess {Object} data Container object
      * @apiSuccess {String} data.currencyName Name of currency
@@ -57,8 +54,8 @@
      * @apiSuccess {Number} data.reservedBalance Balance reserved for orders or withdraw
      */
     @GetMapping(value = "/balances", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
-    public List<WalletBalanceDto> userBalances() {
-        return walletService.getBalancesForUser();
+    public ResponseEntity<List<WalletBalanceDto>> userBalances() {
+        return ResponseEntity.ok(walletService.getBalancesForUser());
     }
 
     /**
@@ -69,7 +66,7 @@
      * @apiDescription Returns collection of user open orders
      * @apiParam {String} currency_pair Name of currency pair (optional)
      * @apiParamExample Request Example:
-     *           /openapi/v1/user/orders/open?currency_pair=btc_usd
+     * /openapi/v1/user/orders/open?currency_pair=btc_usd
      * @apiSuccess {Array} User orders result
      * @apiSuccess {Object} data Container object
      * @apiSuccess {Integer} data.id Order id
@@ -81,13 +78,13 @@
      * @apiSuccess {Number} data.date_accepted Acceptance time as UNIX timestamp in millis
      */
     @GetMapping(value = "/orders/open", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
-    public List<UserOrdersDto> userOpenOrders(@RequestParam(value = "currency_pair", required = false) String currencyPair) {
+    public ResponseEntity<List<UserOrdersDto>> userOpenOrders(@RequestParam(value = "currency_pair", required = false) String currencyPair) {
 
         String currencyPairName = null;
-        if (currencyPair != null) {
-            currencyPairName = formatCurrencyPairNameParam(currencyPair);
+        if (nonNull(currencyPair)) {
+            currencyPairName = currencyPairNameFormatter(currencyPair);
         }
-        return orderService.getUserOpenOrders(currencyPairName);
+        return ResponseEntity.ok(orderService.getUserOpenOrders(currencyPairName));
     }
 
     /**
@@ -100,7 +97,7 @@
      * @apiParam {Integer} limit Number of orders returned (default - 20, max - 100) (optional)
      * @apiParam {Integer} offset Number of orders skipped (optional)
      * @apiParamExample Request Example:
-     *           /openapi/v1/user/orders/closed?currency_pair=btc_usd&limit=100&offset=10
+     * /openapi/v1/user/orders/closed?currency_pair=btc_usd&limit=100&offset=10
      * @apiSuccess {Array} User orders result
      * @apiSuccess {Object} data Container object
      * @apiSuccess {Integer} data.id Order id
@@ -112,21 +109,22 @@
      * @apiSuccess {Number} data.date_accepted Acceptance time as UNIX timestamp in millis
      */
     @GetMapping(value = "/orders/closed", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
-    public List<UserOrdersDto> userClosedOrders(@RequestParam(value = "currency_pair", required = false) String currencyPair,
-                                                @RequestParam(required = false) Integer limit,
-                                                @RequestParam(required = false) Integer offset) {
+    public ResponseEntity<List<UserOrdersDto>> userClosedOrders(@RequestParam(value = "currency_pair", required = false) String currencyPair,
+                                                                @RequestParam(required = false) Integer limit,
+                                                                @RequestParam(required = false) Integer offset) {
 
         String currencyPairName = null;
-        if (currencyPair != null) {
-            currencyPairName = formatCurrencyPairNameParam(currencyPair);
+        if (nonNull(currencyPair)) {
+            currencyPairName = currencyPairNameFormatter(currencyPair);
         }
         validateNaturalInt(limit);
         validateNaturalInt(offset);
-        return orderService.getUserOrdersHistory(currencyPairName, limit, offset);
+
+        return ResponseEntity.ok(orderService.getUserOrdersHistory(currencyPairName, limit, offset));
     }
 
     private void validateNaturalInt(Integer number) {
-        if (number != null && number <= 0) {
+        if (nonNull(number) && number <= 0) {
             throw new InvalidNumberParamException("Invalid number: " + number);
         }
     }
@@ -140,7 +138,7 @@
      * (as per cent - for example, 0.5 rate means 0.5% of amount) by operation type.
      * Commissions for orders (sell and buy) are calculated and withdrawn from amount in quote currency.
      * @apiParamExample Request Example:
-     *      /openapi/v1/user/commissions
+     * /openapi/v1/user/commissions
      * @apiSuccess {Object} data Container object
      * @apiSuccess {Number} data.input Commission for input operations
      * @apiSuccess {Number} data.output Commission for output operations
@@ -149,53 +147,7 @@
      * @apiSuccess {Number} data.transfer Commission for transfer operations
      */
     @GetMapping(value = "/commissions", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
-    public OpenApiCommissionDto getCommissions() {
-        return new OpenApiCommissionDto(orderService.getAllCommissions());
-    }
-
-
-    @ResponseStatus(HttpStatus.FORBIDDEN)
-    @ExceptionHandler(value = AccessDeniedException.class)
-    public OpenApiError accessDeniedExceptionHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.ACCESS_DENIED, req.getRequestURL(), exception);
-    }
-
-    @ResponseStatus(BAD_REQUEST)
-    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
-    @ResponseBody
-    public OpenApiError mismatchArgumentsErrorHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.INVALID_PARAM_VALUE, req.getRequestURL(), exception);
-    }
-
-    @ResponseStatus(BAD_REQUEST)
-    @ExceptionHandler(MissingServletRequestParameterException.class)
-    @ResponseBody
-    public OpenApiError missingServletRequestParameterHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.MISSING_REQUIRED_PARAM, req.getRequestURL(), exception);
-    }
-
-    @ResponseStatus(NOT_ACCEPTABLE)
-    @ExceptionHandler(CurrencyPairNotFoundException.class)
-    @ResponseBody
-    public OpenApiError currencyPairNotFoundExceptionHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.CURRENCY_PAIR_NOT_FOUND, req.getRequestURL(), exception);
+    public ResponseEntity<OpenApiCommissionDto> getCommissions() {
+        return ResponseEntity.ok(new OpenApiCommissionDto(orderService.getAllCommissions()));
     }
-
-
-    @ResponseStatus(NOT_ACCEPTABLE)
-    @ExceptionHandler(InvalidCurrencyPairFormatException.class)
-    @ResponseBody
-    public OpenApiError invalidCurrencyPairFormatExceptionHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.INVALID_CURRENCY_PAIR_FORMAT, req.getRequestURL(), exception);
-    }
-
-
-    @ResponseStatus(INTERNAL_SERVER_ERROR)
-    @ExceptionHandler(Exception.class)
-    @ResponseBody
-    public OpenApiError OtherErrorsHandler(HttpServletRequest req, Exception exception) {
-        return new OpenApiError(ErrorCode.INTERNAL_SERVER_ERROR, req.getRequestURL(), exception);
-    }
-
-
 }
Index: Controller/src/main/java/me/exrates/controller/AdminController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/java/me/exrates/controller/AdminController.java	(revision Local Version)
+++ Controller/src/main/java/me/exrates/controller/AdminController.java	(revision Shelved Version)
@@ -3,12 +3,21 @@
 import com.google.common.base.Preconditions;
 import lombok.extern.log4j.Log4j2;
 import me.exrates.controller.annotation.AdminLoggable;
-import me.exrates.controller.exception.*;
+import me.exrates.controller.exception.ErrorInfo;
+import me.exrates.controller.exception.InvalidNumberParamException;
 import me.exrates.controller.exception.NoRequestedBeansFoundException;
 import me.exrates.controller.exception.NotAcceptableOrderException;
 import me.exrates.controller.exception.NotEnoughMoneyException;
 import me.exrates.controller.validator.RegisterFormValidation;
-import me.exrates.model.*;
+import me.exrates.model.BotLaunchSettings;
+import me.exrates.model.BotTrader;
+import me.exrates.model.Comment;
+import me.exrates.model.CurrencyLimit;
+import me.exrates.model.CurrencyPair;
+import me.exrates.model.Merchant;
+import me.exrates.model.RefillRequestAddressShortDto;
+import me.exrates.model.User;
+import me.exrates.model.UserRoleSettings;
 import me.exrates.model.dto.*;
 import me.exrates.model.dto.dataTable.DataTable;
 import me.exrates.model.dto.dataTable.DataTableParams;
@@ -16,17 +25,60 @@
 import me.exrates.model.dto.filterData.AdminStopOrderFilterData;
 import me.exrates.model.dto.filterData.AdminTransactionsFilterData;
 import me.exrates.model.dto.filterData.RefillAddressFilterData;
-import me.exrates.model.dto.merchants.btc.*;
+import me.exrates.model.dto.merchants.btc.BtcAdminPaymentResponseDto;
+import me.exrates.model.dto.merchants.btc.BtcAdminPreparedTxDto;
+import me.exrates.model.dto.merchants.btc.BtcPreparedTransactionDto;
+import me.exrates.model.dto.merchants.btc.BtcWalletPaymentItemDto;
+import me.exrates.model.dto.merchants.btc.CoreWalletDto;
 import me.exrates.model.dto.onlineTableDto.AccountStatementDto;
 import me.exrates.model.dto.onlineTableDto.OrderWideListDto;
-import me.exrates.model.enums.*;
-import me.exrates.model.enums.invoice.*;
+import me.exrates.model.enums.ActionType;
+import me.exrates.model.enums.AlertType;
+import me.exrates.model.enums.BusinessUserRoleEnum;
+import me.exrates.model.enums.CurrencyPairType;
+import me.exrates.model.enums.MerchantProcessType;
+import me.exrates.model.enums.NotificationEvent;
+import me.exrates.model.enums.NotificationMessageEventEnum;
+import me.exrates.model.enums.NotificationPayTypeEnum;
+import me.exrates.model.enums.OperationType;
+import me.exrates.model.enums.OrderStatus;
+import me.exrates.model.enums.OrderType;
+import me.exrates.model.enums.ReportGroupUserRole;
+import me.exrates.model.enums.TransactionType;
+import me.exrates.model.enums.UserCommentTopicEnum;
+import me.exrates.model.enums.UserRole;
+import me.exrates.model.enums.UserStatus;
+import me.exrates.model.enums.invoice.InvoiceOperationDirection;
+import me.exrates.model.enums.invoice.InvoiceStatus;
+import me.exrates.model.enums.invoice.WithdrawStatusEnum;
 import me.exrates.model.form.AuthorityOptionsForm;
 import me.exrates.model.util.BigDecimalProcessing;
 import me.exrates.model.vo.BackDealInterval;
 import me.exrates.security.service.UserSecureService;
-import me.exrates.service.*;
-import me.exrates.service.exception.*;
+import me.exrates.service.BitcoinService;
+import me.exrates.service.BotService;
+import me.exrates.service.CommissionService;
+import me.exrates.service.CurrencyService;
+import me.exrates.service.MerchantService;
+import me.exrates.service.NotificationService;
+import me.exrates.service.OrderService;
+import me.exrates.service.PhraseTemplateService;
+import me.exrates.service.ReferralService;
+import me.exrates.service.RefillService;
+import me.exrates.service.TransactionService;
+import me.exrates.service.UserFilesService;
+import me.exrates.service.UserRoleService;
+import me.exrates.service.UserService;
+import me.exrates.service.UserTransferService;
+import me.exrates.service.UsersAlertsService;
+import me.exrates.service.WalletService;
+import me.exrates.service.WithdrawService;
+import me.exrates.service.exception.NotCreatableOrderException;
+import me.exrates.service.exception.NotEnoughUserWalletMoneyException;
+import me.exrates.service.exception.OrderAcceptionException;
+import me.exrates.service.exception.OrderCancellingException;
+import me.exrates.service.exception.OrderCreationException;
+import me.exrates.service.exception.RefillRequestAppropriateNotFoundException;
 import me.exrates.service.merchantStrategy.IMerchantService;
 import me.exrates.service.merchantStrategy.MerchantServiceContext;
 import me.exrates.service.notifications.NotificationsSettingsService;
@@ -57,7 +109,17 @@
 import org.springframework.validation.BindException;
 import org.springframework.validation.BindingResult;
 import org.springframework.web.bind.MethodArgumentNotValidException;
-import org.springframework.web.bind.annotation.*;
+import org.springframework.web.bind.annotation.ExceptionHandler;
+import org.springframework.web.bind.annotation.GetMapping;
+import org.springframework.web.bind.annotation.ModelAttribute;
+import org.springframework.web.bind.annotation.PathVariable;
+import org.springframework.web.bind.annotation.PostMapping;
+import org.springframework.web.bind.annotation.RequestBody;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RequestMethod;
+import org.springframework.web.bind.annotation.RequestParam;
+import org.springframework.web.bind.annotation.ResponseBody;
+import org.springframework.web.bind.annotation.ResponseStatus;
 import org.springframework.web.context.request.RequestContextHolder;
 import org.springframework.web.multipart.MultipartFile;
 import org.springframework.web.servlet.LocaleResolver;
@@ -77,7 +139,20 @@
 import java.security.Principal;
 import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Future;
 import java.util.stream.Collectors;
@@ -94,7 +169,9 @@
 import static me.exrates.model.enums.invoice.InvoiceOperationDirection.TRANSFER_VOUCHER;
 import static me.exrates.model.enums.invoice.InvoiceOperationDirection.WITHDRAW;
 import static me.exrates.model.util.BigDecimalProcessing.doAction;
-import static org.springframework.http.HttpStatus.*;
+import static org.springframework.http.HttpStatus.BAD_REQUEST;
+import static org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR;
+import static org.springframework.http.HttpStatus.OK;
 import static org.springframework.web.bind.annotation.RequestMethod.GET;
 import static org.springframework.web.bind.annotation.RequestMethod.POST;
 
@@ -323,7 +400,7 @@
   @ResponseBody
   @RequestMapping(value = "/2a8fy7b07dxe44/wallets", method = GET, produces = MediaType.APPLICATION_JSON_VALUE)
   public Collection<WalletFormattedDto> getUserWallets(@RequestParam int id) {
-    boolean getExtendedInfo = userService.getUserRoleFromDB(id).showExtendedOrderInfo();
+    boolean getExtendedInfo = userService.getUserRoleFromDB(id).isShowExtendedOrderInfo();
     return getExtendedInfo ? walletService.getAllUserWalletsForAdminDetailed(id) :
             walletService.getAllWallets(id).stream().map(WalletFormattedDto::new).collect(Collectors.toList());
   }
@@ -503,7 +580,7 @@
     }
 
     model.addObject("user", user);
-    model.addObject("roleSettings", userRoleService.retrieveSettingsForRole(user.getRole().getRole()));
+    model.addObject("roleSettings", userRoleService.retrieveSettingsForRole(user.getRole().getCode()));
     model.addObject("currencies", currencyService.findAllCurrencies());
     model.addObject("currencyPairs", currencyService.getAllCurrencyPairsInAlphabeticOrder(CurrencyPairType.ALL));
     model.setViewName("admin/editUser");
@@ -525,7 +602,7 @@
     model.addObject("usersInvoiceTransferCurrencyPermissions", currencyService.findWithOperationPermissionByUserAndDirection(user.getId(), TRANSFER_VOUCHER));
     model.addObject("user2faOptions", notificationsSettingsService.get2faOptionsForUser(user.getId()));
     model.addObject("manualChangeAllowed", walletService.isUserAllowedToManuallyChangeWalletBalance(principal.getName(), user.getId()));
-    model.addObject("walletsExtendedInfoRequired", user.getRole().showExtendedOrderInfo());
+    model.addObject("walletsExtendedInfoRequired", user.getRole().isShowExtendedOrderInfo());
     return model;
   }
 
@@ -573,7 +650,7 @@
     NotificatorSubscription subscription = subscribable.getSubscription(userId);
     Preconditions.checkState(subscription.isConnected());
     String contact = Preconditions.checkNotNull(subscription.getContactStr());
-    int roleId = userService.getUserRoleFromDB(userId).getRole();
+    int roleId = userService.getUserRoleFromDB(userId).getCode();
     BigDecimal fee = notificatorsService.getMessagePrice(notificatorId, roleId);
     BigDecimal price = doAction(fee, subscription.getPrice(), ActionType.ADD);
     return new JSONObject(){{put("contact", contact);
@@ -990,7 +1067,7 @@
   @ResponseBody
   public List<CurrencyLimit> retrieveCurrencyLimits(@RequestParam String roleName,
                                                     @RequestParam OperationType operationType) {
-    return currencyService.retrieveCurrencyLimitsForRole(roleName, operationType);
+    return currencyService.getCurrencyLimitsForRole(roleName, operationType);
   }
 
   @AdminLoggable
Index: Controller/src/main/java/me/exrates/controller/EntryController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/java/me/exrates/controller/EntryController.java	(revision Local Version)
+++ Controller/src/main/java/me/exrates/controller/EntryController.java	(revision Shelved Version)
@@ -2,17 +2,43 @@
 
 import com.google.common.base.Preconditions;
 import lombok.extern.log4j.Log4j2;
-import me.exrates.controller.exception.*;
-import me.exrates.model.*;
-import me.exrates.model.dto.*;
-import me.exrates.model.enums.*;
+import me.exrates.controller.exception.ErrorInfo;
+import me.exrates.controller.exception.FileLoadingException;
+import me.exrates.controller.exception.NewsCreationException;
+import me.exrates.controller.exception.NoFileForLoadingException;
+import me.exrates.model.CurrencyPair;
+import me.exrates.model.News;
+import me.exrates.model.NotificationOption;
+import me.exrates.model.SessionParams;
+import me.exrates.model.User;
+import me.exrates.model.UserFile;
+import me.exrates.model.dto.NotificationsUserSetting;
+import me.exrates.model.dto.NotificatorSubscription;
+import me.exrates.model.dto.NotificatorTotalPriceDto;
+import me.exrates.model.dto.OrderCreateDto;
+import me.exrates.model.dto.SmsSubscriptionDto;
+import me.exrates.model.dto.TelegramSubscription;
+import me.exrates.model.enums.ActionType;
+import me.exrates.model.enums.CurrencyPairType;
+import me.exrates.model.enums.NotificationMessageEventEnum;
+import me.exrates.model.enums.NotificationTypeEnum;
+import me.exrates.model.enums.SessionLifeTypeEnum;
+import me.exrates.model.enums.UserRole;
 import me.exrates.model.form.NotificationOptionsForm;
-import me.exrates.service.*;
+import me.exrates.service.CurrencyService;
+import me.exrates.service.NewsService;
+import me.exrates.service.NotificationService;
+import me.exrates.service.ReferralService;
+import me.exrates.service.SessionParamsService;
+import me.exrates.service.UserRoleService;
+import me.exrates.service.UserService;
 import me.exrates.service.exception.IncorrectSmsPinException;
 import me.exrates.service.exception.PaymentException;
 import me.exrates.service.exception.ServiceUnavailableException;
 import me.exrates.service.exception.UnoperableNumberException;
-import me.exrates.service.notifications.*;
+import me.exrates.service.notifications.NotificationsSettingsService;
+import me.exrates.service.notifications.NotificatorsService;
+import me.exrates.service.notifications.Subscribable;
 import org.apache.commons.lang.math.NumberUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -24,7 +50,13 @@
 import org.springframework.http.HttpStatus;
 import org.springframework.stereotype.Controller;
 import org.springframework.util.StringUtils;
-import org.springframework.web.bind.annotation.*;
+import org.springframework.web.bind.annotation.ExceptionHandler;
+import org.springframework.web.bind.annotation.ModelAttribute;
+import org.springframework.web.bind.annotation.PathVariable;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RequestParam;
+import org.springframework.web.bind.annotation.ResponseBody;
+import org.springframework.web.bind.annotation.ResponseStatus;
 import org.springframework.web.servlet.LocaleResolver;
 import org.springframework.web.servlet.ModelAndView;
 import org.springframework.web.servlet.mvc.support.RedirectAttributes;
@@ -33,7 +65,6 @@
 
 import javax.servlet.http.HttpServletRequest;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.math.BigDecimal;
 import java.nio.file.Files;
 import java.nio.file.Paths;
@@ -142,7 +173,7 @@
             int userStatus = user.getStatus().getStatus();
             model.addObject("userEmail", principal.getName());
             model.addObject("userStatus", userStatus);
-            model.addObject("roleSettings", userRoleService.retrieveSettingsForRole(user.getRole().getRole()));
+            model.addObject("roleSettings", userRoleService.retrieveSettingsForRole(user.getRole().getCode()));
             model.addObject("referalPercents", referralService.findAllReferralLevels()
                                                 .stream()
                                                 .filter(p->p.getPercent().compareTo(BigDecimal.ZERO) > 0)
@@ -152,7 +183,7 @@
             request.getSession().setAttribute("lastPageBeforeLogin", request.getRequestURI());
         }
         if (currencyPair != null){
-            currencyService.findPermitedCurrencyPairs(CurrencyPairType.MAIN).stream()
+            currencyService.findPermittedCurrencyPairs(CurrencyPairType.MAIN).stream()
                     .filter(p->p.getPairType() == CurrencyPairType.MAIN)
                     .filter(p-> p.getName().equals(currencyPair))
                     .limit(1)
@@ -209,7 +240,7 @@
             int userStatus = user.getStatus().getStatus();
             model.addObject("userEmail", principal.getName());
             model.addObject("userStatus", userStatus);
-            model.addObject("roleSettings", userRoleService.retrieveSettingsForRole(user.getRole().getRole()));
+            model.addObject("roleSettings", userRoleService.retrieveSettingsForRole(user.getRole().getCode()));
             model.addObject("referalPercents", referralService.findAllReferralLevels()
                     .stream()
                     .filter(p->p.getPercent().compareTo(BigDecimal.ZERO) > 0)
@@ -219,7 +250,7 @@
             request.getSession().setAttribute("lastPageBeforeLogin", request.getRequestURI());
         }
         if (currencyPair != null){
-            currencyService.findPermitedCurrencyPairs(CurrencyPairType.ICO).stream()
+            currencyService.findPermittedCurrencyPairs(CurrencyPairType.ICO).stream()
                     .filter(p->p.getPairType() == CurrencyPairType.ICO)
                     .filter(p-> p.getName().equals(currencyPair))
                     .limit(1)
@@ -277,7 +308,7 @@
             int userStatus = user.getStatus().getStatus();
             model.addObject("userEmail", principal.getName());
             model.addObject("userStatus", userStatus);
-            model.addObject("roleSettings", userRoleService.retrieveSettingsForRole(user.getRole().getRole()));
+            model.addObject("roleSettings", userRoleService.retrieveSettingsForRole(user.getRole().getCode()));
             model.addObject("referalPercents", referralService.findAllReferralLevels()
                     .stream()
                     .filter(p->p.getPercent().compareTo(BigDecimal.ZERO) > 0)
@@ -287,7 +318,7 @@
             request.getSession().setAttribute("lastPageBeforeLogin", request.getRequestURI());
         }
         if (currencyPair != null){
-            currencyService.findPermitedCurrencyPairs(CurrencyPairType.MAIN).stream()
+            currencyService.findPermittedCurrencyPairs(CurrencyPairType.MAIN).stream()
                     .filter(p-> p.getName().equals(currencyPair))
                     .limit(1)
                     .forEach(p-> model.addObject("preferedCurrencyPairName", currencyPair));
@@ -409,7 +440,7 @@
         Subscribable subscribable = Preconditions.checkNotNull(notificatorService.getByNotificatorId(id));
         Object subscription = subscribable.getSubscription(userService.getIdByEmail(principal.getName()));
         UserRole role = userService.getUserRoleFromDB(principal.getName());
-        NotificatorTotalPriceDto dto = notificatorService.getPrices(id, role.getRole());
+        NotificatorTotalPriceDto dto = notificatorService.getPrices(id, role.getCode());
         if (subscription != null && subscription instanceof TelegramSubscription) {
             if (!((TelegramSubscription) subscription).getSubscriptionState().isBeginState()) {
                 throw new IllegalStateException();
@@ -477,7 +508,7 @@
         NotificatorSubscription subscription = subscribable.getSubscription(userService.getIdByEmail(principal.getName()));
         Preconditions.checkState(subscription.isConnected());
         String contact = Preconditions.checkNotNull(subscription.getContactStr());
-        int roleId = userService.getUserRoleFromSecurityContext().getRole();
+        int roleId = userService.getUserRoleFromSecurityContext().getCode();
         BigDecimal feePercent = notificatorService.getMessagePrice(id, roleId);
         BigDecimal price = doAction(doAction(subscription.getPrice(), feePercent, ActionType.MULTIPLY_PERCENT), subscription.getPrice(), ActionType.ADD);
         return new JSONObject(){{put("contact", contact);
Index: Controller/src/main/java/me/exrates/utils/ApiUtil.java
===================================================================
--- Controller/src/main/java/me/exrates/utils/ApiUtil.java	(revision Shelved Version)
+++ Controller/src/main/java/me/exrates/utils/ApiUtil.java	(revision Shelved Version)
@@ -0,0 +1,30 @@
+package me.exrates.utils;
+
+import me.exrates.service.exception.api.InvalidCurrencyPairFormatException;
+import me.exrates.service.exception.api.MissingBodyParamException;
+import org.apache.commons.lang.StringUtils;
+
+import java.util.Map;
+import java.util.function.Predicate;
+import java.util.regex.Pattern;
+
+public final class ApiUtil {
+
+    private static final Predicate<String> CURRENCY_PAIR_NAME_PATTERN = Pattern.compile("^[a-z0-9]{2,8}_[a-z0-9]{2,8}$").asPredicate();
+
+    public static String currencyPairNameFormatter(String currencyPair) {
+        if (!CURRENCY_PAIR_NAME_PATTERN.test(currencyPair)) {
+            throw new InvalidCurrencyPairFormatException(currencyPair);
+        }
+        return currencyPair.replace('_', '/').toUpperCase();
+    }
+
+    public static String getValueByParamName(Map<String, String> body, String paramName, boolean required) {
+        String value = body.get(paramName);
+
+        if (required && StringUtils.isEmpty(value)) {
+            throw new MissingBodyParamException(String.format("Param %s is missing", paramName));
+        }
+        return value;
+    }
+}
Index: Controller/src/main/webapp/WEB-INF/jsp/admin/notificatorsSettings.jsp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/webapp/WEB-INF/jsp/admin/notificatorsSettings.jsp	(revision Local Version)
+++ Controller/src/main/webapp/WEB-INF/jsp/admin/notificatorsSettings.jsp	(revision Shelved Version)
@@ -24,7 +24,7 @@
                     <div class="col-sm-6">
                         <select id="roleName" class="input-block-wrapper__input admin-form-input">
                             <c:forEach items="${roles}" var="role">
-                                <option value="${role.role}">${role}</option>
+                                <option value="${role.code}">${role}</option>
                             </c:forEach>
                         </select>
                         <p><loc:message code="admin.smsAbout"/></p>
Index: Controller/src/main/webapp/WEB-INF/jsp/admin/order_delete.jsp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Controller/src/main/webapp/WEB-INF/jsp/admin/order_delete.jsp	(revision Local Version)
+++ Controller/src/main/webapp/WEB-INF/jsp/admin/order_delete.jsp	(revision Shelved Version)
@@ -177,7 +177,7 @@
                             <select id="creatorRole" class="input-block-wrapper__input admin-form-input" name="creatorRole">
                                 <option value="">ANY</option>
                                 <c:forEach items="${roleList}" var="role">
-                                    <option value="${role.role}">${role.name()}</option>
+                                    <option value="${role.code}">${role.name()}</option>
                                 </c:forEach>
                             </select>
                         </div>
Index: Dao/src/main/java/me/exrates/dao/impl/CommissionDaoImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Dao/src/main/java/me/exrates/dao/impl/CommissionDaoImpl.java	(revision Local Version)
+++ Dao/src/main/java/me/exrates/dao/impl/CommissionDaoImpl.java	(revision Shelved Version)
@@ -19,199 +19,198 @@
 @Repository
 public class CommissionDaoImpl implements CommissionDao {
 
-	@Autowired
-	private MessageSource messageSource;
+    @Autowired
+    private MessageSource messageSource;
 
-	private static final RowMapper<Commission> commissionRowMapper = (resultSet, i) -> {
-		Commission commission = new Commission();
-		commission.setDateOfChange(resultSet.getDate("date"));
-		commission.setId(resultSet.getInt("id"));
-		commission.setOperationType(OperationType.convert(resultSet.getInt("operation_type")));
-		commission.setValue(resultSet.getBigDecimal("value"));
-		return commission;
-	};
+    private static final RowMapper<Commission> commissionRowMapper = (resultSet, i) -> {
+        Commission commission = new Commission();
+        commission.setDateOfChange(resultSet.getDate("date"));
+        commission.setId(resultSet.getInt("id"));
+        commission.setOperationType(OperationType.convert(resultSet.getInt("operation_type")));
+        commission.setValue(resultSet.getBigDecimal("value"));
+        return commission;
+    };
 
 
-	@Autowired
-	@Qualifier(value = "masterTemplate")
-	NamedParameterJdbcTemplate jdbcTemplate;
+    @Autowired
+    @Qualifier(value = "masterTemplate")
+    NamedParameterJdbcTemplate jdbcTemplate;
 
-	@Override
-	public Commission getCommission(OperationType operationType, UserRole userRole) {
-		final String sql = "SELECT COMMISSION.id, COMMISSION.operation_type, COMMISSION.date, COMMISSION.value " +
-				"FROM COMMISSION " +
-				"WHERE operation_type = :operation_type AND user_role = :role_id";
-		final HashMap<String,Integer> params = new HashMap<>();
-		params.put("operation_type",operationType.type);
-		params.put("role_id", userRole.getRole());
-		return jdbcTemplate.queryForObject(sql,params, commissionRowMapper);
-	}
+    @Override
+    public Commission getCommission(OperationType operationType, UserRole userRole) {
+        final String sql = "SELECT COMMISSION.id, COMMISSION.operation_type, COMMISSION.date, COMMISSION.value " +
+                "FROM COMMISSION " +
+                "WHERE operation_type = :operation_type AND user_role = :role_id";
+        final HashMap<String, Integer> params = new HashMap<>();
+        params.put("operation_type", operationType.getCode());
+        params.put("role_id", userRole.getCode());
+        return jdbcTemplate.queryForObject(sql, params, commissionRowMapper);
+    }
 
-	@Override
-	public Commission getCommission(OperationType operationType, Integer userId) {
-		final String sql = "SELECT COMMISSION.id, COMMISSION.operation_type, COMMISSION.date, COMMISSION.value " +
-				"FROM COMMISSION " +
-				"JOIN USER ON USER.id = :user_id " +
-				"WHERE operation_type = :operation_type AND user_role = USER.roleid";
-		final HashMap<String,Integer> params = new HashMap<>();
-		params.put("operation_type",operationType.type);
-		params.put("user_id", userId);
-		return jdbcTemplate.queryForObject(sql,params, commissionRowMapper);
-	}
+    @Override
+    public Commission getCommission(OperationType operationType, Integer userId) {
+        final String sql = "SELECT COMMISSION.id, COMMISSION.operation_type, COMMISSION.date, COMMISSION.value " +
+                "FROM COMMISSION " +
+                "JOIN USER ON USER.id = :user_id " +
+                "WHERE operation_type = :operation_type AND user_role = USER.roleid";
+        final HashMap<String, Integer> params = new HashMap<>();
+        params.put("operation_type", operationType.getCode());
+        params.put("user_id", userId);
+        return jdbcTemplate.queryForObject(sql, params, commissionRowMapper);
+    }
 
-	@Override
-	public Commission getDefaultCommission(OperationType operationType) {
-		final String sql = "SELECT id, operation_type, date, value " +
-				"FROM COMMISSION " +
-				"WHERE operation_type = :operation_type AND user_role = 4;";
-		final HashMap<String,Integer> params = new HashMap<>();
-		params.put("operation_type",operationType.type);
-		return jdbcTemplate.queryForObject(sql,params,commissionRowMapper);
-	}
+    @Override
+    public Commission getDefaultCommission(OperationType operationType) {
+        final String sql = "SELECT id, operation_type, date, value " +
+                "FROM COMMISSION " +
+                "WHERE operation_type = :operation_type AND user_role = 4;";
+        final HashMap<String, Integer> params = new HashMap<>();
+        params.put("operation_type", operationType.getCode());
+        return jdbcTemplate.queryForObject(sql, params, commissionRowMapper);
+    }
 
 
-	@Override
-	public BigDecimal getCommissionMerchant(String merchant, String currency, OperationType operationType) {
-		String selectedField = resolveCommissionDataField(operationType);
-		final String sql = "SELECT " + selectedField + " FROM birzha.MERCHANT_CURRENCY " +
-				"where merchant_id = (select id from MERCHANT where name = :merchant) \n" +
-				"and currency_id = (select id from CURRENCY where name = :currency)";
-		final HashMap<String, String> params = new HashMap<>();
-		params.put("currency", currency);
-		params.put("merchant", merchant);
-		return BigDecimal.valueOf(jdbcTemplate.queryForObject(sql, params, Double.class));
-	}
+    @Override
+    public BigDecimal getCommissionMerchant(String merchant, String currency, OperationType operationType) {
+        String selectedField = resolveCommissionDataField(operationType);
+        final String sql = "SELECT " + selectedField + " FROM birzha.MERCHANT_CURRENCY " +
+                "where merchant_id = (select id from MERCHANT where name = :merchant) \n" +
+                "and currency_id = (select id from CURRENCY where name = :currency)";
+        final HashMap<String, String> params = new HashMap<>();
+        params.put("currency", currency);
+        params.put("merchant", merchant);
+        return BigDecimal.valueOf(jdbcTemplate.queryForObject(sql, params, Double.class));
+    }
 
-	@Override
-	public BigDecimal getCommissionMerchant(Integer merchantId, Integer currencyId, OperationType operationType) {
-		String selectedField = resolveCommissionDataField(operationType);
-		final String sql = "SELECT " + selectedField + " FROM MERCHANT_CURRENCY " +
-				"where merchant_id = :merchant_id " +
-				"and currency_id = :currency_id ";
-		final HashMap<String, Object> params = new HashMap<>();
-		params.put("currency_id", currencyId);
-		params.put("merchant_id", merchantId);
-		return BigDecimal.valueOf(jdbcTemplate.queryForObject(sql, params, Double.class));
-	}
+    @Override
+    public BigDecimal getCommissionMerchant(Integer merchantId, Integer currencyId, OperationType operationType) {
+        String selectedField = resolveCommissionDataField(operationType);
+        final String sql = "SELECT " + selectedField + " FROM MERCHANT_CURRENCY " +
+                "where merchant_id = :merchant_id " +
+                "and currency_id = :currency_id ";
+        final HashMap<String, Object> params = new HashMap<>();
+        params.put("currency_id", currencyId);
+        params.put("merchant_id", merchantId);
+        return BigDecimal.valueOf(jdbcTemplate.queryForObject(sql, params, Double.class));
+    }
 
-	private String resolveCommissionDataField(OperationType operationType) {
-		String selectedField;
-		switch (operationType){
-			case INPUT: {
-				selectedField = "merchant_input_commission";
-				break;
-			}
-			case OUTPUT: {
-				selectedField = "merchant_output_commission";
-				break;
-			}
-			case USER_TRANSFER: {
-				selectedField = "merchant_transfer_commission";
-				break;
-			}
-			default: {
-				throw new IllegalArgumentException("Invalid operation type: "+operationType);
-			}
-		}
-		return selectedField;
-	}
+    private String resolveCommissionDataField(OperationType operationType) {
+        String selectedField;
+        switch (operationType) {
+            case INPUT: {
+                selectedField = "merchant_input_commission";
+                break;
+            }
+            case OUTPUT: {
+                selectedField = "merchant_output_commission";
+                break;
+            }
+            case USER_TRANSFER: {
+                selectedField = "merchant_transfer_commission";
+                break;
+            }
+            default: {
+                throw new IllegalArgumentException("Invalid operation type: " + operationType);
+            }
+        }
+        return selectedField;
+    }
 
-	@Override
-	public List<Commission> getEditableCommissions() {
-		final String sql = "SELECT COMMISSION.id, COMMISSION.operation_type, COMMISSION.value, " +
-				"COMMISSION.date, USER_ROLE.name AS user_role_name " +
-				"FROM COMMISSION " +
-				"JOIN USER_ROLE ON COMMISSION.user_role = USER_ROLE.id " +
-				"WHERE COMMISSION.operation_type NOT IN (5, 6, 7, 8) " +
-				"ORDER BY COMMISSION.id";
-		return jdbcTemplate.query(sql, (resultSet, i) -> {
-			Commission commission = new Commission();
-			commission.setOperationType(OperationType.convert(resultSet.getInt("operation_type")));
-			commission.setValue(resultSet.getBigDecimal("value"));
-			return commission;
-		});
-	}
+    @Override
+    public List<Commission> getEditableCommissions() {
+        final String sql = "SELECT COMMISSION.id, COMMISSION.operation_type, COMMISSION.value, " +
+                "COMMISSION.date, USER_ROLE.name AS user_role_name " +
+                "FROM COMMISSION " +
+                "JOIN USER_ROLE ON COMMISSION.user_role = USER_ROLE.id " +
+                "WHERE COMMISSION.operation_type NOT IN (5, 6, 7, 8) " +
+                "ORDER BY COMMISSION.id";
+        return jdbcTemplate.query(sql, (resultSet, i) -> {
+            Commission commission = new Commission();
+            commission.setOperationType(OperationType.convert(resultSet.getInt("operation_type")));
+            commission.setValue(resultSet.getBigDecimal("value"));
+            return commission;
+        });
+    }
 
-	@Override
-	public List<CommissionShortEditDto> getEditableCommissionsByRoles(List<Integer> roleIds, Locale locale) {
-		final String sql = "SELECT DISTINCT COMMISSION.operation_type, COMMISSION.value " +
-				"FROM COMMISSION " +
-				"JOIN USER_ROLE ON COMMISSION.user_role = USER_ROLE.id " +
-				"WHERE COMMISSION.user_role IN(:roles) AND COMMISSION.operation_type NOT IN (5, 6, 7, 8) " +
-				"ORDER BY COMMISSION.operation_type";
-		Map<String, List<Integer>> params = Collections.singletonMap("roles", roleIds);
-		return jdbcTemplate.query(sql, params, (resultSet, i) -> {
-			CommissionShortEditDto commission = new CommissionShortEditDto();
-			OperationType operationType = OperationType.convert(resultSet.getInt("operation_type"));
-			commission.setOperationType(operationType);
-			commission.setOperationTypeLocalized(operationType.toString(messageSource, locale));
-			commission.setValue(resultSet.getBigDecimal("value"));
-			return commission;
-		});
-	}
+    @Override
+    public List<CommissionShortEditDto> getEditableCommissionsByRoles(List<Integer> roleIds, Locale locale) {
+        final String sql = "SELECT DISTINCT COMMISSION.operation_type, COMMISSION.value " +
+                "FROM COMMISSION " +
+                "JOIN USER_ROLE ON COMMISSION.user_role = USER_ROLE.id " +
+                "WHERE COMMISSION.user_role IN(:roles) AND COMMISSION.operation_type NOT IN (5, 6, 7, 8) " +
+                "ORDER BY COMMISSION.operation_type";
+        Map<String, List<Integer>> params = Collections.singletonMap("roles", roleIds);
+        return jdbcTemplate.query(sql, params, (resultSet, i) -> {
+            CommissionShortEditDto commission = new CommissionShortEditDto();
+            OperationType operationType = OperationType.convert(resultSet.getInt("operation_type"));
+            commission.setOperationType(operationType);
+            commission.setOperationTypeLocalized(operationType.toString(messageSource, locale));
+            commission.setValue(resultSet.getBigDecimal("value"));
+            return commission;
+        });
+    }
 
 
-
-	@Override
-	public void updateCommission(Integer id, BigDecimal value) {
-		final String sql = "UPDATE COMMISSION SET value = :value, date = NOW() where id = :id";
-		Map<String, Number> params = new HashMap<String, Number>() {{
-			put("id", id);
-			put("value", value);
-		}};
-		jdbcTemplate.update(sql, params);
-	}
+    @Override
+    public void updateCommission(Integer id, BigDecimal value) {
+        final String sql = "UPDATE COMMISSION SET value = :value, date = NOW() where id = :id";
+        Map<String, Number> params = new HashMap<String, Number>() {{
+            put("id", id);
+            put("value", value);
+        }};
+        jdbcTemplate.update(sql, params);
+    }
 
-	@Override
-	public void updateCommission(OperationType operationType, List<Integer> roleIds, BigDecimal value) {
-		final String sql = "UPDATE COMMISSION SET value = :value, date = NOW() " +
-				"where operation_type = :operation_type AND user_role IN (:user_roles)";
-		Map<String, Object> params = new HashMap<String, Object>() {{
-			put("operation_type", operationType.getType());
-			put("user_roles", roleIds);
-			put("value", value);
-		}};
-		jdbcTemplate.update(sql, params);
-	}
+    @Override
+    public void updateCommission(OperationType operationType, List<Integer> roleIds, BigDecimal value) {
+        final String sql = "UPDATE COMMISSION SET value = :value, date = NOW() " +
+                "where operation_type = :operation_type AND user_role IN (:user_roles)";
+        Map<String, Object> params = new HashMap<String, Object>() {{
+            put("operation_type", operationType.getCode());
+            put("user_roles", roleIds);
+            put("value", value);
+        }};
+        jdbcTemplate.update(sql, params);
+    }
 
-	@Override
-	public void updateMerchantCurrencyCommission(EditMerchantCommissionDto editMerchantCommissionDto){
-		final String sql = "UPDATE MERCHANT_CURRENCY " +
-				"  SET merchant_input_commission = :input_value, " +
-				"  merchant_output_commission = :output_value, " +
-				"  merchant_transfer_commission = :transfer_value, " +
-				"  merchant_fixed_commission = :fixed_commision " +
-				"  WHERE merchant_id = :merchant_id AND currency_id = :currency_id";
-		Map<String, Number> params = new HashMap<String, Number>() {{
-			put("merchant_id", editMerchantCommissionDto.getMerchantId());
-			put("currency_id", editMerchantCommissionDto.getCurrencyId());
-			put("input_value", editMerchantCommissionDto.getInputValue());
-			put("output_value", editMerchantCommissionDto.getOutputValue());
-			put("transfer_value", editMerchantCommissionDto.getTransferValue());
-			put("fixed_commision", editMerchantCommissionDto.getMinFixedAmount());
-		}};
-		jdbcTemplate.update(sql, params);
-	}
+    @Override
+    public void updateMerchantCurrencyCommission(EditMerchantCommissionDto editMerchantCommissionDto) {
+        final String sql = "UPDATE MERCHANT_CURRENCY " +
+                "  SET merchant_input_commission = :input_value, " +
+                "  merchant_output_commission = :output_value, " +
+                "  merchant_transfer_commission = :transfer_value, " +
+                "  merchant_fixed_commission = :fixed_commision " +
+                "  WHERE merchant_id = :merchant_id AND currency_id = :currency_id";
+        Map<String, Number> params = new HashMap<String, Number>() {{
+            put("merchant_id", editMerchantCommissionDto.getMerchantId());
+            put("currency_id", editMerchantCommissionDto.getCurrencyId());
+            put("input_value", editMerchantCommissionDto.getInputValue());
+            put("output_value", editMerchantCommissionDto.getOutputValue());
+            put("transfer_value", editMerchantCommissionDto.getTransferValue());
+            put("fixed_commision", editMerchantCommissionDto.getMinFixedAmount());
+        }};
+        jdbcTemplate.update(sql, params);
+    }
 
-	@Override
-	public BigDecimal getMinFixedCommission(Integer currencyId, Integer merchantId) {
-		final String sql = "SELECT merchant_fixed_commission FROM MERCHANT_CURRENCY " +
-				"where merchant_id = :merchant " +
-				"and currency_id = :currency ";
-		final HashMap<String, Object> params = new HashMap<>();
-		params.put("currency", currencyId);
-		params.put("merchant", merchantId);
-		return BigDecimal.valueOf(jdbcTemplate.queryForObject(sql, params, Double.class));
-	}
+    @Override
+    public BigDecimal getMinFixedCommission(Integer currencyId, Integer merchantId) {
+        final String sql = "SELECT merchant_fixed_commission FROM MERCHANT_CURRENCY " +
+                "where merchant_id = :merchant " +
+                "and currency_id = :currency ";
+        final HashMap<String, Object> params = new HashMap<>();
+        params.put("currency", currencyId);
+        params.put("merchant", merchantId);
+        return BigDecimal.valueOf(jdbcTemplate.queryForObject(sql, params, Double.class));
+    }
 
-	@Override
-	public Commission getCommissionById(Integer commissionId) {
-		final String sql = "SELECT COMMISSION.id, COMMISSION.operation_type, COMMISSION.date, COMMISSION.value " +
-				" FROM COMMISSION " +
-				" WHERE id = :id";
-		final HashMap<String,Integer> params = new HashMap<>();
-		params.put("id",commissionId);
-		return jdbcTemplate.queryForObject(sql,params, commissionRowMapper);
-	}
+    @Override
+    public Commission getCommissionById(Integer commissionId) {
+        final String sql = "SELECT COMMISSION.id, COMMISSION.operation_type, COMMISSION.date, COMMISSION.value " +
+                " FROM COMMISSION " +
+                " WHERE id = :id";
+        final HashMap<String, Integer> params = new HashMap<>();
+        params.put("id", commissionId);
+        return jdbcTemplate.queryForObject(sql, params, commissionRowMapper);
+    }
 
 }
Index: Dao/src/main/java/me/exrates/dao/impl/CurrencyDaoImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Dao/src/main/java/me/exrates/dao/impl/CurrencyDaoImpl.java	(revision Local Version)
+++ Dao/src/main/java/me/exrates/dao/impl/CurrencyDaoImpl.java	(revision Shelved Version)
@@ -10,11 +10,11 @@
 import me.exrates.model.dto.mobileApiDto.TransferLimitDto;
 import me.exrates.model.dto.mobileApiDto.dashboard.CurrencyPairWithLimitsDto;
 import me.exrates.model.dto.openAPI.CurrencyPairInfoItem;
+import me.exrates.model.enums.CurrencyPairType;
 import me.exrates.model.enums.MerchantProcessType;
 import me.exrates.model.enums.OperationType;
 import me.exrates.model.enums.UserCommentTopicEnum;
 import me.exrates.model.enums.UserRole;
-import me.exrates.model.enums.*;
 import me.exrates.model.enums.invoice.InvoiceOperationDirection;
 import me.exrates.model.enums.invoice.InvoiceOperationPermission;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -26,493 +26,496 @@
 import org.springframework.stereotype.Repository;
 
 import java.math.BigDecimal;
-import java.util.*;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
 
 @Repository
 public class CurrencyDaoImpl implements CurrencyDao {
 
-  @Autowired
-  @Qualifier(value = "masterTemplate")
-  private NamedParameterJdbcTemplate jdbcTemplate;
+    @Autowired
+    @Qualifier(value = "masterTemplate")
+    private NamedParameterJdbcTemplate jdbcTemplate;
 
-  protected static RowMapper<CurrencyPair> currencyPairRowMapper = (rs, row) -> {
-    CurrencyPair currencyPair = new CurrencyPair();
-    currencyPair.setId(rs.getInt("id"));
-    currencyPair.setName(rs.getString("name"));
-    currencyPair.setPairType(CurrencyPairType.valueOf(rs.getString("type")));
-      /**/
-    Currency currency1 = new Currency();
-    currency1.setId(rs.getInt("currency1_id"));
-    currency1.setName(rs.getString("currency1_name"));
-    currencyPair.setCurrency1(currency1);
-      /**/
-    Currency currency2 = new Currency();
-    currency2.setId(rs.getInt("currency2_id"));
-    currency2.setName(rs.getString("currency2_name"));
-    currencyPair.setCurrency2(currency2);
-      /**/
-    currencyPair.setMarket(rs.getString("market"));
+    protected static RowMapper<CurrencyPair> currencyPairRowMapper = (rs, row) -> {
+        CurrencyPair currencyPair = new CurrencyPair();
+        currencyPair.setId(rs.getInt("id"));
+        currencyPair.setName(rs.getString("name"));
+        currencyPair.setPairType(CurrencyPairType.valueOf(rs.getString("type")));
+        /**/
+        Currency currency1 = new Currency();
+        currency1.setId(rs.getInt("currency1_id"));
+        currency1.setName(rs.getString("currency1_name"));
+        currencyPair.setCurrency1(currency1);
+        /**/
+        Currency currency2 = new Currency();
+        currency2.setId(rs.getInt("currency2_id"));
+        currency2.setName(rs.getString("currency2_name"));
+        currencyPair.setCurrency2(currency2);
+        /**/
+        currencyPair.setMarket(rs.getString("market"));
 
-    return currencyPair;
+        return currencyPair;
 
-  };
+    };
 
-  public List<Currency> getCurrList() {
-    String sql = "SELECT id, name FROM CURRENCY WHERE hidden IS NOT TRUE ";
-    List<Currency> currList;
-    currList = jdbcTemplate.query(sql, (rs, row) -> {
-      Currency currency = new Currency();
-      currency.setId(rs.getInt("id"));
-      currency.setName(rs.getString("name"));
-      return currency;
-
-    });
-    return currList;
-  }
+    public List<Currency> getCurrencyList() {
+        String sql = "SELECT id, name FROM CURRENCY WHERE hidden IS NOT TRUE ";
+        return jdbcTemplate.query(sql, (rs, row) -> {
+            Currency currency = new Currency();
+            currency.setId(rs.getInt("id"));
+            currency.setName(rs.getString("name"));
+            return currency;
+        });
+    }
 
-  @Override
-  public int getCurrencyId(int walletId) {
-    String sql = "SELECT currency_id FROM WALLET WHERE id = :walletId ";
-    Map<String, String> namedParameters = new HashMap<>();
-    namedParameters.put("walletId", String.valueOf(walletId));
-    return jdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
-  }
+    @Override
+    public int getCurrencyId(int walletId) {
+        String sql = "SELECT currency_id FROM WALLET WHERE id = :walletId ";
+        Map<String, String> namedParameters = new HashMap<>();
+        namedParameters.put("walletId", String.valueOf(walletId));
+        return jdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
+    }
 
-  @Override
-  public String getCurrencyName(int currencyId) {
-    String sql = "SELECT name FROM CURRENCY WHERE  id = :id ";
-    Map<String, String> namedParameters = new HashMap<>();
-    namedParameters.put("id", String.valueOf(currencyId));
-    return jdbcTemplate.queryForObject(sql, namedParameters, String.class);
-  }
+    @Override
+    public String getCurrencyName(int currencyId) {
+        String sql = "SELECT name FROM CURRENCY WHERE  id = :id ";
+        Map<String, String> namedParameters = new HashMap<>();
+        namedParameters.put("id", String.valueOf(currencyId));
+        return jdbcTemplate.queryForObject(sql, namedParameters, String.class);
+    }
 
-  @Override
-  public Currency findByName(String name) {
-    final String sql = "SELECT * FROM CURRENCY WHERE name = :name";
-    final Map<String, String> params = new HashMap<String, String>() {
-      {
-        put("name", name);
-      }
-    };
-    return jdbcTemplate.queryForObject(sql, params, new BeanPropertyRowMapper<>(Currency.class));
-  }
+    @Override
+    public Currency findByName(String name) {
+        final String sql = "SELECT * FROM CURRENCY WHERE name = :name";
+        final Map<String, String> params = new HashMap<String, String>() {
+            {
+                put("name", name);
+            }
+        };
+        return jdbcTemplate.queryForObject(sql, params, new BeanPropertyRowMapper<>(Currency.class));
+    }
 
-  @Override
-  public Currency findById(int id) {
-    final String sql = "SELECT * FROM CURRENCY WHERE id = :id";
-    final Map<String, Integer> params = new HashMap<String, Integer>() {
-      {
-        put("id", id);
-      }
-    };
-    return jdbcTemplate.queryForObject(sql, params, new BeanPropertyRowMapper<>(Currency.class));
-  }
+    @Override
+    public Currency findById(int id) {
+        final String sql = "SELECT * FROM CURRENCY WHERE id = :id";
+        final Map<String, Integer> params = new HashMap<String, Integer>() {
+            {
+                put("id", id);
+            }
+        };
+        return jdbcTemplate.queryForObject(sql, params, new BeanPropertyRowMapper<>(Currency.class));
+    }
 
-  @Override
-  public List<Currency> findAllCurrencies() {
-    final String sql = "SELECT * FROM CURRENCY WHERE hidden IS NOT TRUE order by name";
-    return jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(Currency.class));
-  }
+    @Override
+    public List<Currency> findAllCurrencies() {
+        final String sql = "SELECT * FROM CURRENCY WHERE hidden IS NOT TRUE order by name";
+        return jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(Currency.class));
+    }
 
-  @Override
-  public List<CurrencyLimit> retrieveCurrencyLimitsForRoles(List<Integer> roleIds, OperationType operationType) {
-    String sql = "SELECT DISTINCT CURRENCY_LIMIT.currency_id, CURRENCY.name, " +
-        "CURRENCY_LIMIT.min_sum, CURRENCY_LIMIT.max_sum, CURRENCY_LIMIT.max_daily_request " +
-        "FROM CURRENCY_LIMIT " +
-        "JOIN CURRENCY ON CURRENCY_LIMIT.currency_id = CURRENCY.id " +
-        "WHERE user_role_id IN(:role_ids) AND CURRENCY_LIMIT.operation_type_id = :operation_type_id";
-    Map<String, Object> params = new HashMap<String, Object>() {{
-      put("role_ids", roleIds);
-      put("operation_type_id", operationType.getType());
-    }};
-
-    return jdbcTemplate.query(sql, params, (rs, row) -> {
-      CurrencyLimit currencyLimit = new CurrencyLimit();
-      Currency currency = new Currency();
-      currency.setId(rs.getInt("currency_id"));
-      currency.setName(rs.getString("name"));
-      currencyLimit.setCurrency(currency);
-      currencyLimit.setMinSum(rs.getBigDecimal("min_sum"));
-      currencyLimit.setMaxSum(rs.getBigDecimal("max_sum"));
-      currencyLimit.setMaxDailyRequest(rs.getInt("max_daily_request"));
-      return currencyLimit;
-    });
-  }
+    @Override
+    public List<CurrencyLimit> getCurrencyLimitsForRoles(List<Integer> roleIds, OperationType operationType) {
+        String sql = "SELECT DISTINCT CURRENCY_LIMIT.currency_id, CURRENCY.name, " +
+                "CURRENCY_LIMIT.min_sum, CURRENCY_LIMIT.max_sum, CURRENCY_LIMIT.max_daily_request " +
+                "FROM CURRENCY_LIMIT " +
+                "JOIN CURRENCY ON CURRENCY_LIMIT.currency_id = CURRENCY.id " +
+                "WHERE user_role_id IN(:role_ids) AND CURRENCY_LIMIT.operation_type_id = :operation_type_id";
+        Map<String, Object> params = new HashMap<String, Object>() {{
+            put("role_ids", roleIds);
+            put("operation_type_id", operationType.getCode());
+        }};
+        return jdbcTemplate.query(sql, params, (rs, row) -> {
+            CurrencyLimit currencyLimit = new CurrencyLimit();
+            Currency currency = new Currency();
+            currency.setId(rs.getInt("currency_id"));
+            currency.setName(rs.getString("name"));
+            currencyLimit.setCurrency(currency);
+            currencyLimit.setMinSum(rs.getBigDecimal("min_sum"));
+            currencyLimit.setMaxSum(rs.getBigDecimal("max_sum"));
+            currencyLimit.setMaxDailyRequest(rs.getInt("max_daily_request"));
+            return currencyLimit;
+        });
+    }
 
-  @Override
-  public List<TransferLimitDto> retrieveMinTransferLimits(List<Integer> currencyIds, Integer roleId) {
-    String currencyClause = currencyIds.isEmpty() ? "" : " AND currency_id IN (:currency_ids) ";
-    String sql = "SELECT currency_id, min_sum FROM CURRENCY_LIMIT WHERE operation_type_id = 9 AND user_role_id = :user_role_id " + currencyClause;
-    Map<String, Object> params = new HashMap<>();
-    params.put("user_role_id", roleId);
-    params.put("currency_ids", currencyIds);
+    @Override
+    public List<TransferLimitDto> retrieveMinTransferLimits(List<Integer> currencyIds, Integer roleId) {
+        String currencyClause = currencyIds.isEmpty() ? "" : " AND currency_id IN (:currency_ids) ";
+        String sql = "SELECT currency_id, min_sum FROM CURRENCY_LIMIT WHERE operation_type_id = 9 AND user_role_id = :user_role_id " + currencyClause;
+        Map<String, Object> params = new HashMap<>();
+        params.put("user_role_id", roleId);
+        params.put("currency_ids", currencyIds);
 
-    return jdbcTemplate.query(sql, params, (rs, rowNum) -> {
-      TransferLimitDto dto = new TransferLimitDto();
-      dto.setCurrencyId(rs.getInt("currency_id"));
-      dto.setTransferMinLimit(rs.getBigDecimal("min_sum"));
-      return dto;
-    });
-  }
+        return jdbcTemplate.query(sql, params, (rs, rowNum) -> {
+            TransferLimitDto dto = new TransferLimitDto();
+            dto.setCurrencyId(rs.getInt("currency_id"));
+            dto.setTransferMinLimit(rs.getBigDecimal("min_sum"));
+            return dto;
+        });
+    }
 
-  @Override
-  public BigDecimal retrieveMinLimitForRoleAndCurrency(UserRole userRole, OperationType operationType, Integer currencyId) {
-    String sql = "SELECT min_sum FROM CURRENCY_LIMIT " +
-        "WHERE user_role_id = :role_id AND operation_type_id = :operation_type_id AND currency_id = :currency_id";
-    Map<String, Integer> params = new HashMap<String, Integer>() {{
-      put("role_id", userRole.getRole());
-      put("operation_type_id", operationType.getType());
-      put("currency_id", currencyId);
-    }};
-    return jdbcTemplate.queryForObject(sql, params, BigDecimal.class);
-  }
+    @Override
+    public BigDecimal getMinLimitForRoleAndCurrency(UserRole userRole,
+                                                    OperationType operationType,
+                                                    Integer currencyId) {
+        String sql = "SELECT min_sum FROM CURRENCY_LIMIT " +
+                "WHERE user_role_id = :role_id AND operation_type_id = :operation_type_id AND currency_id = :currency_id";
+        Map<String, Integer> params = new HashMap<String, Integer>() {{
+            put("role_id", userRole.getCode());
+            put("operation_type_id", operationType.getCode());
+            put("currency_id", currencyId);
+        }};
+        return jdbcTemplate.queryForObject(sql, params, BigDecimal.class);
+    }
 
-  @Override
-  public void updateCurrencyLimit(int currencyId, OperationType operationType, List<Integer> roleIds, BigDecimal minAmount, Integer maxDailyRequest) {
-    String sql = "UPDATE CURRENCY_LIMIT SET min_sum = :min_sum, max_daily_request = :max_daily_request  WHERE currency_id = :currency_id " +
-        "AND operation_type_id = :operation_type_id AND user_role_id IN (:role_ids)";
-    final Map<String, Object> params = new HashMap<String, Object>() {
-      {
-        put("min_sum", minAmount);
-        put("currency_id", currencyId);
-        put("operation_type_id", operationType.getType());
-        put("role_ids", roleIds);
-        put("max_daily_request", maxDailyRequest);
-      }
-    };
+    @Override
+    public void updateCurrencyLimit(int currencyId, OperationType operationType, List<Integer> roleIds, BigDecimal minAmount, Integer maxDailyRequest) {
+        String sql = "UPDATE CURRENCY_LIMIT SET min_sum = :min_sum, max_daily_request = :max_daily_request  WHERE currency_id = :currency_id " +
+                "AND operation_type_id = :operation_type_id AND user_role_id IN (:role_ids)";
+        final Map<String, Object> params = new HashMap<String, Object>() {
+            {
+                put("min_sum", minAmount);
+                put("currency_id", currencyId);
+                put("operation_type_id", operationType.getCode());
+                put("role_ids", roleIds);
+                put("max_daily_request", maxDailyRequest);
+            }
+        };
 
-    jdbcTemplate.update(sql, params);
-  }
+        jdbcTemplate.update(sql, params);
+    }
 
-  @Override
-  public List<CurrencyPair> getAllCurrencyPairs(CurrencyPairType type) {
-    String typeClause = "";
-    if (type != null && type != CurrencyPairType.ALL) {
-      typeClause = " AND type =:pairType ";
-    }
-    String sql = "SELECT id, currency1_id, currency2_id, name, market, type, " +
-        "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
-        "(select name from CURRENCY where id = currency2_id) as currency2_name " +
-        " FROM CURRENCY_PAIR " +
-        " WHERE hidden IS NOT TRUE " + typeClause +
-        " ORDER BY -pair_order DESC";
-    return jdbcTemplate.query(sql, Collections.singletonMap("pairType", type.name()), currencyPairRowMapper);
-  }
+    @Override
+    public List<CurrencyPair> getAllCurrencyPairs(CurrencyPairType type) {
+        String typeClause = "";
+        if (type != null && type != CurrencyPairType.ALL) {
+            typeClause = " AND type =:pairType ";
+        }
+        String sql = "SELECT id, currency1_id, currency2_id, name, market, type, " +
+                "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
+                "(select name from CURRENCY where id = currency2_id) as currency2_name " +
+                " FROM CURRENCY_PAIR " +
+                " WHERE hidden IS NOT TRUE " + typeClause +
+                " ORDER BY -pair_order DESC";
+        return jdbcTemplate.query(sql, Collections.singletonMap("pairType", type.name()), currencyPairRowMapper);
+    }
 
 
-  @Override
-  public CurrencyPair getCurrencyPairById(int currency1Id, int currency2Id) {
-    String sql = "SELECT id, currency1_id, currency2_id, name, market, type, " +
-        "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
-        "(select name from CURRENCY where id = currency2_id) as currency2_name " +
-        " FROM CURRENCY_PAIR WHERE currency1_id = :currency1Id AND currency2_id = :currency2Id";
-    Map<String, String> namedParameters = new HashMap<>();
-    namedParameters.put("currency1Id", String.valueOf(currency1Id));
-    namedParameters.put("currency2Id", String.valueOf(currency2Id));
-    return jdbcTemplate.queryForObject(sql, namedParameters, currencyPairRowMapper);
-  }
+    @Override
+    public CurrencyPair getCurrencyPairById(int currency1Id, int currency2Id) {
+        String sql = "SELECT id, currency1_id, currency2_id, name, market, type, " +
+                "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
+                "(select name from CURRENCY where id = currency2_id) as currency2_name " +
+                " FROM CURRENCY_PAIR WHERE currency1_id = :currency1Id AND currency2_id = :currency2Id";
+        Map<String, String> namedParameters = new HashMap<>();
+        namedParameters.put("currency1Id", String.valueOf(currency1Id));
+        namedParameters.put("currency2Id", String.valueOf(currency2Id));
+        return jdbcTemplate.queryForObject(sql, namedParameters, currencyPairRowMapper);
+    }
 
-  @Override
-  public CurrencyPair findCurrencyPairById(int currencyPairId) {
-    String sql = "SELECT id, currency1_id, currency2_id, name, market, type," +
-        "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
-        "(select name from CURRENCY where id = currency2_id) as currency2_name " +
-        " FROM CURRENCY_PAIR WHERE id = :currencyPairId";
-    Map<String, String> namedParameters = new HashMap<>();
-    namedParameters.put("currencyPairId", String.valueOf(currencyPairId));
-    return jdbcTemplate.queryForObject(sql, namedParameters, currencyPairRowMapper);
-  }
+    @Override
+    public CurrencyPair findCurrencyPairById(int currencyPairId) {
+        String sql = "SELECT id, currency1_id, currency2_id, name, market, type," +
+                "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
+                "(select name from CURRENCY where id = currency2_id) as currency2_name " +
+                " FROM CURRENCY_PAIR WHERE id = :currencyPairId";
+        Map<String, String> namedParameters = new HashMap<>();
+        namedParameters.put("currencyPairId", String.valueOf(currencyPairId));
+        return jdbcTemplate.queryForObject(sql, namedParameters, currencyPairRowMapper);
+    }
 
-  @Override
-  public CurrencyPair getNotHiddenCurrencyPairByName(String currencyPairName) {
-    String sql = "SELECT id, currency1_id, currency2_id, name, market, type," +
-            "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
-            "(select name from CURRENCY where id = currency2_id) as currency2_name " +
-            " FROM CURRENCY_PAIR WHERE name = :currencyPairName AND hidden IS NOT TRUE ";
-    Map<String, String> namedParameters = new HashMap<>();
-    namedParameters.put("currencyPairName", String.valueOf(currencyPairName));
-    return jdbcTemplate.queryForObject(sql, namedParameters, currencyPairRowMapper);
-  }
+    @Override
+    public CurrencyPair getNotHiddenCurrencyPairByName(String currencyPairName) {
+        String sql = "SELECT id, currency1_id, currency2_id, name, market, type," +
+                "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
+                "(select name from CURRENCY where id = currency2_id) as currency2_name " +
+                " FROM CURRENCY_PAIR WHERE name = :currencyPairName AND hidden IS NOT TRUE ";
+        Map<String, String> namedParameters = new HashMap<>();
+        namedParameters.put("currencyPairName", String.valueOf(currencyPairName));
+        return jdbcTemplate.queryForObject(sql, namedParameters, currencyPairRowMapper);
+    }
 
-  @Override
-  public CurrencyPair findCurrencyPairByName(String currencyPairName) {
-    String sql = "SELECT id, currency1_id, currency2_id, name, market, type," +
-            "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
-            "(select name from CURRENCY where id = currency2_id) as currency2_name " +
-            " FROM CURRENCY_PAIR WHERE name = :currencyPairName";
-    Map<String, String> namedParameters = new HashMap<>();
-    namedParameters.put("currencyPairName", String.valueOf(currencyPairName));
-    return jdbcTemplate.queryForObject(sql, namedParameters, currencyPairRowMapper);
-  }
+    @Override
+    public CurrencyPair findCurrencyPairByName(String currencyPairName) {
+        String sql = "SELECT id, currency1_id, currency2_id, name, market, type," +
+                "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
+                "(select name from CURRENCY where id = currency2_id) as currency2_name " +
+                " FROM CURRENCY_PAIR WHERE name = :currencyPairName";
+        Map<String, String> namedParameters = new HashMap<>();
+        namedParameters.put("currencyPairName", String.valueOf(currencyPairName));
+        return jdbcTemplate.queryForObject(sql, namedParameters, currencyPairRowMapper);
+    }
 
-  @Override
-  public List<UserCurrencyOperationPermissionDto> findCurrencyOperationPermittedByUserAndDirection(Integer userId, String operationDirection) {
-    String sql = "SELECT CUR.id, CUR.name, IOP.invoice_operation_permission_id" +
-        " FROM CURRENCY CUR " +
-        " LEFT JOIN USER_CURRENCY_INVOICE_OPERATION_PERMISSION IOP ON " +
-        "				(IOP.currency_id=CUR.id) " +
-        "			 	AND (IOP.operation_direction=:operation_direction) " +
-        "				AND (IOP.user_id=:user_id) " +
-        " WHERE CUR.hidden IS NOT TRUE " +
-        " ORDER BY CUR.id ";
-    Map<String, Object> params = new HashMap<String, Object>() {{
-      put("user_id", userId);
-      put("operation_direction", operationDirection);
-    }};
-    return jdbcTemplate.query(sql, params, (rs, row) -> {
-      UserCurrencyOperationPermissionDto dto = new UserCurrencyOperationPermissionDto();
-      dto.setUserId(userId);
-      dto.setCurrencyId(rs.getInt("id"));
-      dto.setCurrencyName(rs.getString("name"));
-      Integer permissionCode = rs.getObject("invoice_operation_permission_id") == null ? 0 : (Integer) rs.getObject("invoice_operation_permission_id");
-      dto.setInvoiceOperationPermission(InvoiceOperationPermission.convert(permissionCode));
-      return dto;
-    });
-  }
+    @Override
+    public List<UserCurrencyOperationPermissionDto> findCurrencyOperationPermittedByUserAndDirection(Integer userId, String operationDirection) {
+        String sql = "SELECT CUR.id, CUR.name, IOP.invoice_operation_permission_id" +
+                " FROM CURRENCY CUR " +
+                " LEFT JOIN USER_CURRENCY_INVOICE_OPERATION_PERMISSION IOP ON " +
+                "				(IOP.currency_id=CUR.id) " +
+                "			 	AND (IOP.operation_direction=:operation_direction) " +
+                "				AND (IOP.user_id=:user_id) " +
+                " WHERE CUR.hidden IS NOT TRUE " +
+                " ORDER BY CUR.id ";
+        Map<String, Object> params = new HashMap<String, Object>() {{
+            put("user_id", userId);
+            put("operation_direction", operationDirection);
+        }};
+        return jdbcTemplate.query(sql, params, (rs, row) -> {
+            UserCurrencyOperationPermissionDto dto = new UserCurrencyOperationPermissionDto();
+            dto.setUserId(userId);
+            dto.setCurrencyId(rs.getInt("id"));
+            dto.setCurrencyName(rs.getString("name"));
+            Integer permissionCode = rs.getObject("invoice_operation_permission_id") == null ? 0 : (Integer) rs.getObject("invoice_operation_permission_id");
+            dto.setInvoiceOperationPermission(InvoiceOperationPermission.convert(permissionCode));
+            return dto;
+        });
+    }
 
-  @Override
-  public List<UserCurrencyOperationPermissionDto> findCurrencyOperationPermittedByUserList(Integer userId) {
-    String sql = "SELECT CUR.id, CUR.name, IOP.invoice_operation_permission_id, IOP.operation_direction " +
-        " FROM CURRENCY CUR " +
-        " JOIN USER_CURRENCY_INVOICE_OPERATION_PERMISSION IOP ON " +
-        "				(IOP.currency_id=CUR.id) " +
-        "				AND (IOP.user_id=:user_id) " +
-        " WHERE CUR.hidden IS NOT TRUE " +
-        " ORDER BY CUR.id ";
-    Map<String, Object> params = new HashMap<String, Object>() {{
-      put("user_id", userId);
-    }};
-    return jdbcTemplate.query(sql, params, (rs, row) -> {
-      UserCurrencyOperationPermissionDto dto = new UserCurrencyOperationPermissionDto();
-      dto.setUserId(userId);
-      dto.setCurrencyId(rs.getInt("id"));
-      dto.setCurrencyName(rs.getString("name"));
-      dto.setInvoiceOperationDirection(InvoiceOperationDirection.valueOf(rs.getString("operation_direction")));
-      Integer permissionCode = rs.getObject("invoice_operation_permission_id") == null ? 0 : (Integer) rs.getObject("invoice_operation_permission_id");
-      dto.setInvoiceOperationPermission(InvoiceOperationPermission.convert(permissionCode));
-      return dto;
-    });
-  }
+    @Override
+    public List<UserCurrencyOperationPermissionDto> findCurrencyOperationPermittedByUserList(Integer userId) {
+        String sql = "SELECT CUR.id, CUR.name, IOP.invoice_operation_permission_id, IOP.operation_direction " +
+                " FROM CURRENCY CUR " +
+                " JOIN USER_CURRENCY_INVOICE_OPERATION_PERMISSION IOP ON " +
+                "				(IOP.currency_id=CUR.id) " +
+                "				AND (IOP.user_id=:user_id) " +
+                " WHERE CUR.hidden IS NOT TRUE " +
+                " ORDER BY CUR.id ";
+        Map<String, Object> params = new HashMap<String, Object>() {{
+            put("user_id", userId);
+        }};
+        return jdbcTemplate.query(sql, params, (rs, row) -> {
+            UserCurrencyOperationPermissionDto dto = new UserCurrencyOperationPermissionDto();
+            dto.setUserId(userId);
+            dto.setCurrencyId(rs.getInt("id"));
+            dto.setCurrencyName(rs.getString("name"));
+            dto.setInvoiceOperationDirection(InvoiceOperationDirection.valueOf(rs.getString("operation_direction")));
+            Integer permissionCode = rs.getObject("invoice_operation_permission_id") == null ? 0 : (Integer) rs.getObject("invoice_operation_permission_id");
+            dto.setInvoiceOperationPermission(InvoiceOperationPermission.convert(permissionCode));
+            return dto;
+        });
+    }
 
-  @Override
-  public List<String> getWarningForCurrency(Integer currencyId, UserCommentTopicEnum currencyWarningTopicEnum) {
-    String sql = "SELECT PHT.template " +
-        " FROM PHRASE_TEMPLATE PHT " +
-        " JOIN USER_COMMENT_TOPIC UCT ON (UCT.id = PHT.topic_id) AND (UCT.topic = :topic)  " +
-        " JOIN CURRENCY CUR ON (CUR.id = :currency_id)" +
-        " WHERE PHT.template LIKE CONCAT('%.', CUR.name) ";
-    Map<String, Object> params = new HashMap<>();
-    params.put("currency_id", currencyId);
-    params.put("topic", currencyWarningTopicEnum.name());
-    return jdbcTemplate.queryForList(sql, params, String.class);
-  }
+    @Override
+    public List<String> getWarningForCurrency(Integer currencyId, UserCommentTopicEnum currencyWarningTopicEnum) {
+        String sql = "SELECT PHT.template " +
+                " FROM PHRASE_TEMPLATE PHT " +
+                " JOIN USER_COMMENT_TOPIC UCT ON (UCT.id = PHT.topic_id) AND (UCT.topic = :topic)  " +
+                " JOIN CURRENCY CUR ON (CUR.id = :currency_id)" +
+                " WHERE PHT.template LIKE CONCAT('%.', CUR.name) ";
+        Map<String, Object> params = new HashMap<>();
+        params.put("currency_id", currencyId);
+        params.put("topic", currencyWarningTopicEnum.name());
+        return jdbcTemplate.queryForList(sql, params, String.class);
+    }
 
-  @Override
-  public List<String> getWarningsByTopic(UserCommentTopicEnum currencyWarningTopicEnum) {
-    String sql = "SELECT PHT.template " +
-            " FROM PHRASE_TEMPLATE PHT " +
-            " JOIN USER_COMMENT_TOPIC UCT ON (UCT.id = PHT.topic_id) AND (UCT.topic = :topic)  ";
-    Map<String, Object> params = new HashMap<>();
-    params.put("topic", currencyWarningTopicEnum.name());
-    return jdbcTemplate.queryForList(sql, params, String.class);
-  }
+    @Override
+    public List<String> getWarningsByTopic(UserCommentTopicEnum currencyWarningTopicEnum) {
+        String sql = "SELECT PHT.template " +
+                " FROM PHRASE_TEMPLATE PHT " +
+                " JOIN USER_COMMENT_TOPIC UCT ON (UCT.id = PHT.topic_id) AND (UCT.topic = :topic)  ";
+        Map<String, Object> params = new HashMap<>();
+        params.put("topic", currencyWarningTopicEnum.name());
+        return jdbcTemplate.queryForList(sql, params, String.class);
+    }
 
-  @Override
-  public List<String> getWarningForMerchant(Integer merchantId, UserCommentTopicEnum currencyWarningTopicEnum) {
-    String sql = "SELECT PHT.template " +
-            " FROM PHRASE_TEMPLATE PHT " +
-            " JOIN USER_COMMENT_TOPIC UCT ON (UCT.id = PHT.topic_id) AND (UCT.topic = :topic)  " +
-            " JOIN MERCHANT MCH ON (MCH.id = :merchant_id)" +
-            " WHERE PHT.template LIKE CONCAT('%.', REPLACE(MCH.name, ' ', '')) ";
-    Map<String, Object> params = new HashMap<>();
-    params.put("merchant_id", merchantId);
-    params.put("topic", currencyWarningTopicEnum.name());
-    return jdbcTemplate.queryForList(sql, params, String.class);
-  }
+    @Override
+    public List<String> getWarningForMerchant(Integer merchantId, UserCommentTopicEnum currencyWarningTopicEnum) {
+        String sql = "SELECT PHT.template " +
+                " FROM PHRASE_TEMPLATE PHT " +
+                " JOIN USER_COMMENT_TOPIC UCT ON (UCT.id = PHT.topic_id) AND (UCT.topic = :topic)  " +
+                " JOIN MERCHANT MCH ON (MCH.id = :merchant_id)" +
+                " WHERE PHT.template LIKE CONCAT('%.', REPLACE(MCH.name, ' ', '')) ";
+        Map<String, Object> params = new HashMap<>();
+        params.put("merchant_id", merchantId);
+        params.put("topic", currencyWarningTopicEnum.name());
+        return jdbcTemplate.queryForList(sql, params, String.class);
+    }
 
-  @Override
-  public CurrencyPair findCurrencyPairByOrderId(int orderId) {
-    String sql = "SELECT CURRENCY_PAIR.id, CURRENCY_PAIR.currency1_id, CURRENCY_PAIR.currency2_id, name, type," +
-            "CURRENCY_PAIR.market, " +
-        "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
-        "(select name from CURRENCY where id = currency2_id) as currency2_name " +
-        " FROM EXORDERS " +
-        " JOIN CURRENCY_PAIR ON (CURRENCY_PAIR.id = EXORDERS.currency_pair_id) " +
-        " WHERE EXORDERS.id = :order_id";
-    Map<String, String> namedParameters = new HashMap<>();
-    namedParameters.put("order_id", String.valueOf(orderId));
-    return jdbcTemplate.queryForObject(sql, namedParameters, currencyPairRowMapper);
-  }
+    @Override
+    public CurrencyPair findCurrencyPairByOrderId(int orderId) {
+        String sql = "SELECT CURRENCY_PAIR.id, CURRENCY_PAIR.currency1_id, CURRENCY_PAIR.currency2_id, name, type," +
+                "CURRENCY_PAIR.market, " +
+                "(select name from CURRENCY where id = currency1_id) as currency1_name, " +
+                "(select name from CURRENCY where id = currency2_id) as currency2_name " +
+                " FROM EXORDERS " +
+                " JOIN CURRENCY_PAIR ON (CURRENCY_PAIR.id = EXORDERS.currency_pair_id) " +
+                " WHERE EXORDERS.id = :order_id";
+        Map<String, String> namedParameters = new HashMap<>();
+        namedParameters.put("order_id", String.valueOf(orderId));
+        return jdbcTemplate.queryForObject(sql, namedParameters, currencyPairRowMapper);
+    }
 
-  @Override
-  public CurrencyPairLimitDto findCurrencyPairLimitForRoleByPairAndType(Integer currencyPairId, Integer roleId, Integer orderTypeId) {
-    String sql = "SELECT CURRENCY_PAIR.id AS currency_pair_id, CURRENCY_PAIR.name AS currency_pair_name, lim.min_rate, lim.max_rate, " +
-            "lim.min_amount, lim.max_amount " +
-        " FROM CURRENCY_PAIR_LIMIT lim " +
-        " JOIN CURRENCY_PAIR ON lim.currency_pair_id = CURRENCY_PAIR.id AND CURRENCY_PAIR.hidden != 1 " +
-        " WHERE lim.currency_pair_id = :currency_pair_id AND lim.user_role_id = :user_role_id AND lim.order_type_id = :order_type_id";
-    Map<String, Integer> namedParameters = new HashMap<>();
-    namedParameters.put("currency_pair_id", currencyPairId);
-    namedParameters.put("user_role_id", roleId);
-    namedParameters.put("order_type_id", orderTypeId);
-    return jdbcTemplate.queryForObject(sql, namedParameters, (rs, rowNum) -> {
-      CurrencyPairLimitDto dto = new CurrencyPairLimitDto();
-      dto.setCurrencyPairId(rs.getInt("currency_pair_id"));
-      dto.setCurrencyPairName(rs.getString("currency_pair_name"));
-      dto.setMinRate(rs.getBigDecimal("min_rate"));
-      dto.setMaxRate(rs.getBigDecimal("max_rate"));
-      dto.setMinAmount(rs.getBigDecimal("min_amount"));
-      dto.setMaxAmount(rs.getBigDecimal("max_amount"));
-      return dto;
-    });
-  }
+    @Override
+    public CurrencyPairLimitDto findCurrencyPairLimitForRoleByPairAndType(Integer currencyPairId, Integer roleId, Integer orderTypeId) {
+        String sql = "SELECT CURRENCY_PAIR.id AS currency_pair_id, CURRENCY_PAIR.name AS currency_pair_name, lim.min_rate, lim.max_rate, " +
+                "lim.min_amount, lim.max_amount " +
+                " FROM CURRENCY_PAIR_LIMIT lim " +
+                " JOIN CURRENCY_PAIR ON lim.currency_pair_id = CURRENCY_PAIR.id AND CURRENCY_PAIR.hidden != 1 " +
+                " WHERE lim.currency_pair_id = :currency_pair_id AND lim.user_role_id = :user_role_id AND lim.order_type_id = :order_type_id";
+        Map<String, Integer> namedParameters = new HashMap<>();
+        namedParameters.put("currency_pair_id", currencyPairId);
+        namedParameters.put("user_role_id", roleId);
+        namedParameters.put("order_type_id", orderTypeId);
+        return jdbcTemplate.queryForObject(sql, namedParameters, (rs, rowNum) -> {
+            CurrencyPairLimitDto dto = new CurrencyPairLimitDto();
+            dto.setCurrencyPairId(rs.getInt("currency_pair_id"));
+            dto.setCurrencyPairName(rs.getString("currency_pair_name"));
+            dto.setMinRate(rs.getBigDecimal("min_rate"));
+            dto.setMaxRate(rs.getBigDecimal("max_rate"));
+            dto.setMinAmount(rs.getBigDecimal("min_amount"));
+            dto.setMaxAmount(rs.getBigDecimal("max_amount"));
+            return dto;
+        });
+    }
 
-  @Override
-  public List<CurrencyPairLimitDto> findLimitsForRolesByType(List<Integer> roleIds, Integer orderTypeId) {
-    String sql = "SELECT DISTINCT CURRENCY_PAIR.id AS currency_pair_id, CURRENCY_PAIR.name AS currency_pair_name, " +
-        " lim.min_rate, lim.max_rate, lim.min_amount, lim.max_amount " +
-        " FROM CURRENCY_PAIR_LIMIT lim " +
-        " JOIN CURRENCY_PAIR ON lim.currency_pair_id = CURRENCY_PAIR.id " +
-        " WHERE lim.user_role_id IN(:user_role_ids) AND lim.order_type_id = :order_type_id AND CURRENCY_PAIR.hidden != 1";
-    Map<String, Object> namedParameters = new HashMap<>();
-    namedParameters.put("user_role_ids", roleIds);
-    namedParameters.put("order_type_id", orderTypeId);
-    return jdbcTemplate.query(sql, namedParameters, (rs, rowNum) -> {
-      CurrencyPairLimitDto dto = new CurrencyPairLimitDto();
-      dto.setCurrencyPairId(rs.getInt("currency_pair_id"));
-      dto.setCurrencyPairName(rs.getString("currency_pair_name"));
-      dto.setMinRate(rs.getBigDecimal("min_rate"));
-      dto.setMaxRate(rs.getBigDecimal("max_rate"));
-      dto.setMinAmount(rs.getBigDecimal("min_amount"));
-      dto.setMaxAmount(rs.getBigDecimal("max_amount"));
-      return dto;
-    });
-  }
+    @Override
+    public List<CurrencyPairLimitDto> findLimitsForRolesByType(List<Integer> roleIds, Integer orderTypeId) {
+        String sql = "SELECT DISTINCT CURRENCY_PAIR.id AS currency_pair_id, CURRENCY_PAIR.name AS currency_pair_name, " +
+                " lim.min_rate, lim.max_rate, lim.min_amount, lim.max_amount " +
+                " FROM CURRENCY_PAIR_LIMIT lim " +
+                " JOIN CURRENCY_PAIR ON lim.currency_pair_id = CURRENCY_PAIR.id " +
+                " WHERE lim.user_role_id IN(:user_role_ids) AND lim.order_type_id = :order_type_id AND CURRENCY_PAIR.hidden != 1";
+        Map<String, Object> namedParameters = new HashMap<>();
+        namedParameters.put("user_role_ids", roleIds);
+        namedParameters.put("order_type_id", orderTypeId);
+        return jdbcTemplate.query(sql, namedParameters, (rs, rowNum) -> {
+            CurrencyPairLimitDto dto = new CurrencyPairLimitDto();
+            dto.setCurrencyPairId(rs.getInt("currency_pair_id"));
+            dto.setCurrencyPairName(rs.getString("currency_pair_name"));
+            dto.setMinRate(rs.getBigDecimal("min_rate"));
+            dto.setMaxRate(rs.getBigDecimal("max_rate"));
+            dto.setMinAmount(rs.getBigDecimal("min_amount"));
+            dto.setMaxAmount(rs.getBigDecimal("max_amount"));
+            return dto;
+        });
+    }
 
-  @Override
-  public void setCurrencyPairLimit(Integer currencyPairId, List<Integer> roleIds, Integer orderTypeId,
-                                   BigDecimal minRate, BigDecimal maxRate, BigDecimal minAmount, BigDecimal maxAmount) {
-    String sql = "UPDATE CURRENCY_PAIR_LIMIT SET max_rate = :max_rate, min_rate = :min_rate, min_amount = :min_amount, max_amount = :max_amount " +
-        "WHERE currency_pair_id = :currency_pair_id AND user_role_id IN(:user_role_ids) AND order_type_id = :order_type_id";
-    Map<String, Object> namedParameters = new HashMap<>();
-    namedParameters.put("currency_pair_id", currencyPairId);
-    namedParameters.put("user_role_ids", roleIds);
-    namedParameters.put("order_type_id", orderTypeId);
-    namedParameters.put("min_rate", minRate);
-    namedParameters.put("max_rate", maxRate);
-    namedParameters.put("min_amount", minAmount);
-    namedParameters.put("max_amount", maxAmount);
-    jdbcTemplate.update(sql, namedParameters);
-  }
+    @Override
+    public void setCurrencyPairLimit(Integer currencyPairId, List<Integer> roleIds, Integer orderTypeId,
+                                     BigDecimal minRate, BigDecimal maxRate, BigDecimal minAmount, BigDecimal maxAmount) {
+        String sql = "UPDATE CURRENCY_PAIR_LIMIT SET max_rate = :max_rate, min_rate = :min_rate, min_amount = :min_amount, max_amount = :max_amount " +
+                "WHERE currency_pair_id = :currency_pair_id AND user_role_id IN(:user_role_ids) AND order_type_id = :order_type_id";
+        Map<String, Object> namedParameters = new HashMap<>();
+        namedParameters.put("currency_pair_id", currencyPairId);
+        namedParameters.put("user_role_ids", roleIds);
+        namedParameters.put("order_type_id", orderTypeId);
+        namedParameters.put("min_rate", minRate);
+        namedParameters.put("max_rate", maxRate);
+        namedParameters.put("min_amount", minAmount);
+        namedParameters.put("max_amount", maxAmount);
+        jdbcTemplate.update(sql, namedParameters);
+    }
 
-  @Override
-  public List<CurrencyPairWithLimitsDto> findAllCurrencyPairsWithLimits(Integer roleId) {
-    String sql = "SELECT CP.id, CP.currency1_id, CP.currency2_id, CP.name, CP.market, CP.type, " +
-            "             (select name from CURRENCY where id = currency1_id) as currency1_name, " +
-            "        (select name from CURRENCY where id = currency2_id) as currency2_name, " +
-            "  LIM_SELL.min_rate AS min_rate_sell, LIM_SELL.max_rate AS max_rate_sell, LIM_SELL.min_amount AS min_amount_sell, LIM_SELL.max_amount AS max_amount_sell, " +
-            "  LIM_BUY.min_rate AS min_rate_buy, LIM_BUY.max_rate AS max_rate_buy, LIM_BUY.min_amount AS min_amount_buy, LIM_BUY.max_amount AS max_amount_buy " +
-            "        FROM CURRENCY_PAIR CP " +
-            "                JOIN CURRENCY_PAIR_LIMIT LIM_SELL ON CP.id = LIM_SELL.currency_pair_id AND LIM_SELL.user_role_id = :role_id " +
-            "                                                     AND LIM_SELL.order_type_id = 1 " +
-            "                JOIN CURRENCY_PAIR_LIMIT LIM_BUY ON CP.id = LIM_BUY.currency_pair_id AND LIM_BUY.user_role_id = :role_id " +
-            "                                                     AND LIM_BUY.order_type_id = 2 " +
-            "        WHERE CP.hidden != 1 ";
-    return jdbcTemplate.query(sql, Collections.singletonMap("role_id", roleId), (rs, row) -> {
-      CurrencyPair currencyPair = currencyPairRowMapper.mapRow(rs, row);
-      return new CurrencyPairWithLimitsDto(currencyPair,
-          rs.getBigDecimal("min_rate_sell"),
-          rs.getBigDecimal("max_rate_sell"),
-          rs.getBigDecimal("min_rate_buy"),
-          rs.getBigDecimal("max_rate_buy"),
-          rs.getBigDecimal("min_amount_sell"),
-          rs.getBigDecimal("max_amount_sell"),
-          rs.getBigDecimal("min_amount_buy"),
-          rs.getBigDecimal("max_amount_buy"));
-    });
+    @Override
+    public List<CurrencyPairWithLimitsDto> findAllCurrencyPairsWithLimits(Integer roleId) {
+        String sql = "SELECT CP.id, CP.currency1_id, CP.currency2_id, CP.name, CP.market, CP.type, " +
+                "             (select name from CURRENCY where id = currency1_id) as currency1_name, " +
+                "        (select name from CURRENCY where id = currency2_id) as currency2_name, " +
+                "  LIM_SELL.min_rate AS min_rate_sell, LIM_SELL.max_rate AS max_rate_sell, LIM_SELL.min_amount AS min_amount_sell, LIM_SELL.max_amount AS max_amount_sell, " +
+                "  LIM_BUY.min_rate AS min_rate_buy, LIM_BUY.max_rate AS max_rate_buy, LIM_BUY.min_amount AS min_amount_buy, LIM_BUY.max_amount AS max_amount_buy " +
+                "        FROM CURRENCY_PAIR CP " +
+                "                JOIN CURRENCY_PAIR_LIMIT LIM_SELL ON CP.id = LIM_SELL.currency_pair_id AND LIM_SELL.user_role_id = :role_id " +
+                "                                                     AND LIM_SELL.order_type_id = 1 " +
+                "                JOIN CURRENCY_PAIR_LIMIT LIM_BUY ON CP.id = LIM_BUY.currency_pair_id AND LIM_BUY.user_role_id = :role_id " +
+                "                                                     AND LIM_BUY.order_type_id = 2 " +
+                "        WHERE CP.hidden != 1 ";
+        return jdbcTemplate.query(sql, Collections.singletonMap("role_id", roleId), (rs, row) -> {
+            CurrencyPair currencyPair = currencyPairRowMapper.mapRow(rs, row);
+            return new CurrencyPairWithLimitsDto(currencyPair,
+                    rs.getBigDecimal("min_rate_sell"),
+                    rs.getBigDecimal("max_rate_sell"),
+                    rs.getBigDecimal("min_rate_buy"),
+                    rs.getBigDecimal("max_rate_buy"),
+                    rs.getBigDecimal("min_amount_sell"),
+                    rs.getBigDecimal("max_amount_sell"),
+                    rs.getBigDecimal("min_amount_buy"),
+                    rs.getBigDecimal("max_amount_buy"));
+        });
 
-  }
+    }
 
-  @Override
-  public List<Currency> findAllCurrenciesWithHidden() {
-    final String sql = "SELECT * FROM CURRENCY";
-    return jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(Currency.class));
-  }
+    @Override
+    public List<Currency> findAllCurrenciesWithHidden() {
+        final String sql = "SELECT * FROM CURRENCY";
+        return jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(Currency.class));
+    }
 
-  @Override
-  public MerchantCurrencyScaleDto findCurrencyScaleByCurrencyId(Integer currencyId) {
-    String sql = "SELECT id, " +
-        "  max_scale_for_refill, max_scale_for_withdraw " +
-        "  FROM CURRENCY " +
-        "  WHERE id = :currency_id";
-    Map<String, Object> params = new HashMap<String, Object>() {{
-      put("currency_id", currencyId);
-    }};
-    return jdbcTemplate.queryForObject(sql, params, (rs, i) -> {
-      MerchantCurrencyScaleDto result = new MerchantCurrencyScaleDto();
-      result.setCurrencyId(rs.getInt("id"));
-      result.setMerchantId(null);
-      result.setScaleForRefill((Integer) rs.getObject("max_scale_for_refill"));
-      result.setScaleForWithdraw((Integer) rs.getObject("max_scale_for_withdraw"));
-      return result;
-    });
-  }
+    @Override
+    public MerchantCurrencyScaleDto findCurrencyScaleByCurrencyId(Integer currencyId) {
+        String sql = "SELECT id, " +
+                "  max_scale_for_refill, max_scale_for_withdraw " +
+                "  FROM CURRENCY " +
+                "  WHERE id = :currency_id";
+        Map<String, Object> params = new HashMap<String, Object>() {{
+            put("currency_id", currencyId);
+        }};
+        return jdbcTemplate.queryForObject(sql, params, (rs, i) -> {
+            MerchantCurrencyScaleDto result = new MerchantCurrencyScaleDto();
+            result.setCurrencyId(rs.getInt("id"));
+            result.setMerchantId(null);
+            result.setScaleForRefill((Integer) rs.getObject("max_scale_for_refill"));
+            result.setScaleForWithdraw((Integer) rs.getObject("max_scale_for_withdraw"));
+            return result;
+        });
+    }
 
-  @Override
-  public List<Currency> findAllCurrenciesByProcessType(MerchantProcessType processType) {
-    final String sql = "SELECT * FROM CURRENCY " +
-            "JOIN MERCHANT_CURRENCY MC ON MC.currency_id = CURRENCY.id " +
-            "JOIN MERCHANT M ON M.id = MC.merchant_id " +
-            "WHERE M.process_type = :process_type ";
-    return jdbcTemplate.query(sql, 
-            new HashMap<String, Object>() {{put("process_type", processType.name());}},
-            (rs, i) -> {
-              Currency currency = new Currency();
-              currency.setId(rs.getInt("id"));
-              currency.setName(rs.getString("name"));
-              currency.setDescription(rs.getString("description"));
-              return currency;
-            });
-  }
+    @Override
+    public List<Currency> findAllCurrenciesByProcessType(MerchantProcessType processType) {
+        final String sql = "SELECT * FROM CURRENCY " +
+                "JOIN MERCHANT_CURRENCY MC ON MC.currency_id = CURRENCY.id " +
+                "JOIN MERCHANT M ON M.id = MC.merchant_id " +
+                "WHERE M.process_type = :process_type ";
+        return jdbcTemplate.query(sql,
+                new HashMap<String, Object>() {{
+                    put("process_type", processType.name());
+                }},
+                (rs, i) -> {
+                    Currency currency = new Currency();
+                    currency.setId(rs.getInt("id"));
+                    currency.setName(rs.getString("name"));
+                    currency.setDescription(rs.getString("description"));
+                    return currency;
+                });
+    }
 
-  @Override
-  public List<CurrencyPair> findPermitedCurrencyPairs(CurrencyPairType currencyPairType){
-    String sql = "SELECT id, currency1_id, currency2_id, name, market, type, " +
-            "        (select name from CURRENCY where id = currency1_id) as currency1_name, " +
-            "        (select name from CURRENCY where id = currency2_id) as currency2_name " +
-            "         FROM CURRENCY_PAIR " +
-            "         WHERE hidden IS NOT TRUE AND permitted_link IS TRUE ";
-    if (currencyPairType != CurrencyPairType.ALL) {
-        sql = sql.concat(" AND type =:type");
-    }
-    return jdbcTemplate.query(sql, Collections.singletonMap("type", currencyPairType.name()),currencyPairRowMapper);
-  }
+    @Override
+    public List<CurrencyPair> findPermitedCurrencyPairs(CurrencyPairType currencyPairType) {
+        String sql = "SELECT id, currency1_id, currency2_id, name, market, type, " +
+                "        (select name from CURRENCY where id = currency1_id) as currency1_name, " +
+                "        (select name from CURRENCY where id = currency2_id) as currency2_name " +
+                "         FROM CURRENCY_PAIR " +
+                "         WHERE hidden IS NOT TRUE AND permitted_link IS TRUE ";
+        if (currencyPairType != CurrencyPairType.ALL) {
+            sql = sql.concat(" AND type =:type");
+        }
+        return jdbcTemplate.query(sql, Collections.singletonMap("type", currencyPairType.name()), currencyPairRowMapper);
+    }
 
 
-
-  @Override
-  public boolean isCurrencyIco(Integer currencyId) {
-    String sql = "SELECT id " +
-            "         FROM CURRENCY_PAIR " +
-            "         WHERE hidden IS NOT TRUE AND type = 'ICO' AND currency1_id =:currency_id ";
-    return !jdbcTemplate.queryForList(sql, Collections.singletonMap("currency_id", currencyId), Integer.class).isEmpty();
-  }
+    @Override
+    public boolean isCurrencyIco(Integer currencyId) {
+        String sql = "SELECT id " +
+                "         FROM CURRENCY_PAIR " +
+                "         WHERE hidden IS NOT TRUE AND type = 'ICO' AND currency1_id =:currency_id ";
+        return !jdbcTemplate.queryForList(sql, Collections.singletonMap("currency_id", currencyId), Integer.class).isEmpty();
+    }
 
-  @Override
-  public List<CurrencyPairInfoItem> findActiveCurrencyPairs() {
-    String sql = "SELECT name FROM CURRENCY_PAIR WHERE hidden != 1 ORDER BY name ASC";
-    return jdbcTemplate.query(sql, Collections.emptyMap(),
-            (rs, row) -> new CurrencyPairInfoItem(rs.getString("name")));
-  }
+    @Override
+    public List<CurrencyPairInfoItem> findActiveCurrencyPairs() {
+        String sql = "SELECT name FROM CURRENCY_PAIR WHERE hidden != 1 ORDER BY name ASC";
+        return jdbcTemplate.query(sql, Collections.emptyMap(),
+                (rs, row) -> new CurrencyPairInfoItem(rs.getString("name")));
+    }
 
-  @Override
-  public Optional<Integer> findOpenCurrencyPairIdByName(String pairName) {
-    String sql = "SELECT id FROM CURRENCY_PAIR WHERE name = :pair_name AND hidden != 1";
-    try {
-      return Optional.of(jdbcTemplate.queryForObject(sql, Collections.singletonMap("pair_name", pairName), Integer.class));
-    } catch (EmptyResultDataAccessException e) {
-      return Optional.empty();
-    }
+    @Override
+    public Optional<Integer> findOpenCurrencyPairIdByName(String pairName) {
+        String sql = "SELECT id FROM CURRENCY_PAIR WHERE name = :pair_name AND hidden != 1";
+        try {
+            return Optional.of(jdbcTemplate.queryForObject(sql, Collections.singletonMap("pair_name", pairName), Integer.class));
+        } catch (EmptyResultDataAccessException e) {
+            return Optional.empty();
+        }
 
-  }
+    }
 }
\ No newline at end of file
Index: Dao/src/main/java/me/exrates/dao/impl/MerchantDaoImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Dao/src/main/java/me/exrates/dao/impl/MerchantDaoImpl.java	(revision Local Version)
+++ Dao/src/main/java/me/exrates/dao/impl/MerchantDaoImpl.java	(revision Shelved Version)
@@ -233,7 +233,7 @@
             "             WHERE process_type IN (:process_types)" + whereClause;
     Map<String, Object> paramMap = new HashMap<String, Object>() {{
       put("currency_id", currencyId);
-      put("user_role_id", userRole.getRole());
+      put("user_role_id", userRole.getCode());
       put("process_types", merchantProcessTypes);
     }};
 
Index: Dao/src/main/java/me/exrates/dao/impl/OrderDaoImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Dao/src/main/java/me/exrates/dao/impl/OrderDaoImpl.java	(revision Local Version)
+++ Dao/src/main/java/me/exrates/dao/impl/OrderDaoImpl.java	(revision Shelved Version)
@@ -9,7 +9,18 @@
 import me.exrates.model.CurrencyPair;
 import me.exrates.model.ExOrder;
 import me.exrates.model.PagingData;
-import me.exrates.model.dto.*;
+import me.exrates.model.dto.CandleChartItemDto;
+import me.exrates.model.dto.CoinmarketApiDto;
+import me.exrates.model.dto.CurrencyPairTurnoverReportDto;
+import me.exrates.model.dto.ExOrderStatisticsDto;
+import me.exrates.model.dto.OrderBasicInfoDto;
+import me.exrates.model.dto.OrderCommissionsDto;
+import me.exrates.model.dto.OrderCreateDto;
+import me.exrates.model.dto.OrderInfoDto;
+import me.exrates.model.dto.OrdersCommissionSummaryDto;
+import me.exrates.model.dto.RatesUSDForReportDto;
+import me.exrates.model.dto.UserSummaryOrdersByCurrencyPairsDto;
+import me.exrates.model.dto.WalletsAndCommissionsForOrderCreationDto;
 import me.exrates.model.dto.dataTable.DataTableParams;
 import me.exrates.model.dto.filterData.AdminOrderFilterData;
 import me.exrates.model.dto.mobileApiDto.dashboard.CommissionsDto;
@@ -21,7 +32,13 @@
 import me.exrates.model.dto.openAPI.OrderBookItem;
 import me.exrates.model.dto.openAPI.OrderHistoryItem;
 import me.exrates.model.dto.openAPI.UserOrdersDto;
-import me.exrates.model.enums.*;
+import me.exrates.model.enums.ActionType;
+import me.exrates.model.enums.CurrencyPairType;
+import me.exrates.model.enums.OperationType;
+import me.exrates.model.enums.OrderBaseType;
+import me.exrates.model.enums.OrderStatus;
+import me.exrates.model.enums.OrderType;
+import me.exrates.model.enums.UserRole;
 import me.exrates.model.util.BigDecimalProcessing;
 import me.exrates.model.vo.BackDealInterval;
 import me.exrates.model.vo.OrderRoleInfoForDelete;
@@ -48,10 +65,15 @@
 import java.sql.SQLException;
 import java.sql.Timestamp;
 import java.time.LocalDateTime;
-import java.time.LocalTime;
 import java.time.format.DateTimeFormatter;
-import java.time.temporal.ChronoUnit;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
 import java.util.stream.Collectors;
 
 @Repository
@@ -97,7 +119,7 @@
         MapSqlParameterSource parameters = new MapSqlParameterSource()
                 .addValue("user_id", exOrder.getUserId())
                 .addValue("currency_pair_id", exOrder.getCurrencyPairId())
-                .addValue("operation_type_id", exOrder.getOperationType().getType())
+                .addValue("operation_type_id", exOrder.getOperationType().getCode())
                 .addValue("exrate", exOrder.getExRate())
                 .addValue("amount_base", exOrder.getAmountBase())
                 .addValue("amount_convert", exOrder.getAmountConvert())
@@ -127,7 +149,7 @@
         Map<String, Object> params = new HashMap<String, Object>() {{
             put("user_id", exOrder.getUserId());
             put("currency_pair_id", exOrder.getCurrencyPairId());
-            put("operation_type_id", exOrder.getOperationType().type);
+            put("operation_type_id", exOrder.getOperationType().getCode());
             put("exrate", exOrder.getExRate());
             put("amount_base", exOrder.getAmountBase());
             put("amount_convert", exOrder.getAmountConvert());
@@ -154,7 +176,7 @@
         Map<String, Integer> namedParameters = new HashMap<>();
         namedParameters.put("currency_pair_id", currencyPair.getId());
         if (filterRole != null) {
-            namedParameters.put("user_role_id", filterRole.getRole());
+            namedParameters.put("user_role_id", filterRole.getCode());
         }
         return slaveJdbcTemplate.query(sql, namedParameters, (rs, row) -> {
             OrderListDto order = new OrderListDto();
@@ -178,7 +200,7 @@
         Map<String, Integer> namedParameters = new HashMap<>();
         namedParameters.put("currency_pair_id", currencyPair.getId());
         if (filterRole != null) {
-            namedParameters.put("user_role_id", filterRole.getRole());
+            namedParameters.put("user_role_id", filterRole.getCode());
         }
         return slaveJdbcTemplate.query(sql, namedParameters, (rs, row) -> {
             OrderListDto order = new OrderListDto();
@@ -693,7 +715,7 @@
                         "      ORDER BY date DESC LIMIT 1) " +
                         "  ) COMMISSION";
         try {
-            Map<String, Integer> params = Collections.singletonMap("user_role", userRole.getRole());
+            Map<String, Integer> params = Collections.singletonMap("user_role", userRole.getCode());
             return namedParameterJdbcTemplate.queryForObject(sql, params, (rs, rowNum) -> {
                 OrderCommissionsDto orderCommissionsDto = new OrderCommissionsDto();
                 orderCommissionsDto.setSellCommission(rs.getBigDecimal("sell_commission"));
@@ -738,7 +760,7 @@
                         "      ORDER BY date DESC LIMIT 1) " +
                         "  ) COMMISSION";
         try {
-            Map<String, Integer> params = Collections.singletonMap("user_role", userRole.getRole());
+            Map<String, Integer> params = Collections.singletonMap("user_role", userRole.getCode());
             return slaveJdbcTemplate.queryForObject(sql, params, (rs, row) -> {
                     CommissionsDto commissionsDto = new CommissionsDto();
                     commissionsDto.setSellCommission(rs.getBigDecimal("sell_commission"));
@@ -804,7 +826,7 @@
         namedParameters.put("user_id", userId);
         namedParameters.put("status_ids", statusIds);
         if (operationType != null) {
-        namedParameters.put("operation_type_id", operationType.getType());
+        namedParameters.put("operation_type_id", operationType.getCode());
         } else {
             namedParameters.put("operation_type_id", operationTypesIds);
         }
@@ -867,12 +889,12 @@
                     orderCreateDto.setCurrencyPair(currencyPair);
                     orderCreateDto.setAmount(rs.getBigDecimal("amount_base"));
                     orderCreateDto.setTotal(rs.getBigDecimal("amount_convert"));
-                    orderCreateDto.setComission(rs.getBigDecimal("commission_fixed_amount"));
+                    orderCreateDto.setCommission(rs.getBigDecimal("commission_fixed_amount"));
                     orderCreateDto.setOrderBaseType(OrderBaseType.valueOf(rs.getString("base_type")));
                     if (orderCreateDto.getOperationType() == OperationType.SELL) {
-                        orderCreateDto.setTotalWithComission(BigDecimalProcessing.doAction(orderCreateDto.getTotal(), orderCreateDto.getComission(), ActionType.SUBTRACT));
+                        orderCreateDto.setTotalWithComission(BigDecimalProcessing.doAction(orderCreateDto.getTotal(), orderCreateDto.getCommission(), ActionType.SUBTRACT));
                     } else {
-                        orderCreateDto.setTotalWithComission(BigDecimalProcessing.doAction(orderCreateDto.getTotal(), orderCreateDto.getComission(), ActionType.ADD));
+                        orderCreateDto.setTotalWithComission(BigDecimalProcessing.doAction(orderCreateDto.getTotal(), orderCreateDto.getCommission(), ActionType.ADD));
                     }
                     return orderCreateDto;
                 }
@@ -895,9 +917,9 @@
                 "  WHERE USER.email = :email";
         Map<String, Object> namedParameters = new HashMap<>();
         namedParameters.put("email", email);
-        namedParameters.put("operation_type_id", operationType.getType());
+        namedParameters.put("operation_type_id", operationType.getCode());
         namedParameters.put("currency_id", currency.getId());
-        namedParameters.put("user_role", userRole.getRole());
+        namedParameters.put("user_role", userRole.getCode());
         try {
             return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, new RowMapper<WalletsAndCommissionsForOrderCreationDto>() {
                 @Override
@@ -1019,7 +1041,7 @@
         Map<String, Object> params = new HashMap<String, Object>() {{
             put("currency_pair_id", currencyPairId);
             put("exrate", exrate);
-            put("operation_type_id", orderType.getType());
+            put("operation_type_id", orderType.getCode());
             put("acceptor_role_id", userAcceptorRoleId);
             put("order_base_type", orderBaseType.name());
         }};
@@ -1289,7 +1311,7 @@
         Map<String, Object> params = new HashMap<>();
         params.put("currency_pair_id", currencyPairId);
         params.put("status_id", OrderStatus.OPENED.getStatus());
-        params.put("operation_type_id", orderType.getOperationType().type);
+        params.put("operation_type_id", orderType.getOperationType().getCode());
 
         return slaveJdbcTemplate.query(sql, params, (rs, row) -> {
             OrderBookItem item = new OrderBookItem();
@@ -1326,7 +1348,7 @@
         Map<String, Object> params = new HashMap<>();
         params.put("currency_pair_id", currencyPairId);
         params.put("status_id", OrderStatus.OPENED.getStatus());
-        params.put("operation_type_id", orderType.getOperationType().type);
+        params.put("operation_type_id", orderType.getOperationType().getCode());
         return slaveJdbcTemplate.query(sql, params, (rs, row) -> {
             OpenOrderDto item = new OpenOrderDto();
             item.setId(rs.getInt("id"));
Index: Dao/src/main/java/me/exrates/dao/impl/StopOrderDaoImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Dao/src/main/java/me/exrates/dao/impl/StopOrderDaoImpl.java	(revision Local Version)
+++ Dao/src/main/java/me/exrates/dao/impl/StopOrderDaoImpl.java	(revision Shelved Version)
@@ -166,11 +166,11 @@
                     orderCreateDto.setCurrencyPair(currencyPair);
                     orderCreateDto.setAmount(rs.getBigDecimal("amount_base"));
                     orderCreateDto.setTotal(rs.getBigDecimal("amount_convert"));
-                    orderCreateDto.setComission(rs.getBigDecimal("commission_fixed_amount"));
+                    orderCreateDto.setCommission(rs.getBigDecimal("commission_fixed_amount"));
                     if (orderCreateDto.getOperationType() == OperationType.SELL) {
-                        orderCreateDto.setTotalWithComission(BigDecimalProcessing.doAction(orderCreateDto.getTotal(), orderCreateDto.getComission(), ActionType.SUBTRACT));
+                        orderCreateDto.setTotalWithComission(BigDecimalProcessing.doAction(orderCreateDto.getTotal(), orderCreateDto.getCommission(), ActionType.SUBTRACT));
                     } else {
-                        orderCreateDto.setTotalWithComission(BigDecimalProcessing.doAction(orderCreateDto.getTotal(), orderCreateDto.getComission(), ActionType.ADD));
+                        orderCreateDto.setTotalWithComission(BigDecimalProcessing.doAction(orderCreateDto.getTotal(), orderCreateDto.getCommission(), ActionType.ADD));
                     }
                     return orderCreateDto;
                 }
Index: Dao/src/main/java/me/exrates/dao/impl/TransactionDaoImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Dao/src/main/java/me/exrates/dao/impl/TransactionDaoImpl.java	(revision Local Version)
+++ Dao/src/main/java/me/exrates/dao/impl/TransactionDaoImpl.java	(revision Shelved Version)
@@ -296,7 +296,7 @@
           put("amount", transaction.getAmount());
           put("commissionAmount", transaction.getCommissionAmount());
           put("commission", transaction.getCommission() == null ? null : transaction.getCommission().getId());
-          put("operationType", transaction.getOperationType().type);
+          put("operationType", transaction.getOperationType().getCode());
           put("currency", transaction.getCurrency().getId());
           put("merchant", transaction.getMerchant() == null ? null : transaction.getMerchant().getId());
           put("datetime", transaction.getDatetime() == null ? null : Timestamp.valueOf(transaction.getDatetime()));
Index: Dao/src/main/java/me/exrates/dao/impl/UserDaoImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Dao/src/main/java/me/exrates/dao/impl/UserDaoImpl.java	(revision Local Version)
+++ Dao/src/main/java/me/exrates/dao/impl/UserDaoImpl.java	(revision Shelved Version)
@@ -147,7 +147,7 @@
     }
     namedParameters.put("phone", phone);
     namedParameters.put("status", String.valueOf(user.getStatus().getStatus()));
-    namedParameters.put("roleid", String.valueOf(user.getRole().getRole()));
+    namedParameters.put("roleid", String.valueOf(user.getRole().getCode()));
     KeyHolder keyHolder = new GeneratedKeyHolder();
     namedParameterJdbcTemplate.update(sqlUser, new MapSqlParameterSource(namedParameters), keyHolder);
     int userId = keyHolder.getKey().intValue();
@@ -259,7 +259,7 @@
         "WHERE role_id = :role_id";
     Map<String, Integer> params = new HashMap<>();
     params.put("user_id", userId);
-    params.put("role_id", role.getRole());
+    params.put("role_id", role.getCode());
     return namedParameterJdbcTemplate.update(sql, params) > 0;
 
   }
@@ -507,7 +507,7 @@
       fieldsStr.append("status = " + user.getStatus().getStatus()).append(",");
     }
     if (user.getRole() != null) {
-      fieldsStr.append("roleid = " + user.getRole().getRole()).append(",");
+      fieldsStr.append("roleid = " + user.getRole().getCode()).append(",");
     }
     if (user.getPassword() != null && !user.getPassword().isEmpty()) {
       fieldsStr.append("password = '" + passwordEncoder.encode(user.getPassword())).append("',");
Index: Dao/src/main/java/me/exrates/dao/impl/UserRoleDaoImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Dao/src/main/java/me/exrates/dao/impl/UserRoleDaoImpl.java	(revision Local Version)
+++ Dao/src/main/java/me/exrates/dao/impl/UserRoleDaoImpl.java	(revision Shelved Version)
@@ -87,7 +87,7 @@
             "considered_for_price_range = :considered_for_price_range " +
             "WHERE user_role_id = :role_id";
     Map<String, Object> params = new HashMap<>();
-    params.put("role_id", settings.getUserRole().getRole());
+    params.put("role_id", settings.getUserRole().getCode());
     params.put("same_role_only", settings.isOrderAcceptionSameRoleOnly());
     params.put("bot_acception_allowed", settings.isBotAcceptionAllowedOnly());
     params.put("considered_for_price_range", settings.isConsideredForPriceRange());
Index: Dao/src/main/java/me/exrates/dao/CurrencyDao.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Dao/src/main/java/me/exrates/dao/CurrencyDao.java	(revision Local Version)
+++ Dao/src/main/java/me/exrates/dao/CurrencyDao.java	(revision Shelved Version)
@@ -9,11 +9,11 @@
 import me.exrates.model.dto.mobileApiDto.TransferLimitDto;
 import me.exrates.model.dto.mobileApiDto.dashboard.CurrencyPairWithLimitsDto;
 import me.exrates.model.dto.openAPI.CurrencyPairInfoItem;
+import me.exrates.model.enums.CurrencyPairType;
 import me.exrates.model.enums.MerchantProcessType;
 import me.exrates.model.enums.OperationType;
 import me.exrates.model.enums.UserCommentTopicEnum;
 import me.exrates.model.enums.UserRole;
-import me.exrates.model.enums.*;
 
 import java.math.BigDecimal;
 import java.util.List;
@@ -21,37 +21,37 @@
 
 public interface CurrencyDao {
 
-  List<Currency> getCurrList();
+    List<Currency> getCurrencyList();
 
-  int getCurrencyId(int walletId);
+    int getCurrencyId(int walletId);
 
-  String getCurrencyName(int currencyId);
+    String getCurrencyName(int currencyId);
 
-  Currency findByName(String name);
+    Currency findByName(String name);
 
-  Currency findById(int id);
+    Currency findById(int id);
 
-  List<Currency> findAllCurrencies();
+    List<Currency> findAllCurrencies();
 
-  List<CurrencyLimit> retrieveCurrencyLimitsForRoles(List<Integer> roleIds, OperationType operationType);
+    List<CurrencyLimit> getCurrencyLimitsForRoles(List<Integer> roleIds, OperationType operationType);
 
-  List<TransferLimitDto> retrieveMinTransferLimits(List<Integer> currencyIds, Integer roleId);
+    List<TransferLimitDto> retrieveMinTransferLimits(List<Integer> currencyIds, Integer roleId);
 
-  BigDecimal retrieveMinLimitForRoleAndCurrency(UserRole userRole, OperationType operationType, Integer currencyId);
+    BigDecimal getMinLimitForRoleAndCurrency(UserRole userRole, OperationType operationType, Integer currencyId);
 
-  void updateCurrencyLimit(int currencyId, OperationType operationType, List<Integer> roleIds, BigDecimal minAmount, Integer maxDailyRequest);
+    void updateCurrencyLimit(int currencyId, OperationType operationType, List<Integer> roleIds, BigDecimal minAmount, Integer maxDailyRequest);
 
-  List<CurrencyPair> getAllCurrencyPairs(CurrencyPairType type);
+    List<CurrencyPair> getAllCurrencyPairs(CurrencyPairType type);
 
-  CurrencyPair getCurrencyPairById(int currency1Id, int currency2Id);
+    CurrencyPair getCurrencyPairById(int currency1Id, int currency2Id);
 
-  CurrencyPair findCurrencyPairById(int currencyPairId);
+    CurrencyPair findCurrencyPairById(int currencyPairId);
 
-  List<UserCurrencyOperationPermissionDto> findCurrencyOperationPermittedByUserAndDirection(Integer userId, String operationDirection);
+    List<UserCurrencyOperationPermissionDto> findCurrencyOperationPermittedByUserAndDirection(Integer userId, String operationDirection);
 
-  List<UserCurrencyOperationPermissionDto> findCurrencyOperationPermittedByUserList(Integer userId);
+    List<UserCurrencyOperationPermissionDto> findCurrencyOperationPermittedByUserList(Integer userId);
 
-  List<String> getWarningForCurrency(Integer currencyId, UserCommentTopicEnum currencyWarningTopicEnum);
+    List<String> getWarningForCurrency(Integer currencyId, UserCommentTopicEnum currencyWarningTopicEnum);
 
     List<String> getWarningsByTopic(UserCommentTopicEnum currencyWarningTopicEnum);
 
@@ -59,29 +59,30 @@
 
     CurrencyPair findCurrencyPairByOrderId(int orderId);
 
-  CurrencyPairLimitDto findCurrencyPairLimitForRoleByPairAndType(Integer currencyPairId, Integer roleId, Integer orderTypeId);
+    CurrencyPairLimitDto findCurrencyPairLimitForRoleByPairAndType(Integer currencyPairId, Integer roleId, Integer orderTypeId);
 
-  List<CurrencyPairLimitDto> findLimitsForRolesByType(List<Integer> roleIds, Integer orderTypeId);
+    List<CurrencyPairLimitDto> findLimitsForRolesByType(List<Integer> roleIds, Integer orderTypeId);
 
-  void setCurrencyPairLimit(Integer currencyPairId, List<Integer> roleIds, Integer orderTypeId,
-                            BigDecimal minRate, BigDecimal maxRate, BigDecimal minAmount, BigDecimal maxAmount);
+    void setCurrencyPairLimit(Integer currencyPairId, List<Integer> roleIds, Integer orderTypeId,
+                              BigDecimal minRate, BigDecimal maxRate, BigDecimal minAmount, BigDecimal maxAmount);
 
-  List<CurrencyPairWithLimitsDto> findAllCurrencyPairsWithLimits(Integer roleId);
+    List<CurrencyPairWithLimitsDto> findAllCurrencyPairsWithLimits(Integer roleId);
 
-  List<Currency> findAllCurrenciesWithHidden();
+    List<Currency> findAllCurrenciesWithHidden();
 
-  MerchantCurrencyScaleDto findCurrencyScaleByCurrencyId(Integer currencyId);
+    MerchantCurrencyScaleDto findCurrencyScaleByCurrencyId(Integer currencyId);
 
-  CurrencyPair findCurrencyPairByName(String pairName);
+    CurrencyPair findCurrencyPairByName(String pairName);
 
-  List<Currency> findAllCurrenciesByProcessType(MerchantProcessType processType);
+    List<Currency> findAllCurrenciesByProcessType(MerchantProcessType processType);
 
-  List<CurrencyPair> findPermitedCurrencyPairs(CurrencyPairType currencyPairType);
+    List<CurrencyPair> findPermitedCurrencyPairs(CurrencyPairType currencyPairType);
 
     CurrencyPair getNotHiddenCurrencyPairByName(String currencyPair);
 
     boolean isCurrencyIco(Integer currencyId);
+
     List<CurrencyPairInfoItem> findActiveCurrencyPairs();
 
-  Optional<Integer> findOpenCurrencyPairIdByName(String pairName);
+    Optional<Integer> findOpenCurrencyPairIdByName(String pairName);
 }
\ No newline at end of file
Index: Model/src/main/java/me/exrates/model/dto/mobileApiDto/OrderCreationParamsDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/mobileApiDto/OrderCreationParamsDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/mobileApiDto/OrderCreationParamsDto.java	(revision Shelved Version)
@@ -1,14 +1,20 @@
 package me.exrates.model.dto.mobileApiDto;
 
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
 import me.exrates.model.enums.OperationType;
 
 import javax.validation.constraints.NotNull;
 import java.math.BigDecimal;
 
-/**
- * Created by OLEG on 01.09.2016.
- */
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
 public class OrderCreationParamsDto {
+
     @NotNull
     private Integer currencyPairId;
     @NotNull
@@ -17,56 +23,4 @@
     private BigDecimal amount;
     @NotNull
     private BigDecimal rate;
-
-    public OrderCreationParamsDto() {
-    }
-
-    public OrderCreationParamsDto(Integer currencyPairId, OperationType orderType, BigDecimal amount, BigDecimal rate) {
-        this.currencyPairId = currencyPairId;
-        this.orderType = orderType;
-        this.amount = amount;
-        this.rate = rate;
-    }
-
-    public Integer getCurrencyPairId() {
-        return currencyPairId;
-    }
-
-    public void setCurrencyPairId(Integer currencyPairId) {
-        this.currencyPairId = currencyPairId;
-    }
-
-    public OperationType getOrderType() {
-        return orderType;
-    }
-
-    public void setOrderType(OperationType orderType) {
-        this.orderType = orderType;
-    }
-
-    public BigDecimal getAmount() {
-        return amount;
-    }
-
-    public void setAmount(BigDecimal amount) {
-        this.amount = amount;
-    }
-
-    public BigDecimal getRate() {
-        return rate;
-    }
-
-    public void setRate(BigDecimal rate) {
-        this.rate = rate;
-    }
-
-    @Override
-    public String toString() {
-        return "OrderCreationParamsDto{" +
-                "currencyPairId=" + currencyPairId +
-                ", orderType=" + orderType +
-                ", amount=" + amount +
-                ", rate=" + rate +
-                '}';
-    }
 }
Index: Model/src/main/java/me/exrates/model/dto/mobileApiDto/OrderSummaryDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/mobileApiDto/OrderSummaryDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/mobileApiDto/OrderSummaryDto.java	(revision Shelved Version)
@@ -32,7 +32,7 @@
         this.amount = dto.getAmount();
         this.exrate = dto.getExchangeRate();
         this.total = dto.getTotal();
-        this.commission = dto.getComission();
+        this.commission = dto.getCommission();
         this.totalWithComission = dto.getTotalWithComission();
         this.key = key;
     }
Index: Model/src/main/java/me/exrates/model/dto/mobileApiDto/TransferLimitDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/mobileApiDto/TransferLimitDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/mobileApiDto/TransferLimitDto.java	(revision Shelved Version)
@@ -1,27 +1,12 @@
 package me.exrates.model.dto.mobileApiDto;
 
+import lombok.Data;
+
 import java.math.BigDecimal;
 
-/**
- * Created by OLEG on 13.02.2017.
- */
+@Data
 public class TransferLimitDto {
+
     private Integer currencyId;
     private BigDecimal transferMinLimit;
-
-    public Integer getCurrencyId() {
-        return currencyId;
-    }
-
-    public void setCurrencyId(Integer currencyId) {
-        this.currencyId = currencyId;
-    }
-
-    public BigDecimal getTransferMinLimit() {
-        return transferMinLimit;
-    }
-
-    public void setTransferMinLimit(BigDecimal transferMinLimit) {
-        this.transferMinLimit = transferMinLimit;
-    }
 }
Index: Model/src/main/java/me/exrates/model/dto/openAPI/OpenApiCommissionDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/openAPI/OpenApiCommissionDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/openAPI/OpenApiCommissionDto.java	(revision Shelved Version)
@@ -1,16 +1,13 @@
 package me.exrates.model.dto.openAPI;
 
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
-import lombok.Getter;
-import lombok.Setter;
-import lombok.ToString;
+import lombok.Data;
 import me.exrates.model.dto.mobileApiDto.dashboard.CommissionsDto;
 import me.exrates.model.serializer.BigDecimalToDoubleSerializer;
 
 import java.math.BigDecimal;
 
-@Getter @Setter
-@ToString
+@Data
 public class OpenApiCommissionDto {
 
     @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
Index: Model/src/main/java/me/exrates/model/dto/openAPI/OrderBookItem.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/openAPI/OrderBookItem.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/openAPI/OrderBookItem.java	(revision Shelved Version)
@@ -2,24 +2,19 @@
 
 import com.fasterxml.jackson.annotation.JsonIgnore;
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
-import lombok.Getter;
-import lombok.Setter;
-import lombok.ToString;
+import lombok.Data;
 import me.exrates.model.enums.OrderType;
 import me.exrates.model.serializer.BigDecimalToDoubleSerializer;
 
 import java.math.BigDecimal;
 
-@Getter @Setter
-@ToString
+@Data
 public class OrderBookItem {
 
     @JsonIgnore
     private OrderType orderType;
-
     @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
     private BigDecimal amount;
-
     @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
     private BigDecimal rate;
 }
Index: Model/src/main/java/me/exrates/model/dto/openAPI/OrderCreationDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/openAPI/OrderCreationDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/openAPI/OrderCreationDto.java	(revision Shelved Version)
@@ -8,6 +8,8 @@
 
 import java.math.BigDecimal;
 
+import static java.util.Objects.requireNonNull;
+
 @Getter
 @ToString
 public class OrderCreationDto {
@@ -25,7 +27,7 @@
     private BigDecimal partiallyAcceptedAmount;
 
     public OrderCreationDto(OrderCreationResultDto orderCreationResultDto) {
-        this.createdOrderId = orderCreationResultDto.getCreatedOrderId();
+        this.createdOrderId = requireNonNull(orderCreationResultDto.getCreatedOrderId(), "Created order id should not be null");
         this.autoAcceptedQuantity = orderCreationResultDto.getAutoAcceptedQuantity();
         this.partiallyAcceptedAmount = orderCreationResultDto.getPartiallyAcceptedAmount();
     }
Index: Model/src/main/java/me/exrates/model/dto/openAPI/OrderHistoryItem.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/openAPI/OrderHistoryItem.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/openAPI/OrderHistoryItem.java	(revision Shelved Version)
@@ -2,9 +2,7 @@
 
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
-import lombok.Getter;
-import lombok.Setter;
-import lombok.ToString;
+import lombok.Data;
 import me.exrates.model.enums.OrderType;
 import me.exrates.model.serializer.BigDecimalToDoubleSerializer;
 import me.exrates.model.serializer.LocalDateTimeToLongSerializer;
@@ -12,22 +10,18 @@
 import java.math.BigDecimal;
 import java.time.LocalDateTime;
 
-@Getter @Setter
-@ToString
+@Data
 public class OrderHistoryItem {
+
     @JsonProperty("order_id")
     private Integer orderId;
-
     @JsonProperty("date_acceptance")
     @JsonSerialize(using = LocalDateTimeToLongSerializer.class)
     private LocalDateTime dateAcceptance;
-
     @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
     private BigDecimal amount;
-
     @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
     private BigDecimal price;
-
     @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
     private BigDecimal total;
     @JsonProperty("order_type")
Index: Model/src/main/java/me/exrates/model/dto/openAPI/OrderParamsDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/openAPI/OrderParamsDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/openAPI/OrderParamsRequest.java	(revision Shelved Version)
@@ -9,9 +9,10 @@
 import javax.validation.constraints.NotNull;
 import java.math.BigDecimal;
 
-@Getter @Setter
+@Getter
+@Setter
 @ToString
-public class OrderParamsDto {
+public class OrderParamsRequest {
 
     @NotNull
     @JsonProperty("currency_pair")
Index: Model/src/main/java/me/exrates/model/dto/openAPI/TickerJsonDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/openAPI/TickerJsonDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/openAPI/TickerJsonDto.java	(revision Shelved Version)
@@ -1,53 +1,44 @@
 package me.exrates.model.dto.openAPI;
 
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
-import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
-import lombok.EqualsAndHashCode;
-import lombok.Getter;
-import lombok.Setter;
-import lombok.ToString;
+import lombok.Data;
 import me.exrates.model.dto.CoinmarketApiDto;
-import me.exrates.model.serializer.BigDecimalNonePointSerializer;
 import me.exrates.model.serializer.BigDecimalToDoubleSerializer;
 
 import java.math.BigDecimal;
 
-/**
- * Created by OLEG on 20.03.2017.
- */
-@Getter @Setter
-@EqualsAndHashCode
-@ToString
+@Data
 public class TickerJsonDto {
-  private Integer id;
-  private String name;
-  @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
-  private BigDecimal last;
-  @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
-  private BigDecimal lowestAsk;
-  @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
-  private BigDecimal highestBid;
-  @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
-  private BigDecimal percentChange;
-  @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
-  private BigDecimal baseVolume;
-  @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
-  private BigDecimal quoteVolume;
-  @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
-  private BigDecimal high;
-  @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
-  private BigDecimal low;
+
+    private Integer id;
+    private String name;
+    @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
+    private BigDecimal last;
+    @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
+    private BigDecimal lowestAsk;
+    @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
+    private BigDecimal highestBid;
+    @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
+    private BigDecimal percentChange;
+    @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
+    private BigDecimal baseVolume;
+    @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
+    private BigDecimal quoteVolume;
+    @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
+    private BigDecimal high;
+    @JsonSerialize(using = BigDecimalToDoubleSerializer.class)
+    private BigDecimal low;
 
-  public TickerJsonDto(CoinmarketApiDto coinmarketApiDto) {
-    this.id = coinmarketApiDto.getCurrencyPairId();
-    this.name = coinmarketApiDto.getCurrency_pair_name().replace('/', '_');
-    this.last = coinmarketApiDto.getLast();
-    this.lowestAsk = coinmarketApiDto.getLowestAsk();
-    this.highestBid = coinmarketApiDto.getHighestBid();
-    this.percentChange = coinmarketApiDto.getPercentChange();
-    this.baseVolume = coinmarketApiDto.getBaseVolume();
-    this.quoteVolume = coinmarketApiDto.getQuoteVolume();
-    this.high = coinmarketApiDto.getHigh24hr();
-    this.low = coinmarketApiDto.getLow24hr();
-  }
+    public TickerJsonDto(CoinmarketApiDto coinmarketApiDto) {
+        this.id = coinmarketApiDto.getCurrencyPairId();
+        this.name = coinmarketApiDto.getCurrency_pair_name().replace('/', '_');
+        this.last = coinmarketApiDto.getLast();
+        this.lowestAsk = coinmarketApiDto.getLowestAsk();
+        this.highestBid = coinmarketApiDto.getHighestBid();
+        this.percentChange = coinmarketApiDto.getPercentChange();
+        this.baseVolume = coinmarketApiDto.getBaseVolume();
+        this.quoteVolume = coinmarketApiDto.getQuoteVolume();
+        this.high = coinmarketApiDto.getHigh24hr();
+        this.low = coinmarketApiDto.getLow24hr();
+    }
 }
Index: Model/src/main/java/me/exrates/model/dto/CoinmarketApiDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/CoinmarketApiDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/CoinmarketApiDto.java	(revision Shelved Version)
@@ -1,14 +1,16 @@
 package me.exrates.model.dto;
 
+import lombok.Data;
+import lombok.NoArgsConstructor;
 import me.exrates.model.CurrencyPair;
 import me.exrates.model.util.BigDecimalProcessing;
 
 import java.math.BigDecimal;
 
-/**
- * Created by Valk on 10.05.2016.
- */
+@Data
+@NoArgsConstructor
 public class CoinmarketApiDto {
+
     private Integer currencyPairId;
     private String currency_pair_name;
     private BigDecimal first;
@@ -22,124 +24,22 @@
     private BigDecimal high24hr;
     private BigDecimal low24hr;
 
-    public Integer getCurrencyPairId() {
-        return currencyPairId;
-    }
-
-    public void setCurrencyPairId(Integer currencyPairId) {
-        this.currencyPairId = currencyPairId;
-    }
-    /*constructor*/
-
-    public CoinmarketApiDto() {
-    }
-
     public CoinmarketApiDto(CurrencyPair currencyPair) {
         this.currency_pair_name = currencyPair.getName();
     }
 
     @Override
     public String toString() {
-        return '"'+currency_pair_name.replace('/','_')+"\":" +
-                "{\"last\":"+ BigDecimalProcessing.formatNonePointQuoted(last, true) +
+        return '"' + currency_pair_name.replace('/', '_') + "\":" +
+                "{\"last\":" + BigDecimalProcessing.formatNonePointQuoted(last, true) +
                 ", \"lowestAsk\":" + BigDecimalProcessing.formatNonePointQuoted(lowestAsk, true) +
                 ", \"highestBid\":" + BigDecimalProcessing.formatNonePointQuoted(highestBid, true) +
                 ", \"percentChange\":" + BigDecimalProcessing.formatNonePointQuoted(percentChange, true) +
                 ", \"baseVolume\":" + BigDecimalProcessing.formatNonePointQuoted(baseVolume, true) +
                 ", \"quoteVolume\":" + BigDecimalProcessing.formatNonePointQuoted(quoteVolume, true) +
-                ", \"isFrozen\":" + '"'+isFrozen+'"' +
+                ", \"isFrozen\":" + '"' + isFrozen + '"' +
                 ", \"high24hr\":" + BigDecimalProcessing.formatNonePointQuoted(high24hr, true) +
                 ", \"low24hr\":" + BigDecimalProcessing.formatNonePointQuoted(low24hr, true) +
                 '}';
     }
-
-    /*getters setters*/
-
-    public String getCurrency_pair_name() {
-        return currency_pair_name;
-    }
-
-    public void setCurrency_pair_name(String currency_pair_name) {
-        this.currency_pair_name = currency_pair_name;
-    }
-
-    public BigDecimal getFirst() {
-        return first;
-    }
-
-    public void setFirst(BigDecimal first) {
-        this.first = first;
-    }
-
-    public BigDecimal getLast() {
-        return last;
-    }
-
-    public void setLast(BigDecimal last) {
-        this.last = last;
-    }
-
-    public BigDecimal getLowestAsk() {
-        return lowestAsk;
-    }
-
-    public void setLowestAsk(BigDecimal lowestAsk) {
-        this.lowestAsk = lowestAsk;
-    }
-
-    public BigDecimal getHighestBid() {
-        return highestBid;
-    }
-
-    public void setHighestBid(BigDecimal highestBid) {
-        this.highestBid = highestBid;
-    }
-
-    public BigDecimal getPercentChange() {
-        return percentChange;
-    }
-
-    public void setPercentChange(BigDecimal percentChange) {
-        this.percentChange = percentChange;
-    }
-
-    public BigDecimal getBaseVolume() {
-        return baseVolume;
-    }
-
-    public void setBaseVolume(BigDecimal baseVolume) {
-        this.baseVolume = baseVolume;
-    }
-
-    public BigDecimal getQuoteVolume() {
-        return quoteVolume;
-    }
-
-    public void setQuoteVolume(BigDecimal quoteVolume) {
-        this.quoteVolume = quoteVolume;
-    }
-
-    public Integer getIsFrozen() {
-        return isFrozen;
-    }
-
-    public void setIsFrozen(Integer isFrozen) {
-        this.isFrozen = isFrozen;
-    }
-
-    public BigDecimal getHigh24hr() {
-        return high24hr;
-    }
-
-    public void setHigh24hr(BigDecimal high24hr) {
-        this.high24hr = high24hr;
-    }
-
-    public BigDecimal getLow24hr() {
-        return low24hr;
-    }
-
-    public void setLow24hr(BigDecimal low24hr) {
-        this.low24hr = low24hr;
-    }
 }
Index: Model/src/main/java/me/exrates/model/dto/MerchantCurrencyScaleDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/MerchantCurrencyScaleDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/MerchantCurrencyScaleDto.java	(revision Shelved Version)
@@ -1,17 +1,14 @@
 package me.exrates.model.dto;
 
+import lombok.Data;
 import lombok.Getter;
 import lombok.NoArgsConstructor;
 import lombok.Setter;
 import lombok.ToString;
 
-/**
- * Created by ValkSam
- */
-@Getter @Setter
-@NoArgsConstructor
-@ToString
+@Data
 public class MerchantCurrencyScaleDto {
+
   private Integer merchantId;
   private Integer currencyId;
   private Integer scaleForRefill;
Index: Model/src/main/java/me/exrates/model/dto/OrderCreateDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/OrderCreateDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/OrderCreateDto.java	(revision Shelved Version)
@@ -1,5 +1,9 @@
 package me.exrates.model.dto;
 
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
 import me.exrates.model.CurrencyPair;
 import me.exrates.model.enums.ActionType;
 import me.exrates.model.enums.OperationType;
@@ -8,300 +12,74 @@
 
 import java.math.BigDecimal;
 
+import static java.util.Objects.isNull;
 import static me.exrates.model.util.BigDecimalProcessing.doAction;
-import static me.exrates.model.util.BigDecimalProcessing.normalize;
 
-/**
- * Created by Valk on 13.04.16.
- */
-
+@Data
+@Builder(builderClassName = "Builder", toBuilder = true)
+@NoArgsConstructor
+@AllArgsConstructor
 public class OrderCreateDto {
-    /*this field filled from existing order*/
+    //this field filled from existing order
     private int orderId;
     private int userId;
     private OrderStatus status;
-    /*these fields will be transferred to blank creation form */
+    //these fields will be transferred to blank creation form
     private CurrencyPair currencyPair;
-    private int comissionForBuyId;
-    private BigDecimal comissionForBuyRate;
-    private int comissionForSellId;
-    private BigDecimal comissionForSellRate;
+    private int commissionForBuyId;
+    private BigDecimal commissionForBuyRate;
+    private int commissionForSellId;
+    private BigDecimal commissionForSellRate;
     private int walletIdCurrencyBase;
     private BigDecimal currencyBaseBalance;
     private int walletIdCurrencyConvert;
     private BigDecimal currencyConvertBalance;
-    //
-    /*these fields will be returned from creation form after submitting*/
-    /*IMPORTANT: operationType is not populated because OrderCreateDto is used for page the orders,
-that consists two forms: for BUY and for SELL. After submit this field will be set because we submit concrete form: BUY or SELL.
-However if we transfered to form the orders from dashboard, the fields one form (of two forms: SELL or BUY) must be filled.
-To determine which of these forms to be filled, we must set field operationType
-*/
+    //these fields will be returned from creation form after submitting*/
+    //IMPORTANT: operationType is not populated because OrderCreateDto is used for page the orders,
+    //that consists two forms: for BUY and for SELL. After submit this field will be set because we submit concrete form: BUY or SELL.
+    //However, if we transferred to form the orders from dashboard, the fields one form (of two forms: SELL or BUY) must be filled.
+    //To determine which of these forms to be filled, we must set field operationType
     private BigDecimal stop; //stop rate for stop order
     private OperationType operationType;
     private BigDecimal exchangeRate;
-    private BigDecimal amount; //amount of base currency: base currency can be bought or sold dependending on operationType
+    private BigDecimal amount; //amount of base currency: base currency can be bought or sold depending on operationType
     private OrderBaseType orderBaseType;
-    //
-    /*
-    * these fields will be calculated after submitting the order and before final creation confirmation the order
-    * (here: OrderController.submitNewOrderToSell())
-    * These amounts calculated directly in java (after check the order parameters in java validator) and will be persistented in db
-    * (before this step these amounts were being calculated by javascript and may be occur some difference)
-    * */
+    //these fields will be calculated after submitting the order and before final creation confirmation the order
+    //(here: OrderController.submitNewOrderToSell())
+    //These amounts calculated directly in java (after check the order parameters in java validator) and will be persistent in db
+    //(before this step these amounts were being calculated by javascript and may be occur some difference)
     private BigDecimal spentWalletBalance;
     private BigDecimal spentAmount;
     private BigDecimal total; //calculated amount of currency conversion = amount * exchangeRate
-    private int comissionId;
-    private BigDecimal comission; //calculated comission amount depending on operationType and corresponding comission rate
-    private BigDecimal totalWithComission; //total + comission
+    private int commissionId;
+    private BigDecimal commission; //calculated commission amount depending on operationType and corresponding commission rate
+    private BigDecimal totalWithComission; //total + commission
     private Integer sourceId;
 
-    /*constructors*/
-
-    public OrderCreateDto() {
-    }
-
     /*service methods*/
     public OrderCreateDto calculateAmounts() {
-        if (operationType == null) {
+        if (isNull(operationType)) {
             return this;
         }
-        if (operationType == OperationType.SELL) {
-            this.spentWalletBalance = this.currencyBaseBalance == null ? BigDecimal.ZERO : this.currencyBaseBalance;
-            this.total = doAction(this.amount, this.exchangeRate, ActionType.MULTIPLY);
-            this.comissionId = this.comissionForSellId;
-            this.comission = doAction(this.total, this.comissionForSellRate, ActionType.MULTIPLY_PERCENT);
-            this.totalWithComission = doAction(this.total, this.comission.negate(), ActionType.ADD);
-            this.spentAmount = this.amount;
-        } else if (operationType == OperationType.BUY) {
-            this.spentWalletBalance = this.currencyConvertBalance == null ? BigDecimal.ZERO : this.currencyConvertBalance;
-            this.total = doAction(this.amount, this.exchangeRate, ActionType.MULTIPLY);
-            this.comissionId = this.comissionForBuyId;
-            this.comission = doAction(this.total, this.comissionForBuyRate, ActionType.MULTIPLY_PERCENT);
-            this.totalWithComission = doAction(this.total, this.comission, ActionType.ADD);
-            this.spentAmount = doAction(this.total, this.comission, ActionType.ADD);
-        }
-        return this;
-    }
-
-    @Override
-    public String toString() {
-        return "OrderCreateDto{" +
-                "orderId=" + orderId +
-                ", userId=" + userId +
-                ", status=" + status +
-                ", currencyPair=" + currencyPair +
-                ", comissionForBuyId=" + comissionForBuyId +
-                ", comissionForBuyRate=" + comissionForBuyRate +
-                ", comissionForSellId=" + comissionForSellId +
-                ", comissionForSellRate=" + comissionForSellRate +
-                ", walletIdCurrencyBase=" + walletIdCurrencyBase +
-                ", currencyBaseBalance=" + currencyBaseBalance +
-                ", walletIdCurrencyConvert=" + walletIdCurrencyConvert +
-                ", currencyConvertBalance=" + currencyConvertBalance +
-                ", operationType=" + operationType +
-                ", exchangeRate=" + exchangeRate +
-                ", spentWalletBalance=" + spentWalletBalance +
-                ", spentAmount=" + spentAmount +
-                ", amount=" + amount +
-                ", total=" + total +
-                ", comissionId=" + comissionId +
-                ", comission=" + comission +
-                ", totalWithComission=" + totalWithComission +
-                '}';
+        switch (operationType) {
+            case BUY:
+                this.spentWalletBalance = isNull(this.currencyConvertBalance) ? BigDecimal.ZERO : this.currencyConvertBalance;
+                this.total = doAction(this.amount, this.exchangeRate, ActionType.MULTIPLY);
+                this.commissionId = this.commissionForBuyId;
+                this.commission = doAction(this.total, this.commissionForBuyRate, ActionType.MULTIPLY_PERCENT);
+                this.totalWithComission = doAction(this.total, this.commission, ActionType.ADD);
+                this.spentAmount = doAction(this.total, this.commission, ActionType.ADD);
+                return this;
+            case SELL:
+                this.spentWalletBalance = isNull(this.currencyBaseBalance) ? BigDecimal.ZERO : this.currencyBaseBalance;
+                this.total = doAction(this.amount, this.exchangeRate, ActionType.MULTIPLY);
+                this.commissionId = this.commissionForSellId;
+                this.commission = doAction(this.total, this.commissionForSellRate, ActionType.MULTIPLY_PERCENT);
+                this.totalWithComission = doAction(this.total, this.commission.negate(), ActionType.ADD);
+                this.spentAmount = this.amount;
+                return this;
+            default:
+                return this;
+        }
     }
-
-    /*getters setters*/
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public OrderStatus getStatus() {
-        return status;
-    }
-
-    public void setStatus(OrderStatus status) {
-        this.status = status;
-    }
-
-    public int getOrderId() {
-        return orderId;
-    }
-
-    public void setOrderId(int orderId) {
-        this.orderId = orderId;
-    }
-
-    public CurrencyPair getCurrencyPair() {
-        return currencyPair;
-    }
-
-    public void setCurrencyPair(CurrencyPair currencyPair) {
-        this.currencyPair = currencyPair;
-    }
-
-    public int getComissionForBuyId() {
-        return comissionForBuyId;
-    }
-
-    public void setComissionForBuyId(int comissionForBuyId) {
-        this.comissionForBuyId = comissionForBuyId;
-    }
-
-    public BigDecimal getComissionForBuyRate() {
-        return normalize(comissionForBuyRate);
-    }
-
-    public void setComissionForBuyRate(BigDecimal comissionForBuyRate) {
-        this.comissionForBuyRate = comissionForBuyRate;
-    }
-
-    public int getComissionForSellId() {
-        return comissionForSellId;
-    }
-
-    public void setComissionForSellId(int comissionForSellId) {
-        this.comissionForSellId = comissionForSellId;
-    }
-
-    public BigDecimal getComissionForSellRate() {
-        return normalize(comissionForSellRate);
-    }
-
-    public void setComissionForSellRate(BigDecimal comissionForSellRate) {
-        this.comissionForSellRate = comissionForSellRate;
-    }
-
-    public int getWalletIdCurrencyBase() {
-        return walletIdCurrencyBase;
-    }
-
-    public void setWalletIdCurrencyBase(int walletIdCurrencyBase) {
-        this.walletIdCurrencyBase = walletIdCurrencyBase;
-    }
-
-    public BigDecimal getCurrencyBaseBalance() {
-        return normalize(currencyBaseBalance);
-    }
-
-    public void setCurrencyBaseBalance(BigDecimal currencyBaseBalance) {
-        this.currencyBaseBalance = currencyBaseBalance;
-    }
-
-    public int getWalletIdCurrencyConvert() {
-        return walletIdCurrencyConvert;
-    }
-
-    public void setWalletIdCurrencyConvert(int walletIdCurrencyConvert) {
-        this.walletIdCurrencyConvert = walletIdCurrencyConvert;
-    }
-
-    public BigDecimal getCurrencyConvertBalance() {
-        return normalize(currencyConvertBalance);
-    }
-
-    public void setCurrencyConvertBalance(BigDecimal currencyConvertBalance) {
-        this.currencyConvertBalance = currencyConvertBalance;
-    }
-
-    public OperationType getOperationType() {
-        return operationType;
-    }
-
-    public void setOperationType(OperationType operationType) {
-        this.operationType = operationType;
-    }
-
-    public BigDecimal getExchangeRate() {
-        return normalize(exchangeRate);
-    }
-
-    public void setExchangeRate(BigDecimal exchangeRate) {
-        this.exchangeRate = exchangeRate;
-    }
-
-    public BigDecimal getSpentWalletBalance() {
-        return normalize(spentWalletBalance);
-    }
-
-    public void setSpentWalletBalance(BigDecimal balance) {
-        this.spentWalletBalance = balance;
-    }
-
-    public BigDecimal getSpentAmount() {
-        return spentAmount;
-    }
-
-    public void setSpentAmount(BigDecimal spentAmount) {
-        this.spentAmount = normalize(spentAmount);
-    }
-
-    public BigDecimal getAmount() {
-        return normalize(amount);
-    }
-
-    public void setAmount(BigDecimal amount) {
-        this.amount = amount;
-    }
-
-    public BigDecimal getTotal() {
-        return normalize(total);
-    }
-
-    public void setTotal(BigDecimal total) {
-        this.total = total;
-    }
-
-    public int getComissionId() {
-        return comissionId;
-    }
-
-    public void setComissionId(int comissionId) {
-        this.comissionId = comissionId;
-    }
-
-    public BigDecimal getComission() {
-        return (comission);
-    }
-
-    public void setComission(BigDecimal comission) {
-        this.comission = comission;
-    }
-
-    public BigDecimal getTotalWithComission() {
-        return normalize(totalWithComission);
-    }
-
-    public void setTotalWithComission(BigDecimal totalWithComission) {
-        this.totalWithComission = totalWithComission;
-    }
-
-    public Integer getSourceId() {
-        return sourceId;
-    }
-
-    public void setSourceId(Integer sourceId) {
-        this.sourceId = sourceId;
-    }
-
-    public BigDecimal getStop() {
-        return stop;
-    }
-
-    public void setStop(BigDecimal stop) {
-        this.stop = stop;
-    }
-
-    public OrderBaseType getOrderBaseType() {
-        return orderBaseType;
-    }
-
-    public void setOrderBaseType(OrderBaseType orderBaseType) {
-        this.orderBaseType = orderBaseType;
-    }
 }
Index: Model/src/main/java/me/exrates/model/dto/OrderCreateSummaryDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/OrderCreateSummaryDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/OrderCreateSummaryDto.java	(revision Shelved Version)
@@ -32,7 +32,7 @@
         this.amount = BigDecimalProcessing.formatLocale(orderCreateDto.getAmount(), locale, 2);
         this.exrate = BigDecimalProcessing.formatLocale(orderCreateDto.getExchangeRate(), locale, 2);
         this.total = BigDecimalProcessing.formatLocale(orderCreateDto.getTotal(), locale, 2);
-        this.commission = BigDecimalProcessing.formatLocale(orderCreateDto.getComission(), locale, 2);
+        this.commission = BigDecimalProcessing.formatLocale(orderCreateDto.getCommission(), locale, 2);
         this.totalWithComission = BigDecimalProcessing.formatLocale(orderCreateDto.getTotalWithComission(), locale, 2);
         this.stop = BigDecimalProcessing.formatLocale(orderCreateDto.getStop(), locale, 2);
         this.baseType = orderCreateDto.getOrderBaseType().name();
Index: Model/src/main/java/me/exrates/model/dto/OrderCreationResultDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/OrderCreationResultDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/OrderCreationResultDto.java	(revision Shelved Version)
@@ -1,13 +1,17 @@
 package me.exrates.model.dto;
 
 import com.fasterxml.jackson.annotation.JsonInclude;
+import lombok.*;
 
 import java.math.BigDecimal;
 
-/**
- * Created by OLEG on 21.11.2016.
- */
+@Getter
+@Builder(builderClassName = "Builder", toBuilder = true)
+@NoArgsConstructor
+@AllArgsConstructor
+@ToString
 public class OrderCreationResultDto {
+
     @JsonInclude(JsonInclude.Include.NON_NULL)
     private Integer createdOrderId;
     @JsonInclude(JsonInclude.Include.NON_NULL)
@@ -16,46 +20,4 @@
     private BigDecimal partiallyAcceptedAmount;
     @JsonInclude(JsonInclude.Include.NON_NULL)
     private BigDecimal partiallyAcceptedOrderFullAmount;
-
-    public Integer getCreatedOrderId() {
-        return createdOrderId;
-    }
-
-    public void setCreatedOrderId(Integer createdOrderId) {
-        this.createdOrderId = createdOrderId;
-    }
-
-    public Integer getAutoAcceptedQuantity() {
-        return autoAcceptedQuantity;
-    }
-
-    public void setAutoAcceptedQuantity(Integer autoAcceptedQuantity) {
-        this.autoAcceptedQuantity = autoAcceptedQuantity;
-    }
-
-    public BigDecimal getPartiallyAcceptedAmount() {
-        return partiallyAcceptedAmount;
-    }
-
-    public void setPartiallyAcceptedAmount(BigDecimal partiallyAcceptedAmount) {
-        this.partiallyAcceptedAmount = partiallyAcceptedAmount;
-    }
-
-    public BigDecimal getPartiallyAcceptedOrderFullAmount() {
-        return partiallyAcceptedOrderFullAmount;
-    }
-
-    public void setPartiallyAcceptedOrderFullAmount(BigDecimal partiallyAcceptedOrderFullAmount) {
-        this.partiallyAcceptedOrderFullAmount = partiallyAcceptedOrderFullAmount;
-    }
-
-    @Override
-    public String toString() {
-        return "OrderCreationResultDto{" +
-                "createdOrderId=" + createdOrderId +
-                ", autoAcceptedQuantity=" + autoAcceptedQuantity +
-                ", partiallyAcceptedAmount=" + partiallyAcceptedAmount +
-                ", partiallyAcceptedOrderFullAmount=" + partiallyAcceptedOrderFullAmount +
-                '}';
-    }
 }
Index: Model/src/main/java/me/exrates/model/dto/OrderValidationDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/OrderValidationDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/OrderValidationDto.java	(revision Shelved Version)
@@ -1,18 +1,19 @@
 package me.exrates.model.dto;
 
-import lombok.Getter;
-import lombok.Setter;
-import lombok.ToString;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
 
 import java.util.HashMap;
 import java.util.Map;
 
-/**
- * Created by OLEG on 10.04.2017.
- */
-@Getter @Setter
-@ToString
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
 public class OrderValidationDto {
-  private Map<String, Object> errors = new HashMap<>();
-  private Map<String, Object[]> errorParams = new HashMap<>();
+
+    private Map<String, Object> errors = new HashMap<>();
+    private Map<String, Object[]> errorParams = new HashMap<>();
 }
Index: Model/src/main/java/me/exrates/model/dto/UserCurrencyOperationPermissionDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/UserCurrencyOperationPermissionDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/UserCurrencyOperationPermissionDto.java	(revision Shelved Version)
@@ -1,20 +1,15 @@
 package me.exrates.model.dto;
 
-import lombok.Getter;
-import lombok.Setter;
-import lombok.ToString;
+import lombok.Data;
 import me.exrates.model.enums.invoice.InvoiceOperationDirection;
 import me.exrates.model.enums.invoice.InvoiceOperationPermission;
 
-/**
- * Created by ValkSam
- */
-@ToString
-@Getter @Setter
+@Data
 public class UserCurrencyOperationPermissionDto {
-  private Integer userId;
-  private Integer currencyId;
-  private String currencyName;
-  private InvoiceOperationDirection invoiceOperationDirection;
-  private InvoiceOperationPermission invoiceOperationPermission;
+
+    private Integer userId;
+    private Integer currencyId;
+    private String currencyName;
+    private InvoiceOperationDirection invoiceOperationDirection;
+    private InvoiceOperationPermission invoiceOperationPermission;
 }
Index: Model/src/main/java/me/exrates/model/dto/WalletsAndCommissionsForOrderCreationDto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/dto/WalletsAndCommissionsForOrderCreationDto.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/dto/WalletsAndCommissionsForOrderCreationDto.java	(revision Shelved Version)
@@ -1,5 +1,10 @@
 package me.exrates.model.dto;
 
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
 import java.math.BigDecimal;
 
 /**
@@ -8,56 +13,16 @@
  * - IDs the wallets -
  * - balances the wallets of participants the order: user-creator, user-acceptor, company
  * - status the order
- *
- * @author ValkSam
  */
+@Data
+@Builder(builderClassName = "Builder", toBuilder = true)
+@NoArgsConstructor
+@AllArgsConstructor
 public class WalletsAndCommissionsForOrderCreationDto {
-    int userId;
-    /**/
-    int spendWalletId;
-    BigDecimal spendWalletActiveBalance;
-    int commissionId;
-    BigDecimal commissionValue;
-
-    /*getters setters*/
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public int getSpendWalletId() {
-        return spendWalletId;
-    }
-
-    public void setSpendWalletId(int spendWalletId) {
-        this.spendWalletId = spendWalletId;
-    }
-
-    public BigDecimal getSpendWalletActiveBalance() {
-        return spendWalletActiveBalance;
-    }
 
-    public void setSpendWalletActiveBalance(BigDecimal spendWalletActiveBalance) {
-        this.spendWalletActiveBalance = spendWalletActiveBalance;
-    }
-
-    public int getCommissionId() {
-        return commissionId;
-    }
-
-    public void setCommissionId(int commissionId) {
-        this.commissionId = commissionId;
-    }
-
-    public BigDecimal getCommissionValue() {
-        return commissionValue;
-    }
-
-    public void setCommissionValue(BigDecimal commissionValue) {
-        this.commissionValue = commissionValue;
-    }
+    private int userId;
+    private int spendWalletId;
+    private BigDecimal spendWalletActiveBalance;
+    private int commissionId;
+    private BigDecimal commissionValue;
 }
Index: Model/src/main/java/me/exrates/model/enums/invoice/InvoiceOperationDirection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/enums/invoice/InvoiceOperationDirection.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/enums/invoice/InvoiceOperationDirection.java	(revision Shelved Version)
@@ -1,16 +1,13 @@
 package me.exrates.model.enums.invoice;
 
+import lombok.Getter;
 import me.exrates.model.exceptions.UnsupportedInvoiceOperationDirectionException;
 
 import java.util.stream.Stream;
 
-import lombok.ToString;
-
-/**
- * Created by OLEG on 28.02.2017.
- */
-@ToString
+@Getter
 public enum InvoiceOperationDirection {
+
     REFILL(1), WITHDRAW(2), TRANSFER_VOUCHER(3);
 
     private int id;
@@ -19,12 +16,10 @@
         this.id = id;
     }
 
-    public int getId() {
-        return id;
-    }
-
     public static InvoiceOperationDirection convert(int id) {
-        return Stream.of(InvoiceOperationDirection.values()).filter(item -> item.id == id).findFirst()
+        return Stream.of(InvoiceOperationDirection.values())
+                .filter(item -> item.id == id)
+                .findFirst()
                 .orElseThrow(() -> new UnsupportedInvoiceOperationDirectionException(String.format("id: %s", id)));
     }
 
Index: Model/src/main/java/me/exrates/model/enums/invoice/InvoiceOperationPermission.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/enums/invoice/InvoiceOperationPermission.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/enums/invoice/InvoiceOperationPermission.java	(revision Shelved Version)
@@ -1,28 +1,24 @@
 package me.exrates.model.enums.invoice;
 
+import lombok.Getter;
 import me.exrates.model.exceptions.UnsupportedOperationPermissionException;
 
 import java.util.stream.Stream;
 
-/**
- * Created by OLEG on 28.02.2017.
- */
+@Getter
 public enum InvoiceOperationPermission {
+
     NONE(0), VIEW_ONLY(1), ACCEPT_DECLINE(2);
 
-    private int code;
+    private int id;
 
-    InvoiceOperationPermission(int code) {
-        this.code = code;
-    }
-
-    public int getCode() {
-        return code;
+    InvoiceOperationPermission(int id) {
+        this.id = id;
     }
 
     public static InvoiceOperationPermission convert(int id) {
-        return Stream.of(InvoiceOperationPermission.class.getEnumConstants())
-                .filter(e -> e.code == id)
+        return Stream.of(InvoiceOperationPermission.values())
+                .filter(value -> value.id == id)
                 .findAny()
                 .orElseThrow(() -> new UnsupportedOperationPermissionException(String.valueOf(id)));
     }
Index: Model/src/main/java/me/exrates/model/enums/OperationType.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/enums/OperationType.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/enums/OperationType.java	(revision Shelved Version)
@@ -1,5 +1,10 @@
 package me.exrates.model.enums;
 
+import com.google.common.collect.Lists;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.Getter;
+import lombok.NoArgsConstructor;
 import me.exrates.model.exceptions.UnsupportedOperationTypeException;
 import org.springframework.context.MessageSource;
 
@@ -8,14 +13,12 @@
 import static me.exrates.model.enums.TransactionSourceType.REFILL;
 import static me.exrates.model.enums.TransactionSourceType.WITHDRAW;
 
+@Getter
 public enum OperationType {
-    INPUT(1, REFILL){{
+
+    INPUT(1, REFILL) {{
         /*Addition of three digits is required for IDR input*/
-        currencyForAddRandomValueToAmount.put(10, new AdditionalRandomAmountParam(){{
-            currencyName = "IDR";
-            lowBound = 100;
-            highBound = 999;
-        }});
+        currencyForAddRandomValueToAmount.put(10, new AdditionalRandomAmountParam("IDR", 100, 999));
     }},
     OUTPUT(2, WITHDRAW),
     SELL(3),
@@ -26,51 +29,26 @@
     MANUAL(8),
     USER_TRANSFER(9);
 
-    public class AdditionalRandomAmountParam {
-        public String currencyName;
-        public double lowBound;
-        public double highBound;
-
-    @Override
-    public boolean equals(Object currencyName) {
-        return this.currencyName.equals((String)currencyName);
-    }
-
-    @Override
-    public int hashCode() {
-        return currencyName != null ? currencyName.hashCode() : 0;
-    }
-}
-
-    public final int type;
-
-    TransactionSourceType transactionSourceType = null;
-
     protected final Map<Integer, AdditionalRandomAmountParam> currencyForAddRandomValueToAmount = new HashMap<>();
 
-    OperationType(int type) {
-        this.type = type;
+    private int code;
+    private TransactionSourceType sourceType;
+
+    OperationType(int code) {
+        this.code = code;
     }
-    OperationType(int type, TransactionSourceType transactionSourceType) {
-        this.type = type;
-        this.transactionSourceType = transactionSourceType;
+
+    OperationType(int code, TransactionSourceType sourceType) {
+        this.code = code;
+        this.sourceType = sourceType;
     }
 
-    public Optional<AdditionalRandomAmountParam> getRandomAmountParam(Integer currencyId){
+    public Optional<AdditionalRandomAmountParam> getRandomAmountParam(Integer currencyId) {
         return Optional.ofNullable(currencyForAddRandomValueToAmount.get(currencyId));
     }
 
-    public Optional<AdditionalRandomAmountParam> getRandomAmountParam(String currencyName){
-        return currencyForAddRandomValueToAmount.values().stream()
-            .filter(e->e.equals(currencyName))
-            .findAny();
-    }
-
-    public static List<OperationType> getInputOutputOperationsList(){
-        return new ArrayList<OperationType>(){{
-            add(INPUT);
-            add(OUTPUT);
-        }};
+    public static List<OperationType> getInputOutputOperationsList() {
+        return Lists.newArrayList(INPUT, OUTPUT);
     }
 
     public static OperationType getOpposite(OperationType ot) {
@@ -88,22 +66,34 @@
         }
     }
 
-    public int getType() {
-        return type;
-    }
-
-    public TransactionSourceType getTransactionSourceType() {
-        return transactionSourceType;
-    }
-
-    public static OperationType convert(int id) {
-        return Arrays.stream(OperationType.class.getEnumConstants())
-            .filter(e -> e.type == id)
-            .findAny()
-            .orElseThrow(() -> new UnsupportedOperationTypeException(id));
+    public static OperationType convert(int code) {
+        return Arrays.stream(OperationType.values())
+                .filter(value -> value.code == code)
+                .findAny()
+                .orElseThrow(() -> new UnsupportedOperationTypeException(code));
     }
 
     public String toString(MessageSource messageSource, Locale locale) {
         return messageSource.getMessage("operationtype." + this.name(), null, locale);
     }
+
+    @Data
+    @NoArgsConstructor
+    @AllArgsConstructor
+    public class AdditionalRandomAmountParam {
+
+        public String currencyName;
+        public double lowBound;
+        public double highBound;
+
+        @Override
+        public boolean equals(Object currencyName) {
+            return this.currencyName.equals(currencyName);
+        }
+
+        @Override
+        public int hashCode() {
+            return currencyName != null ? currencyName.hashCode() : 0;
+        }
+    }
 }
Index: Model/src/main/java/me/exrates/model/enums/OrderType.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/enums/OrderType.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/enums/OrderType.java	(revision Shelved Version)
@@ -1,36 +1,23 @@
 package me.exrates.model.enums;
 
+import lombok.Getter;
 import me.exrates.model.exceptions.UnsupportedOrderTypeException;
 
 import java.math.BigDecimal;
 import java.util.Arrays;
 import java.util.Comparator;
 
-/**
- * Created by OLEG on 06.04.2017.
- */
+@Getter
 public enum OrderType {
+
   SELL(1, OperationType.SELL, Comparator.naturalOrder()),
-
   BUY(2, OperationType.BUY, Comparator.reverseOrder());
   
   private int type;
   private OperationType operationType;
   // needed for sorting orders by rate: DESC for BUY, ASC for SELL
   private Comparator<BigDecimal> benefitRateComparator;
-  
-  public int getType() {
-    return type;
-  }
 
-  public OperationType getOperationType() {
-    return operationType;
-  }
-
-  public Comparator<BigDecimal> getBenefitRateComparator() {
-    return benefitRateComparator;
-  }
-
   OrderType(int type, OperationType operationType, Comparator<BigDecimal> benefitRateComparator) {
     this.type = type;
     this.operationType = operationType;
@@ -38,18 +25,24 @@
   }
 
   public static OrderType convert(int type) {
-    return Arrays.stream(OrderType.values()).filter(ot -> ot.type == type).findAny()
+    return Arrays.stream(OrderType.values())
+            .filter(ot -> ot.type == type)
+            .findAny()
             .orElseThrow(UnsupportedOrderTypeException::new);
   }
   
   public static OrderType convert(String name) {
-    return Arrays.stream(OrderType.values()).filter(ot -> ot.name().equals(name)).findAny()
+    return Arrays.stream(OrderType.values())
+            .filter(ot -> ot.name().equals(name))
+            .findAny()
             .orElseThrow(UnsupportedOrderTypeException::new);
   }
 
   public static OrderType fromOperationType(OperationType operationType) {
-    return Arrays.stream(OrderType.values()).filter(item -> item.operationType == operationType)
-            .findFirst().orElseThrow(() -> new IllegalArgumentException(String.format("Operation type %s not convertible to order type",
+    return Arrays.stream(OrderType.values())
+            .filter(ot -> ot.operationType == operationType)
+            .findFirst()
+            .orElseThrow(() -> new IllegalArgumentException(String.format("Operation type %s not convertible to order type",
                     operationType.name())));
   }
 
Index: Model/src/main/java/me/exrates/model/enums/TransactionSourceType.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/enums/TransactionSourceType.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/enums/TransactionSourceType.java	(revision Shelved Version)
@@ -8,11 +8,9 @@
 import java.util.Arrays;
 import java.util.Locale;
 
-/**
- * Created by Valk on 23.05.2016.
- */
 @Getter
 public enum TransactionSourceType {
+
   ORDER(1),
   REFERRAL(3),
   ACCRUAL(4),
@@ -29,22 +27,21 @@
     this.code = code;
   }
 
-  public static TransactionSourceType convert(int id) {
-    return Arrays.stream(TransactionSourceType.class.getEnumConstants())
-        .filter(e -> e.code == id)
+  public static TransactionSourceType convert(int code) {
+    return Arrays.stream(TransactionSourceType.values())
+        .filter(value -> value.code == code)
         .findAny()
-        .orElseThrow(() -> new UnsupportedTransactionSourceTypeIdException(String.valueOf(id)));
+        .orElseThrow(() -> new UnsupportedTransactionSourceTypeIdException(String.valueOf(code)));
   }
 
   public static TransactionSourceType convert(String name) {
-    return Arrays.stream(TransactionSourceType.class.getEnumConstants())
-        .filter(e -> e.name().equals(name))
+    return Arrays.stream(TransactionSourceType.values())
+        .filter(value -> value.name().equals(name))
         .findAny()
         .orElseThrow(() -> new UnsupportedTransactionSourceTypeNameException(name));
   }
 
   public String toString(MessageSource messageSource, Locale locale) {
     return messageSource.getMessage("transactionsourcetype." + this.name(), null, locale);
-
   }
 }
Index: Model/src/main/java/me/exrates/model/enums/UserCommentTopicEnum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/enums/UserCommentTopicEnum.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/enums/UserCommentTopicEnum.java	(revision Shelved Version)
@@ -1,50 +1,46 @@
 package me.exrates.model.enums;
 
 
+import lombok.Getter;
 import lombok.extern.log4j.Log4j2;
 import me.exrates.model.exceptions.UnsupportedUserCommentTopicIdException;
 import me.exrates.model.exceptions.UnsupportedUserCommentTopicNameException;
 
 import java.util.Arrays;
 
-/**
- * Created by ValkSam
- */
 @Log4j2
+@Getter
 public enum UserCommentTopicEnum {
-  GENERAL(1),
-  REFILL_DECLINE(2),
-  REFILL_CURRENCY_WARNING(3),
-  WITHDRAW_DECLINE(4),
-  WITHDRAW_POSTED(5),
-  WITHDRAW_CURRENCY_WARNING(6),
-  REFILL_ACCEPTED(7),
-  INITIAL_TRANSFER_CURRENCY_WARNING(8),
-  TRANSFER_CURRENCY_WARNING(9),
-  REFILL_MERCHANT_WARNING(10),
-  WITHDRAW_MERCHANT_WARNING(11);
+
+    GENERAL(1),
+    REFILL_DECLINE(2),
+    REFILL_CURRENCY_WARNING(3),
+    WITHDRAW_DECLINE(4),
+    WITHDRAW_POSTED(5),
+    WITHDRAW_CURRENCY_WARNING(6),
+    REFILL_ACCEPTED(7),
+    INITIAL_TRANSFER_CURRENCY_WARNING(8),
+    TRANSFER_CURRENCY_WARNING(9),
+    REFILL_MERCHANT_WARNING(10),
+    WITHDRAW_MERCHANT_WARNING(11);
 
-  private Integer code;
+    private Integer code;
 
-  UserCommentTopicEnum(Integer code) {
-    this.code = code;
-  }
+    UserCommentTopicEnum(Integer code) {
+        this.code = code;
+    }
 
-  public static UserCommentTopicEnum convert(int id) {
-    return Arrays.stream(UserCommentTopicEnum.class.getEnumConstants())
-        .filter(e -> e.code == id)
-        .findAny()
-        .orElseThrow(() -> new UnsupportedUserCommentTopicIdException(String.valueOf(id)));
-  }
+    public static UserCommentTopicEnum convert(int code) {
+        return Arrays.stream(UserCommentTopicEnum.values())
+                .filter(value -> value.code == code)
+                .findAny()
+                .orElseThrow(() -> new UnsupportedUserCommentTopicIdException(String.valueOf(code)));
+    }
 
-  public static UserCommentTopicEnum convert(String name) {
-    return Arrays.stream(UserCommentTopicEnum.class.getEnumConstants())
-        .filter(e -> e.name().equals(name))
-        .findAny()
-        .orElseThrow(() -> new UnsupportedUserCommentTopicNameException(name));
-  }
-
-  public Integer getCode() {
-    return code;
-  }
+    public static UserCommentTopicEnum convert(String name) {
+        return Arrays.stream(UserCommentTopicEnum.values())
+                .filter(value -> value.name().equals(name))
+                .findAny()
+                .orElseThrow(() -> new UnsupportedUserCommentTopicNameException(name));
+    }
 }
Index: Model/src/main/java/me/exrates/model/enums/UserRole.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/enums/UserRole.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/enums/UserRole.java	(revision Shelved Version)
@@ -1,68 +1,57 @@
 package me.exrates.model.enums;
 
-import me.exrates.model.exceptions.UnsupportedUserRoleIdException;
+import lombok.Getter;
 
 import java.util.Arrays;
 
+@Getter
 public enum UserRole implements RealCheckableRole {
 
-  ADMINISTRATOR(1),
-  ACCOUNTANT(2),
-  ADMIN_USER(3),
-  USER(4),
-  ROLE_CHANGE_PASSWORD(5),
-  EXCHANGE(6),
-  VIP_USER(7),
-  TRADER(8),
-  FIN_OPERATOR(9),
-  BOT_TRADER(10, false, false),
-  ICO_MARKET_MAKER(11);
+    ADMINISTRATOR(1),
+    ACCOUNTANT(2),
+    ADMIN_USER(3),
+    USER(4),
+    ROLE_CHANGE_PASSWORD(5),
+    EXCHANGE(6),
+    VIP_USER(7),
+    TRADER(8),
+    FIN_OPERATOR(9),
+    BOT_TRADER(10, false, false),
+    ICO_MARKET_MAKER(11);
 
-  private final int role;
+    private int code;
+    private boolean showExtendedOrderInfo;
+    private boolean isReal;
 
-  private final boolean showExtendedOrderInfo;
+    UserRole(int code) {
+        this(code, true, true);
+    }
 
-  private final boolean isReal;
-
-  UserRole(int role, boolean showExtendedOrderInfo, boolean isReal) {
-    this.role = role;
-    this.showExtendedOrderInfo = showExtendedOrderInfo;
-    this.isReal = isReal;
-  }
+    UserRole(int code, boolean showExtendedOrderInfo, boolean isReal) {
+        this.code = code;
+        this.showExtendedOrderInfo = showExtendedOrderInfo;
+        this.isReal = isReal;
+    }
 
-  UserRole(int role) {
-    this(role, true, true);
-  }
-
-  public int getRole() {
-    return role;
-  }
-
-  public boolean showExtendedOrderInfo() {
-    return showExtendedOrderInfo;
-  }
-
-  public static UserRole convert(int id) {
-    return Arrays.stream(UserRole.class.getEnumConstants())
-        .filter(e -> e.role == id)
-        .findAny().orElse(USER)
-        /*.orElseThrow(() -> new UnsupportedUserRoleIdException(String.valueOf(id)))*/;
-  }
-
-
-
-  @Override
-  public String toString() {
-    return this.name();
-  }
+    public static UserRole convert(int code) {
+        return Arrays.stream(UserRole.values())
+                .filter(role -> role.code == code)
+                .findAny()
+                .orElse(USER);
+    }
 
-  @Override
-  public boolean isReal() {
-    return isReal;
-  }
+    @Override
+    public boolean isReal() {
+        return isReal;
+    }
 
-  @Override
-  public String getName() {
-    return this.name();
-  }
+    @Override
+    public String getName() {
+        return this.name();
+    }
+
+    @Override
+    public String toString() {
+        return this.name();
+    }
 }
\ No newline at end of file
Index: Model/src/main/java/me/exrates/model/serializer/BigDecimalToDoubleSerializer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/serializer/BigDecimalToDoubleSerializer.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/serializer/BigDecimalToDoubleSerializer.java	(revision Shelved Version)
@@ -1,7 +1,6 @@
 package me.exrates.model.serializer;
 
 import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.JsonSerializer;
 import com.fasterxml.jackson.databind.SerializerProvider;
 
@@ -9,8 +8,9 @@
 import java.math.BigDecimal;
 
 public class BigDecimalToDoubleSerializer extends JsonSerializer<BigDecimal> {
+
     @Override
-    public void serialize(BigDecimal bigDecimal, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException, JsonProcessingException {
+    public void serialize(BigDecimal bigDecimal, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
         jsonGenerator.writeNumber(bigDecimal.doubleValue());
     }
 }
Index: Model/src/main/java/me/exrates/model/CurrencyPair.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/CurrencyPair.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/CurrencyPair.java	(revision Shelved Version)
@@ -1,10 +1,15 @@
 package me.exrates.model;
 
+import lombok.Data;
+import lombok.NoArgsConstructor;
 import me.exrates.model.enums.CurrencyPairType;
 import org.springframework.stereotype.Component;
 
 @Component
+@Data
+@NoArgsConstructor
 public class CurrencyPair {
+
     private int id;
     private String name;
     private Currency currency1;
@@ -13,20 +18,11 @@
     private String marketName;
     private CurrencyPairType pairType;
 
-    /*constructors*/
-    public CurrencyPair() {
-    }
-
     public CurrencyPair(Currency currency1, Currency currency2) {
         this.currency1 = currency1;
         this.currency2 = currency2;
     }
 
-    /*service methods*/
-    public Currency getAnotherCurrency(Currency currency) {
-        return currency.equals(currency1) ? currency2 : currency1;
-    }
-
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
@@ -46,74 +42,4 @@
         result = 31 * result + (name != null ? name.hashCode() : 0);
         return result;
     }
-
-    @Override
-    public String toString() {
-        return "CurrencyPair{" +
-                "id=" + id +
-                ", name='" + name + '\'' +
-                ", currency1=" + currency1 +
-                ", currency2=" + currency2 +
-                ", market='" + market + '\'' +
-                ", marketName='" + marketName + '\'' +
-                ", pairType=" + pairType +
-                '}';
-    }
-
-    /*getters setters*/
-    public int getId() {
-        return id;
-    }
-
-    public void setId(int id) {
-        this.id = id;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public Currency getCurrency1() {
-        return currency1;
-    }
-
-    public void setCurrency1(Currency currency1) {
-        this.currency1 = currency1;
-    }
-
-    public Currency getCurrency2() {
-        return currency2;
-    }
-
-    public void setCurrency2(Currency currency2) {
-        this.currency2 = currency2;
-    }
-
-    public String getMarket() {
-        return market;
-    }
-
-    public void setMarket(String market) {
-        this.market = market;
-    }
-
-    public String getMarketName() {
-        return marketName;
-    }
-
-    public void setMarketName(String marketName) {
-        this.marketName = marketName;
-    }
-
-    public CurrencyPairType getPairType() {
-        return pairType;
-    }
-
-    public void setPairType(CurrencyPairType pairType) {
-        this.pairType = pairType;
-    }
 }
Index: Model/src/main/java/me/exrates/model/ExOrder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Model/src/main/java/me/exrates/model/ExOrder.java	(revision Local Version)
+++ Model/src/main/java/me/exrates/model/ExOrder.java	(revision Shelved Version)
@@ -47,8 +47,8 @@
         this.exRate = orderCreateDto.getExchangeRate();
         this.amountBase = orderCreateDto.getAmount();
         this.amountConvert = orderCreateDto.getTotal();
-        this.comissionId = orderCreateDto.getComissionId();
-        this.commissionFixedAmount = orderCreateDto.getComission();
+        this.comissionId = orderCreateDto.getCommissionId();
+        this.commissionFixedAmount = orderCreateDto.getCommission();
         this.status = orderCreateDto.getStatus();
         this.currencyPair = orderCreateDto.getCurrencyPair();
         this.sourceId = orderCreateDto.getSourceId();
Index: Service/src/main/java/me/exrates/service/converters/BigDecimalConverter.java
===================================================================
--- Service/src/main/java/me/exrates/service/converters/BigDecimalConverter.java	(revision Shelved Version)
+++ Service/src/main/java/me/exrates/service/converters/BigDecimalConverter.java	(revision Shelved Version)
@@ -0,0 +1,39 @@
+package me.exrates.service.converters;
+
+import com.google.common.collect.Sets;
+import me.exrates.model.enums.OperationType;
+
+import java.math.BigDecimal;
+import java.util.Set;
+
+import static java.math.BigDecimal.ROUND_HALF_UP;
+
+public final class BigDecimalConverter {
+
+    private static final String EDRC = "EDRC";
+    private static final String BTC = "BTC";
+    private static final String LTC = "LTC";
+    private static final String EDR = "EDR";
+    private static final String ETH = "ETH";
+    private static final String ETC = "ETC";
+    private static final String DASH = "DASH";
+
+    private static final Set<String> CRYPTO = Sets.newHashSet(EDRC, BTC, LTC, EDR, ETH, ETC, DASH);
+
+    private static final int CRYPTO_PRECISION = 8;
+    private static final int DEFAULT_PRECISION = 2;
+    private static final int EDC_OUTPUT_PRECISION = 3;
+
+    public static String convertToString(final BigDecimal amount, final String currency) {
+        return amount.setScale(resolvePrecision(currency), ROUND_HALF_UP).toPlainString();
+    }
+
+    public static int resolvePrecisionByOperationType(final String currency, OperationType operationType) {
+        return currency.equals(EDR)
+                && (operationType == OperationType.OUTPUT) ? EDC_OUTPUT_PRECISION : resolvePrecision(currency);
+    }
+
+    private static int resolvePrecision(final String currency) {
+        return CRYPTO.contains(currency) ? CRYPTO_PRECISION : DEFAULT_PRECISION;
+    }
+}
Index: Service/src/main/java/me/exrates/service/exception/api/ErrorCode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/exception/api/ErrorCode.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/exception/api/ErrorCode.java	(revision Shelved Version)
@@ -1,16 +1,52 @@
 package me.exrates.service.exception.api;
 
-/**
- * Created by OLEG on 08.09.2016.
- */
 public enum ErrorCode {
-    REQUEST_NOT_READABLE, INVALID_PARAM_VALUE, EXISTING_NICKNAME, EXISTING_EMAIL, INTERNAL_SERVER_ERROR,
-    EMAIL_NOT_EXISTS, ACCOUNT_DISABLED, ACCOUNT_NOT_CONFIRMED, INCORRECT_LOGIN_OR_PASSWORD, MISSING_CREDENTIALS, MISSING_AUTHENTICATION_TOKEN,
-    INVALID_AUTHENTICATION_TOKEN, EXPIRED_AUTHENTICATION_TOKEN, TOKEN_NOT_FOUND, FAILED_AUTHENTICATION, MISSING_REQUIRED_PARAM,
-    CURRENCY_PAIR_NOT_FOUND, ORDER_KEY_NOT_FOUND, INSUFFICIENT_FUNDS, WALLET_NOT_FOUND, CAUSED_NEGATIVE_BALANCE,
-    WALLET_UPDATE_ERROR, TRANSACTION_CREATION_ERROR, ORDER_NOT_FOUND, ALREADY_ACCEPTED_ORDER, INVALID_PAYMENT_AMOUNT,
-    INVALID_FILE, INVALID_APP_KEY, ABSENT_FIN_PASSWORD, UNCONFIRMED_FIN_PASSWORD, INCORRECT_FIN_PASSWORD, LANGUAGE_NOT_SUPPORTED,
-    INVALID_SESSION_ID, INVOICE_NOT_FOUND, USER_NOT_FOUND, SELF_TRANSFER_NOT_ALLOWED, BAD_INVOICE_STATUS, INPUT_REQUEST_LIMIT_EXCEEDED,
-    BLOCKED_CURRENCY_FOR_MERCHANT, OUTPUT_REQUEST_LIMIT_EXCEEDED, VOUCHER_NOT_FOUND, COMMISSION_EXCEEDS_AMOUNT, INVALID_NICKNAME, BANNED_IP,
-    INVALID_CURRENCY_PAIR_FORMAT, ACCESS_DENIED;
+
+    REQUEST_NOT_READABLE,
+    INVALID_PARAM_VALUE,
+    EXISTING_NICKNAME,
+    EXISTING_EMAIL,
+    INTERNAL_SERVER_ERROR,
+    EMAIL_NOT_EXISTS,
+    ACCOUNT_DISABLED,
+    ACCOUNT_NOT_CONFIRMED,
+    INCORRECT_LOGIN_OR_PASSWORD,
+    MISSING_CREDENTIALS,
+    MISSING_AUTHENTICATION_TOKEN,
+    INVALID_AUTHENTICATION_TOKEN,
+    EXPIRED_AUTHENTICATION_TOKEN,
+    TOKEN_NOT_FOUND,
+    FAILED_AUTHENTICATION,
+    MISSING_REQUIRED_PARAM,
+    CURRENCY_PAIR_NOT_FOUND,
+    ORDER_KEY_NOT_FOUND,
+    INSUFFICIENT_FUNDS,
+    WALLET_NOT_FOUND,
+    CAUSED_NEGATIVE_BALANCE,
+    WALLET_UPDATE_ERROR,
+    TRANSACTION_CREATION_ERROR,
+    ORDER_NOT_FOUND,
+    ALREADY_ACCEPTED_ORDER,
+    INVALID_PAYMENT_AMOUNT,
+    INVALID_FILE,
+    INVALID_APP_KEY,
+    ABSENT_FIN_PASSWORD,
+    UNCONFIRMED_FIN_PASSWORD,
+    INCORRECT_FIN_PASSWORD,
+    LANGUAGE_NOT_SUPPORTED,
+    INVALID_SESSION_ID,
+    INVOICE_NOT_FOUND,
+    USER_NOT_FOUND,
+    SELF_TRANSFER_NOT_ALLOWED,
+    BAD_INVOICE_STATUS,
+    INPUT_REQUEST_LIMIT_EXCEEDED,
+    BLOCKED_CURRENCY_FOR_MERCHANT,
+    OUTPUT_REQUEST_LIMIT_EXCEEDED,
+    VOUCHER_NOT_FOUND,
+    COMMISSION_EXCEEDS_AMOUNT,
+    INVALID_NICKNAME, BANNED_IP,
+    INVALID_CURRENCY_PAIR_FORMAT,
+    ACCESS_DENIED,
+    UNPROCESSABLE_ENTITY,
+    REQUEST_NOT_SUPPORTED
 }
Index: Service/src/main/java/me/exrates/service/exception/api/OpenApiError.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/exception/api/OpenApiError.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/exception/api/OpenApiError.java	(revision Shelved Version)
@@ -4,29 +4,31 @@
 import lombok.ToString;
 import org.apache.commons.lang.exception.ExceptionUtils;
 
+import static java.util.Objects.isNull;
+
 @Getter
 @ToString
 public class OpenApiError {
+
     private final ErrorCode errorCode;
     private final String url;
     public final String detail;
 
-
-    public OpenApiError(ErrorCode errorCode, CharSequence url, Exception ex) {
+    public OpenApiError(ErrorCode errorCode, String url, Exception ex) {
         this.errorCode = errorCode;
-        this.url = url.toString();
+        this.url = url;
         String detail = ex.getLocalizedMessage();
         Throwable rootCause = ExceptionUtils.getRootCause(ex);
-        if (rootCause == null || rootCause.getLocalizedMessage() == null) {
+        if (isNull(rootCause) || isNull(rootCause.getLocalizedMessage())) {
             this.detail = detail;
         } else {
             this.detail = rootCause.getLocalizedMessage();
         }
     }
 
-    public OpenApiError(ErrorCode errorCode, CharSequence url, String detail) {
+    public OpenApiError(ErrorCode errorCode, String url, String detail) {
         this.errorCode = errorCode;
-        this.url = url.toString();
+        this.url = url;
         this.detail = detail;
     }
 }
Index: Service/src/main/java/me/exrates/service/exception/api/ValidationOpenApiError.java
===================================================================
--- Service/src/main/java/me/exrates/service/exception/api/ValidationOpenApiError.java	(revision Shelved Version)
+++ Service/src/main/java/me/exrates/service/exception/api/ValidationOpenApiError.java	(revision Shelved Version)
@@ -0,0 +1,23 @@
+package me.exrates.service.exception.api;
+
+import lombok.Getter;
+import lombok.ToString;
+
+import java.util.List;
+
+@Getter
+@ToString(callSuper = true)
+public class ValidationOpenApiError extends OpenApiError {
+
+    private List<String> errors;
+
+    public ValidationOpenApiError(ErrorCode errorCode, String url, Exception ex, List<String> errors) {
+        super(errorCode, url, ex);
+        this.errors = errors;
+    }
+
+    public ValidationOpenApiError(ErrorCode errorCode, String url, String detail, List<String> errors) {
+        super(errorCode, url, detail);
+        this.errors = errors;
+    }
+}
Index: Service/src/main/java/me/exrates/service/impl/BotServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/impl/BotServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/impl/BotServiceImpl.java	(revision Shelved Version)
@@ -1,6 +1,5 @@
 package me.exrates.service.impl;
 
-import lombok.Synchronized;
 import lombok.extern.log4j.Log4j2;
 import me.exrates.dao.BotDao;
 import me.exrates.model.*;
@@ -8,7 +7,6 @@
 import me.exrates.model.dto.OrderCreateDto;
 import me.exrates.model.enums.*;
 import me.exrates.service.*;
-import me.exrates.service.events.CreateOrderEvent;
 import me.exrates.service.exception.BotException;
 import me.exrates.service.exception.InsufficientCostsForAcceptionException;
 import me.exrates.service.exception.OrderAcceptionException;
@@ -21,7 +19,6 @@
 import org.springframework.context.annotation.PropertySource;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;
-import org.springframework.transaction.event.TransactionalEventListener;
 
 import javax.annotation.PostConstruct;
 import javax.annotation.PreDestroy;
@@ -132,7 +129,7 @@
 
     private boolean checkNeedToAccept(ExOrder exOrder) {
         UserRoleSettings userRoleSettings = userRoleService.retrieveSettingsForRole(
-                userService.getUserRoleFromDB(exOrder.getUserId()).getRole());
+                userService.getUserRoleFromDB(exOrder.getUserId()).getCode());
 
         return exOrder.getOrderBaseType() == OrderBaseType.LIMIT && userRoleSettings.isBotAcceptionAllowedOnly();
 
Index: Service/src/main/java/me/exrates/service/impl/CurrencyServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/impl/CurrencyServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/impl/CurrencyServiceImpl.java	(revision Shelved Version)
@@ -10,294 +10,324 @@
 import me.exrates.model.dto.mobileApiDto.TransferLimitDto;
 import me.exrates.model.dto.mobileApiDto.dashboard.CurrencyPairWithLimitsDto;
 import me.exrates.model.dto.openAPI.CurrencyPairInfoItem;
-import me.exrates.model.enums.*;
+import me.exrates.model.enums.CurrencyPairType;
+import me.exrates.model.enums.MerchantProcessType;
+import me.exrates.model.enums.OperationType;
+import me.exrates.model.enums.OrderType;
+import me.exrates.model.enums.UserCommentTopicEnum;
+import me.exrates.model.enums.UserRole;
 import me.exrates.model.enums.invoice.InvoiceOperationDirection;
 import me.exrates.service.CurrencyService;
 import me.exrates.service.UserRoleService;
 import me.exrates.service.UserService;
 import me.exrates.service.exception.CurrencyPairNotFoundException;
 import me.exrates.service.exception.ScaleForAmountNotSetException;
-import org.apache.log4j.LogManager;
-import org.apache.log4j.Logger;
-import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.dao.EmptyResultDataAccessException;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;
 
 import java.math.BigDecimal;
-import java.util.*;
-import java.util.stream.Collectors;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
 
-import static java.math.BigDecimal.ROUND_HALF_UP;
+import static java.util.stream.Collectors.toList;
+import static java.util.stream.Collectors.toSet;
 
-/**
- * @author Denis Savin (pilgrimm333@gmail.com)
- */
 @Service
 public class CurrencyServiceImpl implements CurrencyService {
 
-  @Autowired
-  private CurrencyDao currencyDao;
-
-  @Autowired
-  private UserService userService;
+    private final CurrencyDao currencyDao;
+    private final UserService userService;
+    private final UserRoleService userRoleService;
 
-  @Autowired
-  UserRoleService userRoleService;
-
-    private static final Logger logger = LogManager.getLogger(CurrencyServiceImpl.class);
-    private static final Set<String> CRYPTO = new HashSet<String>() {
-        {
-            add("EDRC");
-            add("BTC");
-            add("LTC");
-            add("EDR");
-            add("ETH");
-            add("ETC");
-            add("DASH");
-        }
-    };
-    private static final int CRYPTO_PRECISION = 8;
-    private static final int DEFAULT_PRECISION = 2;
-    private static final int EDC_OUTPUT_PRECISION = 3;
+    public CurrencyServiceImpl(CurrencyDao currencyDao,
+                               UserService userService,
+                               UserRoleService userRoleService) {
+        this.currencyDao = currencyDao;
+        this.userService = userService;
+        this.userRoleService = userRoleService;
+    }
 
-  @Override
-  @Transactional(readOnly = true)
-  public String getCurrencyName(int currencyId) {
-    return currencyDao.getCurrencyName(currencyId);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public String getCurrencyName(int currencyId) {
+        return currencyDao.getCurrencyName(currencyId);
+    }
 
-  @Override
-  public List<Currency> getAllCurrencies() {
-    return currencyDao.getCurrList();
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<Currency> getAllCurrencies() {
+        return currencyDao.getCurrencyList();
+    }
 
-  @Override
-  public Currency findByName(String name) {
-    return currencyDao.findByName(name);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public Currency findByName(String name) {
+        return currencyDao.findByName(name);
+    }
 
-  @Override
-  public Currency findById(int id) {
-    return currencyDao.findById(id);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public Currency findById(int id) {
+        return currencyDao.findById(id);
+    }
 
-  @Override
-  public List<Currency> findAllCurrencies() {
-    return currencyDao.findAllCurrencies();
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<Currency> findAllCurrencies() {
+        return currencyDao.findAllCurrencies();
+    }
 
-  @Override
-  public void updateCurrencyLimit(int currencyId, OperationType operationType, String roleName, BigDecimal minAmount, Integer maxDailyRequest) {
-    currencyDao.updateCurrencyLimit(currencyId, operationType, userRoleService.getRealUserRoleIdByBusinessRoleList(roleName), minAmount, maxDailyRequest);
-  }
+    @Override
+    @Transactional
+    public void updateCurrencyLimit(int currencyId,
+                                    OperationType operationType,
+                                    String roleName,
+                                    BigDecimal minAmount,
+                                    Integer maxDailyRequest) {
+        currencyDao.updateCurrencyLimit(currencyId, operationType, userRoleService.getRealUserRoleIdByBusinessRoleList(roleName), minAmount, maxDailyRequest);
+    }
 
-  @Override
-  public List<CurrencyLimit> retrieveCurrencyLimitsForRole(String roleName, OperationType operationType) {
-    return currencyDao.retrieveCurrencyLimitsForRoles(userRoleService.getRealUserRoleIdByBusinessRoleList(roleName), operationType);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<CurrencyLimit> getCurrencyLimitsForRole(String roleName,
+                                                        OperationType operationType) {
+        return currencyDao.getCurrencyLimitsForRoles(userRoleService.getRealUserRoleIdByBusinessRoleList(roleName), operationType);
+    }
 
-  @Override
-  public BigDecimal retrieveMinLimitForRoleAndCurrency(UserRole userRole, OperationType operationType, Integer currencyId) {
-    return currencyDao.retrieveMinLimitForRoleAndCurrency(userRole, operationType, currencyId);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public BigDecimal getMinLimitForRoleAndCurrency(UserRole userRole,
+                                                    OperationType operationType,
+                                                    Integer currencyId) {
+        return currencyDao.getMinLimitForRoleAndCurrency(userRole, operationType, currencyId);
+    }
 
-  @Override
-  public List<CurrencyPair> getAllCurrencyPairs(CurrencyPairType type) {
-    return currencyDao.getAllCurrencyPairs(type);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<CurrencyPair> getAllCurrencyPairs(CurrencyPairType type) {
+        return currencyDao.getAllCurrencyPairs(type);
+    }
 
-  @Override
-  public List<CurrencyPair> getAllCurrencyPairsInAlphabeticOrder(CurrencyPairType type) {
-    List<CurrencyPair> result = currencyDao.getAllCurrencyPairs(type);
-    result.sort(Comparator.comparing(CurrencyPair::getName));
-    return result;
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<CurrencyPair> getAllCurrencyPairsInAlphabeticOrder(CurrencyPairType type) {
+        return currencyDao.getAllCurrencyPairs(type).stream()
+                .sorted(Comparator.comparing(CurrencyPair::getName))
+                .collect(toList());
+    }
 
-  @Override
-  public CurrencyPair findCurrencyPairById(int currencyPairId) {
-    try {
-      return currencyDao.findCurrencyPairById(currencyPairId);
-    } catch (EmptyResultDataAccessException e) {
-      throw new CurrencyPairNotFoundException("Currency pair not found");
-    }
-  }
-
-  @Override
-  public String amountToString(final BigDecimal amount, final String currency) {
-    return amount.setScale(resolvePrecision(currency), ROUND_HALF_UP)
-//                .stripTrailingZeros()
-        .toPlainString();
-  }
-
-  @Override
-  public int resolvePrecision(final String currency) {
-    return CRYPTO.contains(currency) ? CRYPTO_PRECISION : DEFAULT_PRECISION;
-  }
-
-    @Override
-    public int resolvePrecisionByOperationType(final String currency, OperationType operationType) {
-
-        return currency.equals(currencyDao.findByName("EDR").getName()) && (operationType == OperationType.OUTPUT) ?
-                EDC_OUTPUT_PRECISION :
-                CRYPTO.contains(currency) ? CRYPTO_PRECISION :
-                DEFAULT_PRECISION;
+    @Override
+    @Transactional(readOnly = true)
+    public CurrencyPair findCurrencyPairById(int currencyPairId) {
+        try {
+            return currencyDao.findCurrencyPairById(currencyPairId);
+        } catch (EmptyResultDataAccessException ex) {
+            throw new CurrencyPairNotFoundException("Currency pair not found", ex);
+        }
     }
 
     @Override
-    public List<TransferLimitDto> retrieveMinTransferLimits(List<Integer> currencyIds) {
-        Integer roleId = userService.getUserRoleFromSecurityContext().getRole();
+    @Transactional(readOnly = true)
+    public List<TransferLimitDto> getMinTransferLimits(List<Integer> currencyIds) {
+        final Integer roleId = userService.getUserRoleFromSecurityContext().getCode();
+
         return currencyDao.retrieveMinTransferLimits(currencyIds, roleId);
     }
 
-  @Override
-  @Transactional(readOnly = true)
-  public List<UserCurrencyOperationPermissionDto> findWithOperationPermissionByUserAndDirection(Integer userId, InvoiceOperationDirection operationDirection) {
-    return currencyDao.findCurrencyOperationPermittedByUserAndDirection(userId, operationDirection.name());
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<UserCurrencyOperationPermissionDto> findWithOperationPermissionByUserAndDirection(Integer userId,
+                                                                                                  InvoiceOperationDirection operationDirection) {
+        return currencyDao.findCurrencyOperationPermittedByUserAndDirection(userId, operationDirection.name());
+    }
 
-  @Override
-  @Transactional(readOnly = true)
-  public List<UserCurrencyOperationPermissionDto> getCurrencyOperationPermittedForRefill(String userEmail) {
-    return getCurrencyOperationPermittedList(userEmail, InvoiceOperationDirection.REFILL);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<UserCurrencyOperationPermissionDto> getCurrencyOperationPermittedForRefill(String userEmail) {
+        return getCurrencyOperationPermittedList(userEmail, InvoiceOperationDirection.REFILL);
+    }
 
-  @Override
-  @Transactional(readOnly = true)
-  public List<UserCurrencyOperationPermissionDto> getCurrencyOperationPermittedForWithdraw(String userEmail) {
-    return getCurrencyOperationPermittedList(userEmail, InvoiceOperationDirection.WITHDRAW);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<UserCurrencyOperationPermissionDto> getCurrencyOperationPermittedForWithdraw(String userEmail) {
+        return getCurrencyOperationPermittedList(userEmail, InvoiceOperationDirection.WITHDRAW);
+    }
 
-  @Override
-  @Transactional(readOnly = true)
-  public Set<String> getCurrencyPermittedNameList(String userEmail) {
-    Integer userId = userService.getIdByEmail(userEmail);
-    return getCurrencyPermittedNameList(userId);
-  }
+    private List<UserCurrencyOperationPermissionDto> getCurrencyOperationPermittedList(String userEmail,
+                                                                                       InvoiceOperationDirection direction) {
+        final Integer userId = userService.getIdByEmail(userEmail);
+
+        return findWithOperationPermissionByUserAndDirection(userId, direction);
+    }
+
+    @Override
+    @Transactional(readOnly = true)
+    public Set<String> getCurrencyPermittedNameList(String userEmail) {
+        final Integer userId = userService.getIdByEmail(userEmail);
+
+        return getCurrencyPermittedNameList(userId);
+    }
 
-  @Override
-  @Transactional(readOnly = true)
-  public List<UserCurrencyOperationPermissionDto> getCurrencyPermittedOperationList(Integer userId) {
-    return currencyDao.findCurrencyOperationPermittedByUserList(userId);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<UserCurrencyOperationPermissionDto> getCurrencyPermittedOperationList(Integer userId) {
+        return currencyDao.findCurrencyOperationPermittedByUserList(userId);
+    }
 
-  @Override
-  @Transactional(readOnly = true)
-  public Set<String> getCurrencyPermittedNameList(Integer userId) {
-    return currencyDao.findCurrencyOperationPermittedByUserList(userId).stream()
-        .map(e -> e.getCurrencyName())
-        .collect(Collectors.toSet());
-  }
-
-  private List<UserCurrencyOperationPermissionDto> getCurrencyOperationPermittedList(String userEmail, InvoiceOperationDirection direction) {
-    Integer userId = userService.getIdByEmail(userEmail);
-    return findWithOperationPermissionByUserAndDirection(userId, direction);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public Set<String> getCurrencyPermittedNameList(Integer userId) {
+        return currencyDao.findCurrencyOperationPermittedByUserList(userId).stream()
+                .map(UserCurrencyOperationPermissionDto::getCurrencyName)
+                .collect(toSet());
+    }
 
-  @Override
-  public List<String> getWarningForCurrency(Integer currencyId, UserCommentTopicEnum currencyWarningTopicEnum) {
-    return currencyDao.getWarningForCurrency(currencyId, currencyWarningTopicEnum);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<String> getWarningForCurrency(Integer currencyId,
+                                              UserCommentTopicEnum currencyWarningTopicEnum) {
+        return currencyDao.getWarningForCurrency(currencyId, currencyWarningTopicEnum);
+    }
 
-  @Override
-  public List<String> getWarningsByTopic(UserCommentTopicEnum currencyWarningTopicEnum) {
-    return currencyDao.getWarningsByTopic(currencyWarningTopicEnum);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<String> getWarningsByTopic(UserCommentTopicEnum currencyWarningTopicEnum) {
+        return currencyDao.getWarningsByTopic(currencyWarningTopicEnum);
+    }
 
-  @Override
-  public List<String> getWarningForMerchant(Integer merchantId, UserCommentTopicEnum currencyWarningTopicEnum) {
-    return currencyDao.getWarningForMerchant(merchantId, currencyWarningTopicEnum);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<String> getWarningForMerchant(Integer merchantId,
+                                              UserCommentTopicEnum currencyWarningTopicEnum) {
+        return currencyDao.getWarningForMerchant(merchantId, currencyWarningTopicEnum);
+    }
 
-  @Override
-  @Transactional(readOnly = true)
-  public Currency getById(int id) {
-    return currencyDao.findById(id);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public Currency getById(int id) {
+        return currencyDao.findById(id);
+    }
 
-  @Override
-  public CurrencyPairLimitDto findLimitForRoleByCurrencyPairAndType(Integer currencyPairId, OperationType operationType) {
-    UserRole userRole = userService.getUserRoleFromSecurityContext();
-    OrderType orderType = OrderType.convert(operationType.name());
-    return currencyDao.findCurrencyPairLimitForRoleByPairAndType(currencyPairId, userRole.getRole(), orderType.getType());
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public CurrencyPairLimitDto findLimitForRoleByCurrencyPairAndType(Integer currencyPairId,
+                                                                      OperationType operationType) {
+        final UserRole userRole = userService.getUserRoleFromSecurityContext();
+        final OrderType orderType = OrderType.convert(operationType.name());
+
+        return currencyDao.findCurrencyPairLimitForRoleByPairAndType(currencyPairId, userRole.getCode(), orderType.getType());
+    }
 
-  @Override
-  public List<CurrencyPairLimitDto> findAllCurrencyLimitsForRoleAndType(String roleName, OrderType orderType) {
-    return currencyDao.findLimitsForRolesByType(userRoleService.getRealUserRoleIdByBusinessRoleList(roleName), orderType.getType());
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<CurrencyPairLimitDto> findAllCurrencyLimitsForRoleAndType(String roleName,
+                                                                          OrderType orderType) {
+        final List<Integer> roleCodes = userRoleService.getRealUserRoleIdByBusinessRoleList(roleName);
+
+        return currencyDao.findLimitsForRolesByType(roleCodes, orderType.getType());
+    }
 
-  @Override
-  public void updateCurrencyPairLimit(Integer currencyPairId, OrderType orderType, String roleName, BigDecimal minRate, BigDecimal maxRate, BigDecimal minAmount, BigDecimal maxAmount) {
-    currencyDao.setCurrencyPairLimit(currencyPairId, userRoleService.getRealUserRoleIdByBusinessRoleList(roleName), orderType.getType(), minRate,
-            maxRate, minAmount, maxAmount);
-  }
+    @Override
+    @Transactional
+    public void updateCurrencyPairLimit(Integer currencyPairId,
+                                        OrderType orderType,
+                                        String roleName,
+                                        BigDecimal minRate,
+                                        BigDecimal maxRate,
+                                        BigDecimal minAmount,
+                                        BigDecimal maxAmount) {
+        final List<Integer> roleCodes = userRoleService.getRealUserRoleIdByBusinessRoleList(roleName);
+
+        currencyDao.setCurrencyPairLimit(currencyPairId,
+                roleCodes,
+                orderType.getType(),
+                minRate,
+                maxRate,
+                minAmount,
+                maxAmount);
+    }
 
-  @Override
-  public List<CurrencyPairWithLimitsDto> findCurrencyPairsWithLimitsForUser() {
-    Integer userRoleId = userService.getUserRoleFromSecurityContext().getRole();
-    return currencyDao.findAllCurrencyPairsWithLimits(userRoleId);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<CurrencyPairWithLimitsDto> findCurrencyPairsWithLimitsForUser() {
+        final Integer userRoleId = userService.getUserRoleFromSecurityContext().getCode();
+
+        return currencyDao.findAllCurrencyPairsWithLimits(userRoleId);
+    }
 
-  @Override
-  public List<Currency> findAllCurrenciesWithHidden() {
-    return currencyDao.findAllCurrenciesWithHidden();
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<Currency> findAllCurrenciesWithHidden() {
+        return currencyDao.findAllCurrenciesWithHidden();
+    }
 
-  @Override
-  public BigDecimal computeRandomizedAddition(Integer currencyId, OperationType operationType) {
-    Optional<OperationType.AdditionalRandomAmountParam> randomAmountParam = operationType.getRandomAmountParam(currencyId);
-    if (!randomAmountParam.isPresent()) {
-      return BigDecimal.ZERO;
-    } else {
-      OperationType.AdditionalRandomAmountParam param = randomAmountParam.get();
-      return BigDecimal.valueOf(Math.random() * (param.highBound - param.lowBound) + param.lowBound).setScale(0, BigDecimal.ROUND_DOWN);
-    }
-  }
+    @Override
+    public BigDecimal computeRandomizedAddition(Integer currencyId,
+                                                OperationType operationType) {
+        Optional<OperationType.AdditionalRandomAmountParam> randomAmountParam = operationType.getRandomAmountParam(currencyId);
+        if (!randomAmountParam.isPresent()) {
+            return BigDecimal.ZERO;
+        } else {
+            OperationType.AdditionalRandomAmountParam param = randomAmountParam.get();
+            return BigDecimal.valueOf(Math.random() * (param.highBound - param.lowBound) + param.lowBound).setScale(0, BigDecimal.ROUND_DOWN);
+        }
+    }
 
-  @Override
-  public boolean isIco(Integer currencyId) {
-    return currencyDao.isCurrencyIco(currencyId);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public boolean isIco(Integer currencyId) {
+        return currencyDao.isCurrencyIco(currencyId);
+    }
 
-  @Override
-  @Transactional
-  public MerchantCurrencyScaleDto getCurrencyScaleByCurrencyId(Integer currencyId) {
-    MerchantCurrencyScaleDto result = currencyDao.findCurrencyScaleByCurrencyId(currencyId);
-    Optional.ofNullable(result.getScaleForRefill()).orElseThrow(() -> new ScaleForAmountNotSetException("currency: " + currencyId));
-    Optional.ofNullable(result.getScaleForWithdraw()).orElseThrow(() -> new ScaleForAmountNotSetException("currency: " + currencyId));
-    return result;
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public MerchantCurrencyScaleDto getCurrencyScaleByCurrencyId(Integer currencyId) {
+        final MerchantCurrencyScaleDto result = currencyDao.findCurrencyScaleByCurrencyId(currencyId);
+
+        Optional.ofNullable(result.getScaleForRefill())
+                .orElseThrow(() -> new ScaleForAmountNotSetException("currency: " + currencyId));
+        Optional.ofNullable(result.getScaleForWithdraw())
+                .orElseThrow(() -> new ScaleForAmountNotSetException("currency: " + currencyId));
+        return result;
+    }
 
-  @Override
-  public CurrencyPair getCurrencyPairByName(String pairName) {
-    return currencyDao.findCurrencyPairByName(pairName);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public CurrencyPair getCurrencyPairByName(String pairName) {
+        return currencyDao.findCurrencyPairByName(pairName);
+    }
 
-  @Override
-  public Integer findCurrencyPairIdByName(String pairName) {
-    return currencyDao.findOpenCurrencyPairIdByName(pairName).orElseThrow(() -> new CurrencyPairNotFoundException(pairName));
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public Integer findCurrencyPairIdByName(String pairName) {
+        return currencyDao.findOpenCurrencyPairIdByName(pairName)
+                .orElseThrow(() -> new CurrencyPairNotFoundException(pairName));
+    }
 
-  @Override
-  public List<Currency> findAllCurrenciesByProcessType(MerchantProcessType processType) {
-    return currencyDao.findAllCurrenciesByProcessType(processType);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<Currency> findAllCurrenciesByProcessType(MerchantProcessType processType) {
+        return currencyDao.findAllCurrenciesByProcessType(processType);
+    }
 
-  @Override
-  public List<CurrencyPair> findPermitedCurrencyPairs(CurrencyPairType currencyPairType){
-    return currencyDao.findPermitedCurrencyPairs(currencyPairType);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<CurrencyPair> findPermittedCurrencyPairs(CurrencyPairType currencyPairType) {
+        return currencyDao.findPermitedCurrencyPairs(currencyPairType);
+    }
 
-  @Override
-  public CurrencyPair getNotHiddenCurrencyPairByName(String currencyPair) {
-    return currencyDao.getNotHiddenCurrencyPairByName(currencyPair);
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public CurrencyPair getNotHiddenCurrencyPairByName(String currencyPair) {
+        return currencyDao.getNotHiddenCurrencyPairByName(currencyPair);
+    }
 
-
-
-  @Override
-  public List<CurrencyPairInfoItem> findActiveCurrencyPairs() {
-    return currencyDao.findActiveCurrencyPairs();
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public List<CurrencyPairInfoItem> findActiveCurrencyPairs() {
+        return currencyDao.findActiveCurrencyPairs();
+    }
 }
Index: Service/src/main/java/me/exrates/service/impl/MerchantServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/impl/MerchantServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/impl/MerchantServiceImpl.java	(revision Shelved Version)
@@ -2,8 +2,12 @@
 
 import javafx.util.Pair;
 import me.exrates.dao.MerchantDao;
-import me.exrates.model.*;
+import me.exrates.model.CreditsOperation;
 import me.exrates.model.Currency;
+import me.exrates.model.Email;
+import me.exrates.model.Merchant;
+import me.exrates.model.MerchantCurrency;
+import me.exrates.model.Transaction;
 import me.exrates.model.dto.MerchantCurrencyBasicInfoDto;
 import me.exrates.model.dto.MerchantCurrencyLifetimeDto;
 import me.exrates.model.dto.MerchantCurrencyOptionsDto;
@@ -11,13 +15,31 @@
 import me.exrates.model.dto.merchants.btc.CoreWalletDto;
 import me.exrates.model.dto.mobileApiDto.MerchantCurrencyApiDto;
 import me.exrates.model.dto.mobileApiDto.TransferMerchantApiDto;
-import me.exrates.model.enums.*;
+import me.exrates.model.enums.MerchantProcessType;
+import me.exrates.model.enums.OperationType;
+import me.exrates.model.enums.TransactionSourceType;
+import me.exrates.model.enums.UserCommentTopicEnum;
 import me.exrates.model.enums.invoice.RefillStatusEnum;
 import me.exrates.model.enums.invoice.WithdrawStatusEnum;
 import me.exrates.model.util.BigDecimalProcessing;
-import me.exrates.service.*;
-import me.exrates.service.exception.*;
-import me.exrates.service.merchantStrategy.*;
+import me.exrates.service.BitcoinService;
+import me.exrates.service.CommissionService;
+import me.exrates.service.CurrencyService;
+import me.exrates.service.MerchantService;
+import me.exrates.service.NotificationService;
+import me.exrates.service.SendMailService;
+import me.exrates.service.UserService;
+import me.exrates.service.exception.InvalidAmountException;
+import me.exrates.service.exception.MerchantCurrencyBlockedException;
+import me.exrates.service.exception.MerchantNotFoundException;
+import me.exrates.service.exception.MerchantServiceBeanNameNotDefinedException;
+import me.exrates.service.exception.MerchantServiceNotFoundException;
+import me.exrates.service.exception.ScaleForAmountNotSetException;
+import me.exrates.service.merchantStrategy.IMerchantService;
+import me.exrates.service.merchantStrategy.IRefillable;
+import me.exrates.service.merchantStrategy.ITransferable;
+import me.exrates.service.merchantStrategy.IWithdrawable;
+import me.exrates.service.merchantStrategy.MerchantServiceContext;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -28,7 +50,12 @@
 import org.springframework.transaction.annotation.Transactional;
 
 import java.math.BigDecimal;
-import java.util.*;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -36,6 +63,8 @@
 import static java.math.BigDecimal.ROUND_HALF_UP;
 import static me.exrates.model.enums.OperationType.OUTPUT;
 import static me.exrates.model.enums.OperationType.USER_TRANSFER;
+import static me.exrates.service.converters.BigDecimalConverter.convertToString;
+import static me.exrates.service.converters.BigDecimalConverter.resolvePrecisionByOperationType;
 
 /**
  * @author Denis Savin (pilgrimm333@gmail.com)
@@ -384,8 +413,8 @@
     final Map<String, String> result = new HashMap<>();
     final BigDecimal commission = commissionService.findCommissionByTypeAndRole(type, userService.getUserRoleFromSecurityContext()).getValue();
     final BigDecimal commissionMerchant = type == USER_TRANSFER ? BigDecimal.ZERO : commissionService.getCommissionMerchant(merchant, currency, type);
-    final BigDecimal commissionTotal = commission.add(commissionMerchant).setScale(currencyService.resolvePrecisionByOperationType(currency, type), ROUND_HALF_UP);
-    BigDecimal commissionAmount = amount.multiply(commissionTotal).divide(HUNDREDTH).setScale(currencyService.resolvePrecisionByOperationType(currency, type), ROUND_HALF_UP);
+    final BigDecimal commissionTotal = commission.add(commissionMerchant).setScale(resolvePrecisionByOperationType(currency, type), ROUND_HALF_UP);
+    BigDecimal commissionAmount = amount.multiply(commissionTotal).divide(HUNDREDTH).setScale(resolvePrecisionByOperationType(currency, type), ROUND_HALF_UP);
     String commissionString = Stream.of("(", commissionTotal.stripTrailingZeros().toString(), "%)").collect(Collectors.joining(""));
     if (type == OUTPUT) {
       BigDecimal merchantMinFixedCommission = commissionService.getMinFixedCommission(currencyService.findByName(currency).getId(), this.findByName(merchant).getId());
@@ -395,14 +424,14 @@
       }
     }
     LOG.debug("commission: " + commissionString);
-    final BigDecimal resultAmount = type != OUTPUT ? amount.add(commissionAmount).setScale(currencyService.resolvePrecisionByOperationType(currency, type), ROUND_HALF_UP) :
-            amount.subtract(commissionAmount).setScale(currencyService.resolvePrecisionByOperationType(currency, type), ROUND_DOWN);
+    final BigDecimal resultAmount = type != OUTPUT ? amount.add(commissionAmount).setScale(resolvePrecisionByOperationType(currency, type), ROUND_HALF_UP) :
+            amount.subtract(commissionAmount).setScale(resolvePrecisionByOperationType(currency, type), ROUND_DOWN);
     if (resultAmount.signum() <= 0) {
       throw new InvalidAmountException("merchants.invalidSum");
     }
     result.put("commission", commissionString);
-    result.put("commissionAmount", currencyService.amountToString(commissionAmount, currency));
-    result.put("amount", currencyService.amountToString(resultAmount, currency));
+    result.put("commissionAmount", convertToString(commissionAmount, currency));
+    result.put("amount", convertToString(resultAmount, currency));
     return result;
   }
 
Index: Service/src/main/java/me/exrates/service/impl/OrderServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/impl/OrderServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/impl/OrderServiceImpl.java	(revision Shelved Version)
@@ -2,11 +2,20 @@
 
 import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.common.collect.Maps;
 import lombok.extern.log4j.Log4j2;
 import me.exrates.dao.CommissionDao;
 import me.exrates.dao.OrderDao;
-import me.exrates.model.*;
+import me.exrates.model.Commission;
+import me.exrates.model.CompanyWallet;
 import me.exrates.model.Currency;
+import me.exrates.model.CurrencyPair;
+import me.exrates.model.ExOrder;
+import me.exrates.model.PagingData;
+import me.exrates.model.Transaction;
+import me.exrates.model.User;
+import me.exrates.model.UserRoleSettings;
+import me.exrates.model.Wallet;
 import me.exrates.model.chart.ChartResolution;
 import me.exrates.model.chart.ChartTimeFrame;
 import me.exrates.model.dto.*;
@@ -23,17 +32,57 @@
 import me.exrates.model.dto.openAPI.OrderBookItem;
 import me.exrates.model.dto.openAPI.OrderHistoryItem;
 import me.exrates.model.dto.openAPI.UserOrdersDto;
-import me.exrates.model.enums.*;
+import me.exrates.model.enums.ActionType;
+import me.exrates.model.enums.BusinessUserRoleEnum;
+import me.exrates.model.enums.ChartPeriodsEnum;
+import me.exrates.model.enums.ChartTimeFramesEnum;
+import me.exrates.model.enums.CurrencyPairType;
+import me.exrates.model.enums.NotificationEvent;
+import me.exrates.model.enums.OperationType;
+import me.exrates.model.enums.OrderActionEnum;
+import me.exrates.model.enums.OrderBaseType;
+import me.exrates.model.enums.OrderDeleteStatus;
+import me.exrates.model.enums.OrderHistoryPeriod;
+import me.exrates.model.enums.OrderStatus;
+import me.exrates.model.enums.OrderType;
+import me.exrates.model.enums.ReferralTransactionStatusEnum;
+import me.exrates.model.enums.RefreshObjectsEnum;
+import me.exrates.model.enums.TransactionSourceType;
+import me.exrates.model.enums.TransactionStatus;
+import me.exrates.model.enums.UserRole;
+import me.exrates.model.enums.WalletTransferStatus;
 import me.exrates.model.util.BigDecimalProcessing;
-import me.exrates.model.vo.*;
-import me.exrates.service.*;
+import me.exrates.model.vo.BackDealInterval;
+import me.exrates.model.vo.CacheData;
+import me.exrates.model.vo.OrderRoleInfoForDelete;
+import me.exrates.model.vo.TransactionDescription;
+import me.exrates.model.vo.WalletOperationData;
+import me.exrates.service.CompanyWalletService;
+import me.exrates.service.CurrencyService;
+import me.exrates.service.NotificationService;
+import me.exrates.service.OrderService;
+import me.exrates.service.ReferralService;
+import me.exrates.service.TransactionService;
+import me.exrates.service.UserRoleService;
+import me.exrates.service.UserService;
+import me.exrates.service.WalletService;
 import me.exrates.service.cache.ChartsCacheManager;
 import me.exrates.service.cache.ExchangeRatesHolder;
 import me.exrates.service.cache.OrdersStatisticByPairsCache;
 import me.exrates.service.events.AcceptOrderEvent;
 import me.exrates.service.events.CancelOrderEvent;
 import me.exrates.service.events.CreateOrderEvent;
-import me.exrates.service.exception.*;
+import me.exrates.service.exception.AlreadyAcceptedOrderException;
+import me.exrates.service.exception.AttemptToAcceptBotOrderException;
+import me.exrates.service.exception.IncorrectCurrentUserException;
+import me.exrates.service.exception.InsufficientCostsForAcceptionException;
+import me.exrates.service.exception.NotCreatableOrderException;
+import me.exrates.service.exception.NotEnoughUserWalletMoneyException;
+import me.exrates.service.exception.OrderAcceptionException;
+import me.exrates.service.exception.OrderCancellingException;
+import me.exrates.service.exception.OrderCreationException;
+import me.exrates.service.exception.OrderDeletingException;
+import me.exrates.service.exception.WalletCreationException;
 import me.exrates.service.exception.api.OrderParamsWrongException;
 import me.exrates.service.impl.proxy.ServiceCacheableProxy;
 import me.exrates.service.stopOrder.RatesHolder;
@@ -48,197 +97,221 @@
 import org.springframework.context.ApplicationEventPublisher;
 import org.springframework.context.MessageSource;
 import org.springframework.security.core.Authentication;
-import org.springframework.security.core.GrantedAuthority;
 import org.springframework.security.core.context.SecurityContextHolder;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Propagation;
 import org.springframework.transaction.annotation.Transactional;
 
-
 import javax.annotation.Nullable;
 import javax.annotation.PostConstruct;
-import javax.swing.text.html.Option;
 import java.math.BigDecimal;
 import java.security.Principal;
 import java.time.LocalDateTime;
-import java.util.*;
-import java.util.concurrent.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
+import java.util.StringJoiner;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
+import static java.util.Objects.isNull;
+import static java.util.Objects.nonNull;
 import static java.util.stream.Collectors.toList;
-import static me.exrates.model.enums.OrderActionEnum.*;
+import static me.exrates.model.enums.OrderActionEnum.ACCEPT;
+import static me.exrates.model.enums.OrderActionEnum.ACCEPTED;
+import static me.exrates.model.enums.OrderActionEnum.CANCEL;
+import static me.exrates.model.enums.OrderActionEnum.CREATE;
+import static me.exrates.model.enums.OrderActionEnum.CREATE_SPLIT;
+import static me.exrates.model.enums.OrderActionEnum.DELETE;
+import static me.exrates.model.enums.OrderActionEnum.DELETE_SPLIT;
 
 @Log4j2
 @Service
 public class OrderServiceImpl implements OrderService {
 
-  public static final String SCOPE = "ALL";
-  private static final int ORDERS_QUERY_DEFAULT_LIMIT = 20;
-  private static final Logger logger = LogManager.getLogger(OrderServiceImpl.class);
+    private static final Logger logger = LogManager.getLogger(OrderServiceImpl.class);
 
-  private final List<BackDealInterval> intervals = Arrays.stream(ChartPeriodsEnum.values())
-          .map(ChartPeriodsEnum::getBackDealInterval)
-          .collect(Collectors.toList());
+    private static final String SCOPE = "ALL";
+    private static final int ORDERS_QUERY_DEFAULT_LIMIT = 20;
+
+    private final List<BackDealInterval> intervals = Arrays.stream(ChartPeriodsEnum.values())
+            .map(ChartPeriodsEnum::getBackDealInterval)
+            .collect(Collectors.toList());
 
-  private final List<ChartTimeFrame> timeFrames = Arrays.stream(ChartTimeFramesEnum.values())
-          .map(ChartTimeFramesEnum::getTimeFrame)
-          .collect(toList());
+    private final List<ChartTimeFrame> timeFrames = Arrays.stream(ChartTimeFramesEnum.values())
+            .map(ChartTimeFramesEnum::getTimeFrame)
+            .collect(toList());
 
-  private List<CoinmarketApiDto> coinmarketCachedData = new CopyOnWriteArrayList<>();
-  private ScheduledExecutorService coinmarketScheduler = Executors.newSingleThreadScheduledExecutor();
+    private List<CoinmarketApiDto> coinmarketCachedData = new CopyOnWriteArrayList<>();
+    private ScheduledExecutorService coinmarketScheduler = Executors.newSingleThreadScheduledExecutor();
 
     private final Object autoAcceptLock = new Object();
     private final Object restOrderCreationLock = new Object();
 
-
-  @Autowired
-  private OrderDao orderDao;
-
-  @Autowired
-  private CommissionDao commissionDao;
-
-  @Autowired
-  private TransactionService transactionService;
-
-  @Autowired
-  private UserService userService;
-
-  @Autowired
-  private WalletService walletService;
-
-  @Autowired
-  private CompanyWalletService companyWalletService;
-
-  @Autowired
-  private CurrencyService currencyService;
-
-  @Autowired
-  private MessageSource messageSource;
-
+    private final OrderDao orderDao;
+    private final CommissionDao commissionDao;
+    private final TransactionService transactionService;
+    private final UserService userService;
+    private final WalletService walletService;
+    private final CompanyWalletService companyWalletService;
+    private final CurrencyService currencyService;
+    private MessageSource messageSource;
+    private final ReferralService referralService;
+    private final NotificationService notificationService;
+    private final ServiceCacheableProxy serviceCacheableProxy;
+    private final TransactionDescription transactionDescription;
+    private final StopOrderService stopOrderService;
+    private final RatesHolder ratesHolder;
+    private final UserRoleService userRoleService;
+    private final ObjectMapper objectMapper;
+    private final ApplicationEventPublisher eventPublisher;
+    private final OrdersStatisticByPairsCache ordersStatisticByPairsCache;
+    private final ChartsCacheManager chartsCacheManager;
+    private final ExchangeRatesHolder exchangeRatesHolder;
 
-  @Autowired
-  private ReferralService referralService;
-
-  @Autowired
-  NotificationService notificationService;
-
-  @Autowired
-  ServiceCacheableProxy serviceCacheableProxy;
-
-  @Autowired
-  TransactionDescription transactionDescription;
-
-  @Autowired
-  StopOrderService stopOrderService;
-  @Autowired
-  RatesHolder ratesHolder;
-  @Autowired
-  private UserRoleService userRoleService;
-  @Autowired
-  private ObjectMapper objectMapper;
-  @Autowired
-  private ApplicationEventPublisher eventPublisher;
-  @Autowired
-  private OrdersStatisticByPairsCache ordersStatisticByPairsCache;
-  @Autowired
-  private ChartsCacheManager chartsCacheManager;
-  @Autowired
-  private ExchangeRatesHolder exchangeRatesHolder;
+    @Autowired
+    public OrderServiceImpl(OrderDao orderDao,
+                            CommissionDao commissionDao,
+                            TransactionService transactionService,
+                            UserService userService,
+                            WalletService walletService,
+                            CompanyWalletService companyWalletService,
+                            CurrencyService currencyService,
+                            MessageSource messageSource,
+                            ReferralService referralService,
+                            NotificationService notificationService,
+                            ServiceCacheableProxy serviceCacheableProxy,
+                            TransactionDescription transactionDescription,
+                            StopOrderService stopOrderService,
+                            RatesHolder ratesHolder,
+                            UserRoleService userRoleService,
+                            ObjectMapper objectMapper,
+                            ApplicationEventPublisher eventPublisher,
+                            OrdersStatisticByPairsCache ordersStatisticByPairsCache,
+                            ChartsCacheManager chartsCacheManager,
+                            ExchangeRatesHolder exchangeRatesHolder) {
+        this.orderDao = orderDao;
+        this.commissionDao = commissionDao;
+        this.transactionService = transactionService;
+        this.userService = userService;
+        this.walletService = walletService;
+        this.companyWalletService = companyWalletService;
+        this.currencyService = currencyService;
+        this.messageSource = messageSource;
+        this.referralService = referralService;
+        this.notificationService = notificationService;
+        this.serviceCacheableProxy = serviceCacheableProxy;
+        this.transactionDescription = transactionDescription;
+        this.stopOrderService = stopOrderService;
+        this.ratesHolder = ratesHolder;
+        this.userRoleService = userRoleService;
+        this.objectMapper = objectMapper;
+        this.eventPublisher = eventPublisher;
+        this.ordersStatisticByPairsCache = ordersStatisticByPairsCache;
+        this.chartsCacheManager = chartsCacheManager;
+        this.exchangeRatesHolder = exchangeRatesHolder;
+    }
 
-  @PostConstruct
-  public void init() {
-    coinmarketScheduler.scheduleAtFixedRate(()-> {
-      List<CoinmarketApiDto> newData = getCoinmarketDataForActivePairs(null, new BackDealInterval("24 HOUR"));
-      coinmarketCachedData = new CopyOnWriteArrayList<>(newData);
-    }, 0, 30, TimeUnit.MINUTES);
-  }
+    @PostConstruct
+    public void init() {
+        coinmarketScheduler.scheduleAtFixedRate(() -> {
+            List<CoinmarketApiDto> newData = getCoinmarketDataForActivePairs(null, new BackDealInterval("24 HOUR"));
+            coinmarketCachedData = new CopyOnWriteArrayList<>(newData);
+        }, 0, 30, TimeUnit.MINUTES);
+    }
 
 
-  @Override
-  public List<BackDealInterval> getIntervals() {
-    return intervals;
-  }
+    @Override
+    public List<BackDealInterval> getIntervals() {
+        return intervals;
+    }
 
-  @Override
-  public List<ChartTimeFrame> getChartTimeFrames() {
-    return timeFrames;
-  }
+    @Override
+    public List<ChartTimeFrame> getChartTimeFrames() {
+        return timeFrames;
+    }
 
-  @Transactional(transactionManager = "slaveTxManager", readOnly = true)
-  @Override
-  public ExOrderStatisticsDto getOrderStatistic(CurrencyPair currencyPair, BackDealInterval backDealInterval, Locale locale) {
-    ExOrderStatisticsDto result = orderDao.getOrderStatistic(currencyPair, backDealInterval);
-    result = new ExOrderStatisticsDto(result);
-    result.setPercentChange(BigDecimalProcessing.formatNonePoint(BigDecimalProcessing.doAction(
-            result.getFirstOrderRate(), result.getLastOrderRate(), ActionType.PERCENT_GROWTH), 2));
-    result.setFirstOrderAmountBase(BigDecimalProcessing.formatNonePoint(result.getFirstOrderAmountBase(), true));
-    result.setFirstOrderRate(BigDecimalProcessing.formatNonePoint(result.getFirstOrderRate(), true));
-    result.setLastOrderAmountBase(BigDecimalProcessing.formatNonePoint(result.getLastOrderAmountBase(), true));
-    result.setLastOrderRate(BigDecimalProcessing.formatNonePoint(result.getLastOrderRate(), true));
-    result.setMinRate(BigDecimalProcessing.formatNonePoint(result.getMinRate(), true));
-    result.setMaxRate(BigDecimalProcessing.formatNonePoint(result.getMaxRate(), true));
-    result.setSumBase(BigDecimalProcessing.formatNonePoint(result.getSumBase(), true));
-    result.setSumConvert(BigDecimalProcessing.formatNonePoint(result.getSumConvert(), true));
-    return result;
-  }
+    @Transactional(transactionManager = "slaveTxManager", readOnly = true)
+    @Override
+    public ExOrderStatisticsDto getOrderStatistic(CurrencyPair currencyPair, BackDealInterval backDealInterval, Locale locale) {
+        ExOrderStatisticsDto result = orderDao.getOrderStatistic(currencyPair, backDealInterval);
+        result = new ExOrderStatisticsDto(result);
+        result.setPercentChange(BigDecimalProcessing.formatNonePoint(BigDecimalProcessing.doAction(
+                result.getFirstOrderRate(), result.getLastOrderRate(), ActionType.PERCENT_GROWTH), 2));
+        result.setFirstOrderAmountBase(BigDecimalProcessing.formatNonePoint(result.getFirstOrderAmountBase(), true));
+        result.setFirstOrderRate(BigDecimalProcessing.formatNonePoint(result.getFirstOrderRate(), true));
+        result.setLastOrderAmountBase(BigDecimalProcessing.formatNonePoint(result.getLastOrderAmountBase(), true));
+        result.setLastOrderRate(BigDecimalProcessing.formatNonePoint(result.getLastOrderRate(), true));
+        result.setMinRate(BigDecimalProcessing.formatNonePoint(result.getMinRate(), true));
+        result.setMaxRate(BigDecimalProcessing.formatNonePoint(result.getMaxRate(), true));
+        result.setSumBase(BigDecimalProcessing.formatNonePoint(result.getSumBase(), true));
+        result.setSumConvert(BigDecimalProcessing.formatNonePoint(result.getSumConvert(), true));
+        return result;
+    }
 
-  @Override
-  public List<Map<String, Object>> getDataForAreaChart(CurrencyPair currencyPair, BackDealInterval interval) {
-    logger.info("Begin 'getDataForAreaChart' method");
-    return orderDao.getDataForAreaChart(currencyPair, interval);
-  }
+    @Override
+    public List<Map<String, Object>> getDataForAreaChart(CurrencyPair currencyPair, BackDealInterval interval) {
+        logger.info("Begin 'getDataForAreaChart' method");
+        return orderDao.getDataForAreaChart(currencyPair, interval);
+    }
 
 
-
-  @Override
-  public List<CandleChartItemDto> getDataForCandleChart(CurrencyPair currencyPair, BackDealInterval interval) {
-    return orderDao.getDataForCandleChart(currencyPair, interval);
-  }
+    @Override
+    public List<CandleChartItemDto> getDataForCandleChart(CurrencyPair currencyPair, BackDealInterval interval) {
+        return orderDao.getDataForCandleChart(currencyPair, interval);
+    }
 
 
-
-  @Override
-  public List<CandleChartItemDto> getCachedDataForCandle(CurrencyPair currencyPair, ChartTimeFrame timeFrame) {
-    return chartsCacheManager.getData(currencyPair.getId(), timeFrame);
-  }
+    @Override
+    public List<CandleChartItemDto> getCachedDataForCandle(CurrencyPair currencyPair, ChartTimeFrame timeFrame) {
+        return chartsCacheManager.getData(currencyPair.getId(), timeFrame);
+    }
 
 
-  @Override
-  public List<CandleChartItemDto> getLastDataForCandleChart(Integer currencyPairId,
-                                                            LocalDateTime startTime, ChartResolution resolution) {
+    @Override
+    public List<CandleChartItemDto> getLastDataForCandleChart(Integer currencyPairId,
+                                                              LocalDateTime startTime, ChartResolution resolution) {
 
 
-    return orderDao.getDataForCandleChart(currencyService.findCurrencyPairById(currencyPairId), startTime, LocalDateTime.now(),
-            resolution.getTimeValue(), resolution.getTimeUnit().name());
-  }
+        return orderDao.getDataForCandleChart(currencyService.findCurrencyPairById(currencyPairId), startTime, LocalDateTime.now(),
+                resolution.getTimeValue(), resolution.getTimeUnit().name());
+    }
 
 
-  @Override
-  public List<CandleChartItemDto> getDataForCandleChart(int pairId, ChartTimeFrame timeFrame) {
-    LocalDateTime endTime = LocalDateTime.now();
+    @Override
+    public List<CandleChartItemDto> getDataForCandleChart(int pairId, ChartTimeFrame timeFrame) {
+        LocalDateTime endTime = LocalDateTime.now();
 //    LocalDateTime lastHalfHour = endTime.truncatedTo(ChronoUnit.HOURS)
 //            .plusMinutes(30 * (endTime.getMinute() / 30));
-    LocalDateTime startTime = endTime.minus(timeFrame.getTimeValue(), timeFrame.getTimeUnit().getCorrespondingTimeUnit());
+        LocalDateTime startTime = endTime.minus(timeFrame.getTimeValue(), timeFrame.getTimeUnit().getCorrespondingTimeUnit());
 //    LocalDateTime firstHalfHour = startTime.truncatedTo(ChronoUnit.HOURS)
 //            .plusMinutes(30 * (startTime.getMinute() / 30));
 
-    return orderDao.getDataForCandleChart(currencyService.findCurrencyPairById(pairId),
-            startTime, endTime, timeFrame.getResolution().getTimeValue(),
-            timeFrame.getResolution().getTimeUnit().name());
-  }
+        return orderDao.getDataForCandleChart(currencyService.findCurrencyPairById(pairId),
+                startTime, endTime, timeFrame.getResolution().getTimeValue(),
+                timeFrame.getResolution().getTimeUnit().name());
+    }
 
 
-
-  @Override
-  public List<CandleChartItemDto> getDataForCandleChart(CurrencyPair currencyPair, BackDealInterval interval, LocalDateTime startTime) {
-    LocalDateTime endTime = startTime.plus((long) interval.intervalValue, interval.intervalType.getCorrespondingTimeUnit());
-    return orderDao.getDataForCandleChart(currencyPair, interval, endTime);
-  }
+    @Override
+    public List<CandleChartItemDto> getDataForCandleChart(CurrencyPair currencyPair, BackDealInterval interval, LocalDateTime startTime) {
+        LocalDateTime endTime = startTime.plus((long) interval.intervalValue, interval.intervalType.getCorrespondingTimeUnit());
+        return orderDao.getDataForCandleChart(currencyPair, interval, endTime);
+    }
 
 
-  @Override
-  public List<ExOrderStatisticsShortByPairsDto> getOrdersStatisticByPairs(CacheData cacheData, Locale locale) {
+    @Override
+    public List<ExOrderStatisticsShortByPairsDto> getOrdersStatisticByPairs(CacheData cacheData, Locale locale) {
       /*Boolean evictEhCache = cacheData.getForceUpdate() && false;
       List<ExOrderStatisticsShortByPairsDto> result = serviceCacheableProxy.getOrdersStatisticByPairs(evictEhCache);
       if (Cache.checkCache(cacheData, result)) {
@@ -259,1009 +332,1051 @@
                 }
         );
       }*/
-    List<ExOrderStatisticsShortByPairsDto> result = orderDao.getOrderStatisticByPairs();
-    result = result.stream()
-            .map(ExOrderStatisticsShortByPairsDto::new)
-            .collect(toList());
-    result.forEach(e -> {
-      BigDecimal lastRate = new BigDecimal(e.getLastOrderRate());
-      BigDecimal predLastRate = e.getPredLastOrderRate() == null ? lastRate : new BigDecimal(e.getPredLastOrderRate());
-      e.setLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(lastRate, locale, 12));
-      e.setPredLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(predLastRate, locale, 12));
-      BigDecimal percentChange = BigDecimalProcessing.doAction(predLastRate, lastRate, ActionType.PERCENT_GROWTH);
-      e.setPercentChange(BigDecimalProcessing.formatLocaleFixedDecimal(percentChange, locale, 2));
-    });
-    return result;
-  }
+        List<ExOrderStatisticsShortByPairsDto> result = orderDao.getOrderStatisticByPairs();
+        result = result.stream()
+                .map(ExOrderStatisticsShortByPairsDto::new)
+                .collect(toList());
+        result.forEach(e -> {
+            BigDecimal lastRate = new BigDecimal(e.getLastOrderRate());
+            BigDecimal predLastRate = e.getPredLastOrderRate() == null ? lastRate : new BigDecimal(e.getPredLastOrderRate());
+            e.setLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(lastRate, locale, 12));
+            e.setPredLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(predLastRate, locale, 12));
+            BigDecimal percentChange = BigDecimalProcessing.doAction(predLastRate, lastRate, ActionType.PERCENT_GROWTH);
+            e.setPercentChange(BigDecimalProcessing.formatLocaleFixedDecimal(percentChange, locale, 2));
+        });
+        return result;
+    }
 
-   @Transactional(readOnly = true)
-   @Override
-   public List<ExOrderStatisticsShortByPairsDto> getOrdersStatisticByPairsEx(RefreshObjectsEnum refreshObjectsEnum) {
-      List<ExOrderStatisticsShortByPairsDto> dto = this.processStatistic(exchangeRatesHolder.getAllRates());
-      switch (refreshObjectsEnum) {
-          case ICO_CURRENCIES_STATISTIC: {
-              dto = dto.stream().filter(p->p.getType() == CurrencyPairType.ICO).collect(toList());
-              break;
-          }
-          case MAIN_CURRENCIES_STATISTIC: {
-              dto = dto.stream().filter(p->p.getType() == CurrencyPairType.MAIN).collect(toList());
-              break;
-          }
-          default: {
-          }
-      }
-     return dto;
-   }
+    @Transactional(readOnly = true)
+    @Override
+    public List<ExOrderStatisticsShortByPairsDto> getOrdersStatisticByPairsEx(RefreshObjectsEnum refreshObjectsEnum) {
+        List<ExOrderStatisticsShortByPairsDto> dto = this.processStatistic(exchangeRatesHolder.getAllRates());
+        switch (refreshObjectsEnum) {
+            case ICO_CURRENCIES_STATISTIC: {
+                dto = dto.stream().filter(p -> p.getType() == CurrencyPairType.ICO).collect(toList());
+                break;
+            }
+            case MAIN_CURRENCIES_STATISTIC: {
+                dto = dto.stream().filter(p -> p.getType() == CurrencyPairType.MAIN).collect(toList());
+                break;
+            }
+            default: {
+            }
+        }
+        return dto;
+    }
 
     @Override
     public List<ExOrderStatisticsShortByPairsDto> getStatForSomeCurrencies(List<Integer> pairsIds) {
-      List<ExOrderStatisticsShortByPairsDto> dto = exchangeRatesHolder.getCurrenciesRates(pairsIds);
-      Locale locale = Locale.ENGLISH;
-      dto.forEach(e -> {
-        BigDecimal lastRate = new BigDecimal(e.getLastOrderRate());
-        BigDecimal predLastRate = e.getPredLastOrderRate() == null ? lastRate : new BigDecimal(e.getPredLastOrderRate());
-        e.setLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(lastRate, locale, 12));
-        e.setPredLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(predLastRate, locale, 12));
-        BigDecimal percentChange = BigDecimalProcessing.doAction(predLastRate, lastRate, ActionType.PERCENT_GROWTH);
-        e.setPercentChange(BigDecimalProcessing.formatLocaleFixedDecimal(percentChange, locale, 2));
-      });  return dto;
+        List<ExOrderStatisticsShortByPairsDto> dto = exchangeRatesHolder.getCurrenciesRates(pairsIds);
+        Locale locale = Locale.ENGLISH;
+        dto.forEach(e -> {
+            BigDecimal lastRate = new BigDecimal(e.getLastOrderRate());
+            BigDecimal predLastRate = e.getPredLastOrderRate() == null ? lastRate : new BigDecimal(e.getPredLastOrderRate());
+            e.setLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(lastRate, locale, 12));
+            e.setPredLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(predLastRate, locale, 12));
+            BigDecimal percentChange = BigDecimalProcessing.doAction(predLastRate, lastRate, ActionType.PERCENT_GROWTH);
+            e.setPercentChange(BigDecimalProcessing.formatLocaleFixedDecimal(percentChange, locale, 2));
+        });
+        return dto;
     }
 
-  @Transactional
-  @Override
-  public List<ExOrderStatisticsShortByPairsDto> getOrdersStatisticByPairsSessionless(Locale locale) {
-    List<ExOrderStatisticsShortByPairsDto> result = exchangeRatesHolder.getAllRates();
-    result.forEach(e -> {
-          BigDecimal lastRate = new BigDecimal(e.getLastOrderRate());
-          BigDecimal predLastRate = e.getPredLastOrderRate() == null ? lastRate : new BigDecimal(e.getPredLastOrderRate());
-          e.setLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(lastRate, locale, 12));
-          e.setPredLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(predLastRate, locale, 12));
-          BigDecimal percentChange = BigDecimalProcessing.doAction(predLastRate, lastRate, ActionType.PERCENT_GROWTH);
-          e.setPercentChange(BigDecimalProcessing.formatLocaleFixedDecimal(percentChange, locale, 2));
-        }
-    );
-    return result;
-  }
+    @Transactional
+    @Override
+    public List<ExOrderStatisticsShortByPairsDto> getOrdersStatisticByPairsSessionless(Locale locale) {
+        List<ExOrderStatisticsShortByPairsDto> result = exchangeRatesHolder.getAllRates();
+        result.forEach(e -> {
+                    BigDecimal lastRate = new BigDecimal(e.getLastOrderRate());
+                    BigDecimal predLastRate = e.getPredLastOrderRate() == null ? lastRate : new BigDecimal(e.getPredLastOrderRate());
+                    e.setLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(lastRate, locale, 12));
+                    e.setPredLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(predLastRate, locale, 12));
+                    BigDecimal percentChange = BigDecimalProcessing.doAction(predLastRate, lastRate, ActionType.PERCENT_GROWTH);
+                    e.setPercentChange(BigDecimalProcessing.formatLocaleFixedDecimal(percentChange, locale, 2));
+                }
+        );
+        return result;
+    }
 
-  @Override
-  public OrderCreateDto prepareNewOrder(CurrencyPair activeCurrencyPair, OperationType orderType, String userEmail, BigDecimal amount, BigDecimal rate, OrderBaseType baseType) {
-    return prepareNewOrder(activeCurrencyPair, orderType, userEmail, amount, rate, null, baseType);
-  }
-  
-  @Override
-  public OrderCreateDto prepareNewOrder(CurrencyPair activeCurrencyPair, OperationType orderType, String userEmail, BigDecimal amount, BigDecimal rate, Integer sourceId, OrderBaseType baseType) {
-    Currency spendCurrency = null;
-    if (orderType == OperationType.SELL) {
-      spendCurrency = activeCurrencyPair.getCurrency1();
-    } else if (orderType == OperationType.BUY) {
-      spendCurrency = activeCurrencyPair.getCurrency2();
-    }
-    WalletsAndCommissionsForOrderCreationDto walletsAndCommissions = getWalletAndCommission(userEmail, spendCurrency, orderType);
-        /**/
-    OrderCreateDto orderCreateDto = new OrderCreateDto();
-    orderCreateDto.setOperationType(orderType);
-    orderCreateDto.setCurrencyPair(activeCurrencyPair);
-    orderCreateDto.setAmount(amount);
-    orderCreateDto.setExchangeRate(rate);
-    orderCreateDto.setUserId(walletsAndCommissions.getUserId());
-    orderCreateDto.setCurrencyPair(activeCurrencyPair);
-    orderCreateDto.setSourceId(sourceId);
-    orderCreateDto.setOrderBaseType(baseType);
-    /*todo get 0 comission values from db*/
-    if (baseType == OrderBaseType.ICO) {
-      walletsAndCommissions.setCommissionValue(BigDecimal.ZERO);
-      walletsAndCommissions.setCommissionId(24);
-    }
-    if (orderType == OperationType.SELL) {
-      orderCreateDto.setWalletIdCurrencyBase(walletsAndCommissions.getSpendWalletId());
-      orderCreateDto.setCurrencyBaseBalance(walletsAndCommissions.getSpendWalletActiveBalance());
-      orderCreateDto.setComissionForSellId(walletsAndCommissions.getCommissionId());
-      orderCreateDto.setComissionForSellRate(walletsAndCommissions.getCommissionValue());
-    } else if (orderType == OperationType.BUY) {
-      orderCreateDto.setWalletIdCurrencyConvert(walletsAndCommissions.getSpendWalletId());
-      orderCreateDto.setCurrencyConvertBalance(walletsAndCommissions.getSpendWalletActiveBalance());
-      orderCreateDto.setComissionForBuyId(walletsAndCommissions.getCommissionId());
-      orderCreateDto.setComissionForBuyRate(walletsAndCommissions.getCommissionValue());
-    }
-        /**/
-    orderCreateDto.calculateAmounts();
-    return orderCreateDto;
-  }
+    @Override
+    public OrderCreateDto prepareNewOrder(CurrencyPair activeCurrencyPair,
+                                          OperationType orderType,
+                                          String userEmail,
+                                          BigDecimal amount,
+                                          BigDecimal rate,
+                                          OrderBaseType baseType) {
+        return prepareNewOrder(activeCurrencyPair, orderType, userEmail, amount, rate, null, baseType);
+    }
+
+    @Override
+    public OrderCreateDto prepareNewOrder(CurrencyPair activeCurrencyPair,
+                                          OperationType orderType,
+                                          String userEmail,
+                                          BigDecimal amount,
+                                          BigDecimal rate,
+                                          Integer sourceId,
+                                          OrderBaseType baseType) {
+        Currency spendCurrency = null;
+        if (orderType == OperationType.SELL) {
+            spendCurrency = activeCurrencyPair.getCurrency1();
+        } else if (orderType == OperationType.BUY) {
+            spendCurrency = activeCurrencyPair.getCurrency2();
+        }
+        WalletsAndCommissionsForOrderCreationDto walletsAndCommissions = getWalletAndCommission(userEmail, spendCurrency, orderType);
+
+        //todo get 0 commission values from db
+        if (baseType == OrderBaseType.ICO) {
+            walletsAndCommissions = walletsAndCommissions.toBuilder()
+                    .commissionId(24)
+                    .commissionValue(BigDecimal.ZERO)
+                    .build();
+        }
+        OrderCreateDto.Builder builder = OrderCreateDto.builder()
+                .operationType(orderType)
+                .currencyPair(activeCurrencyPair)
+                .amount(amount)
+                .exchangeRate(rate)
+                .userId(walletsAndCommissions.getUserId())
+                .currencyPair(activeCurrencyPair)
+                .sourceId(sourceId)
+                .orderBaseType(baseType);
+        if (orderType == OperationType.SELL) {
+            builder
+                    .walletIdCurrencyBase(walletsAndCommissions.getSpendWalletId())
+                    .currencyBaseBalance(walletsAndCommissions.getSpendWalletActiveBalance())
+                    .commissionForSellId(walletsAndCommissions.getCommissionId())
+                    .commissionForSellRate(walletsAndCommissions.getCommissionValue());
+        } else if (orderType == OperationType.BUY) {
+            builder
+                    .walletIdCurrencyConvert(walletsAndCommissions.getSpendWalletId())
+                    .currencyConvertBalance(walletsAndCommissions.getSpendWalletActiveBalance())
+                    .commissionForBuyId(walletsAndCommissions.getCommissionId())
+                    .commissionForBuyRate(walletsAndCommissions.getCommissionValue());
+        }
+        return builder.build().calculateAmounts();
+    }
 
-  @Override
-  public OrderValidationDto validateOrder(OrderCreateDto orderCreateDto) {
-    OrderValidationDto orderValidationDto = new OrderValidationDto();
-    Map<String, Object> errors = orderValidationDto.getErrors();
-    Map<String, Object[]> errorParams = orderValidationDto.getErrorParams();
-    if (orderCreateDto.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
-      errors.put("amount_" + errors.size(), "order.fillfield");
-    }
-    if (orderCreateDto.getExchangeRate().compareTo(BigDecimal.ZERO) <= 0) {
-      errors.put("exrate_" + errors.size(), "order.fillfield");
-    }
+    @Override
+    public OrderValidationDto validateOrder(OrderCreateDto orderCreateDto) {
+        Map<String, Object> errors = Maps.newHashMap();
+        Map<String, Object[]> errorParams = Maps.newHashMap();
+
+        if (orderCreateDto.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
+            errors.put("amount_" + errors.size(), "order.fillfield");
+        }
+        if (orderCreateDto.getExchangeRate().compareTo(BigDecimal.ZERO) <= 0) {
+            errors.put("exrate_" + errors.size(), "order.fillfield");
+        }
 
-    CurrencyPairLimitDto currencyPairLimit = currencyService.findLimitForRoleByCurrencyPairAndType(orderCreateDto.getCurrencyPair().getId(),
-            orderCreateDto.getOperationType());
-    if (orderCreateDto.getOrderBaseType() != null && orderCreateDto.getOrderBaseType().equals(OrderBaseType.STOP_LIMIT)) {
-      if (orderCreateDto.getStop() == null || orderCreateDto.getStop().compareTo(BigDecimal.ZERO) <= 0) {
-        errors.put("stop_" + errors.size(), "order.fillfield");
-      } else {
-        if (orderCreateDto.getStop().compareTo(currencyPairLimit.getMinRate()) < 0) {
-          String key = "stop_" + errors.size();
-          errors.put(key, "order.minrate");
-          errorParams.put(key, new Object[]{currencyPairLimit.getMinRate()});
-        }
-        if (orderCreateDto.getStop().compareTo(currencyPairLimit.getMaxRate()) > 0) {
-          String key = "stop_" + errors.size();
-          errors.put(key, "order.maxrate");
-          errorParams.put(key, new Object[]{currencyPairLimit.getMaxRate()});
-        }
-      }
-    }
-    /*------------------*/
-    if (orderCreateDto.getCurrencyPair().getPairType() == CurrencyPairType.ICO) {
-      validateIcoOrder(errors, errorParams, orderCreateDto);
-    }
-    /*------------------*/
-    if (orderCreateDto.getAmount() != null) {
-      if (orderCreateDto.getAmount().compareTo(currencyPairLimit.getMaxAmount()) > 0) {
-        String key1 = "amount_" + errors.size();
-        errors.put(key1, "order.maxvalue");
-        errorParams.put(key1, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMaxAmount(), false)});
-        String key2 = "amount_" + errors.size();
-        errors.put(key2, "order.valuerange");
-        errorParams.put(key2, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMinAmount(), false),
-                BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMaxAmount(), false)});
-      }
-      if (orderCreateDto.getAmount().compareTo(currencyPairLimit.getMinAmount()) < 0) {
-        String key1 = "amount_" + errors.size();
-        errors.put(key1, "order.minvalue");
-        errorParams.put(key1, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMinAmount(), false)});
-        String key2 = "amount_" + errors.size();
-        errors.put(key2, "order.valuerange");
-        errorParams.put(key2, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMinAmount(), false),
-                BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMaxAmount(), false)});
-      }
-    }
-    if (orderCreateDto.getExchangeRate() != null) {
-      if (orderCreateDto.getExchangeRate().compareTo(BigDecimal.ZERO) < 1) {
-        errors.put("exrate_" + errors.size(), "order.zerorate");
-      }
-      if (orderCreateDto.getExchangeRate().compareTo(currencyPairLimit.getMinRate()) < 0) {
-        String key = "exrate_" + errors.size();
-        errors.put(key, "order.minrate");
-        errorParams.put(key, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMinRate(), false)});
-      }
-      if (orderCreateDto.getExchangeRate().compareTo(currencyPairLimit.getMaxRate()) > 0) {
-        String key = "exrate_" + errors.size();
-        errors.put(key, "order.maxrate");
-        errorParams.put(key, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMaxRate(), false)});
-      }
-      
-    }
-    if ((orderCreateDto.getAmount() != null) && (orderCreateDto.getExchangeRate() != null)) {
-      boolean ifEnoughMoney = orderCreateDto.getSpentWalletBalance().compareTo(BigDecimal.ZERO) > 0 && orderCreateDto.getSpentAmount().compareTo(orderCreateDto.getSpentWalletBalance()) <= 0;
-      if (!ifEnoughMoney) {
-        errors.put("balance_" + errors.size(), "validation.orderNotEnoughMoney");
-      }
-    }
-    return orderValidationDto;
-  }
+        final CurrencyPairLimitDto currencyPairLimit = currencyService.findLimitForRoleByCurrencyPairAndType(
+                orderCreateDto.getCurrencyPair().getId(),
+                orderCreateDto.getOperationType());
+
+        if (nonNull(orderCreateDto.getOrderBaseType()) && orderCreateDto.getOrderBaseType().equals(OrderBaseType.STOP_LIMIT)) {
+            if (isNull(orderCreateDto.getStop()) || orderCreateDto.getStop().compareTo(BigDecimal.ZERO) <= 0) {
+                errors.put("stop_" + errors.size(), "order.fillfield");
+            } else {
+                if (orderCreateDto.getStop().compareTo(currencyPairLimit.getMinRate()) < 0) {
+                    String key = "stop_" + errors.size();
+                    errors.put(key, "order.minrate");
+                    errorParams.put(key, new Object[]{currencyPairLimit.getMinRate()});
+                }
+                if (orderCreateDto.getStop().compareTo(currencyPairLimit.getMaxRate()) > 0) {
+                    String key = "stop_" + errors.size();
+                    errors.put(key, "order.maxrate");
+                    errorParams.put(key, new Object[]{currencyPairLimit.getMaxRate()});
+                }
+            }
+        }
+
+        if (orderCreateDto.getCurrencyPair().getPairType() == CurrencyPairType.ICO) {
+            errors = validateIcoOrder(errors, orderCreateDto);
+        }
+
+        if (nonNull(orderCreateDto.getAmount())) {
+            if (orderCreateDto.getAmount().compareTo(currencyPairLimit.getMaxAmount()) > 0) {
+                String key = "amount_" + errors.size();
+                errors.put(key, "order.maxvalue");
+                errorParams.put(key, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMaxAmount(), false)});
+                key = "amount_" + errors.size();
+                errors.put(key, "order.valuerange");
+                errorParams.put(key, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMinAmount(), false),
+                        BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMaxAmount(), false)});
+            }
+            if (orderCreateDto.getAmount().compareTo(currencyPairLimit.getMinAmount()) < 0) {
+                String key = "amount_" + errors.size();
+                errors.put(key, "order.minvalue");
+                errorParams.put(key, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMinAmount(), false)});
+                key = "amount_" + errors.size();
+                errors.put(key, "order.valuerange");
+                errorParams.put(key, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMinAmount(), false),
+                        BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMaxAmount(), false)});
+            }
+        }
+        if (nonNull(orderCreateDto.getExchangeRate())) {
+            if (orderCreateDto.getExchangeRate().compareTo(BigDecimal.ZERO) < 1) {
+                errors.put("exrate_" + errors.size(), "order.zerorate");
+            }
+            if (orderCreateDto.getExchangeRate().compareTo(currencyPairLimit.getMinRate()) < 0) {
+                String key = "exrate_" + errors.size();
+                errors.put(key, "order.minrate");
+                errorParams.put(key, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMinRate(), false)});
+            }
+            if (orderCreateDto.getExchangeRate().compareTo(currencyPairLimit.getMaxRate()) > 0) {
+                String key = "exrate_" + errors.size();
+                errors.put(key, "order.maxrate");
+                errorParams.put(key, new Object[]{BigDecimalProcessing.formatNonePoint(currencyPairLimit.getMaxRate(), false)});
+            }
+
+        }
+        if (nonNull(orderCreateDto.getAmount()) && nonNull(orderCreateDto.getExchangeRate())) {
+            boolean ifEnoughMoney = orderCreateDto.getSpentWalletBalance().compareTo(BigDecimal.ZERO) > 0
+                    && orderCreateDto.getSpentAmount().compareTo(orderCreateDto.getSpentWalletBalance()) <= 0;
+            if (!ifEnoughMoney) {
+                errors.put("balance_" + errors.size(), "validation.orderNotEnoughMoney");
+            }
+        }
+        return OrderValidationDto.builder()
+                .errors(errors)
+                .errorParams(errorParams)
+                .build();
+    }
 
-  private void validateIcoOrder(Map<String, Object> errors, Map<String, Object[]> errorParams, OrderCreateDto orderCreateDto) {
-    if (orderCreateDto.getOrderBaseType() != OrderBaseType.ICO) {
-      throw new RuntimeException("unsupported type of order");
-    }
-    if (orderCreateDto.getOperationType() == OperationType.SELL) {
-      SecurityContextHolder.getContext().getAuthentication().getAuthorities()
-              .stream()
-              .filter(p-> p.getAuthority().equals(UserRole.ICO_MARKET_MAKER.name())).findAny().orElseThrow(()-> new RuntimeException("not allowed"));
-    }
-    if (orderCreateDto.getOperationType() == OperationType.BUY) {
-      Optional<BigDecimal> lastRate = orderDao.getLowestOpenOrderPriceByCurrencyPairAndOperationType(orderCreateDto.getCurrencyPair().getId(), OperationType.SELL.type);
-      if (!lastRate.isPresent() || orderCreateDto.getExchangeRate().compareTo(lastRate.get()) < 0) {
-        errors.put("exrate_" + errors.size(), "order_ico.no_orders_for_rate");
-      }
-    }
-  }
+    private Map<String, Object> validateIcoOrder(Map<String, Object> errors, OrderCreateDto orderCreateDto) {
+        if (orderCreateDto.getOrderBaseType() != OrderBaseType.ICO) {
+            throw new RuntimeException("Unsupported type of order");
+        }
+        if (orderCreateDto.getOperationType() == OperationType.SELL) {
+            SecurityContextHolder.getContext().getAuthentication().getAuthorities()
+                    .stream()
+                    .filter(authority -> authority.getAuthority().equals(UserRole.ICO_MARKET_MAKER.getName()))
+                    .findAny()
+                    .orElseThrow(() -> new RuntimeException("not allowed"));
+        }
+        if (orderCreateDto.getOperationType() == OperationType.BUY) {
+            Optional<BigDecimal> lastRate = orderDao.getLowestOpenOrderPriceByCurrencyPairAndOperationType(orderCreateDto.getCurrencyPair().getId(), OperationType.SELL.getCode());
+            if (!lastRate.isPresent() || orderCreateDto.getExchangeRate().compareTo(lastRate.get()) < 0) {
+                errors.put("exrate_" + errors.size(), "order_ico.no_orders_for_rate");
+            }
+        }
+        return errors;
+    }
 
-  @Override
-  public String createOrder(OrderCreateDto orderCreateDto, OrderActionEnum action, Locale locale) {
-    Optional<String> autoAcceptResult = this.autoAccept(orderCreateDto, locale);
-    if (autoAcceptResult.isPresent()) {
-      logger.debug(autoAcceptResult.get());
-      return autoAcceptResult.get();
-    }
-    Integer orderId = this.createOrder(orderCreateDto, CREATE);
-    if (orderId <= 0) {
-      throw new NotCreatableOrderException(messageSource.getMessage("dberror.text", null, locale));
-    }
-    return "{\"result\":\"" + messageSource.getMessage("createdorder.text", null, locale) + "\"}";
-  }
+    @Override
+    public String createOrder(OrderCreateDto orderCreateDto, OrderActionEnum action, Locale locale) {
+        Optional<String> autoAcceptResult = this.autoAccept(orderCreateDto, locale);
+        if (autoAcceptResult.isPresent()) {
+            logger.debug(autoAcceptResult.get());
+            return autoAcceptResult.get();
+        }
+        Integer orderId = this.createOrder(orderCreateDto, CREATE);
+        if (orderId <= 0) {
+            throw new NotCreatableOrderException(messageSource.getMessage("dberror.text", null, locale));
+        }
+        return "{\"result\":\"" + messageSource.getMessage("createdorder.text", null, locale) + "\"}";
+    }
 
-  @Override
-  @Transactional
-  public Integer createOrderByStopOrder(OrderCreateDto orderCreateDto, OrderActionEnum action, Locale locale) {
-      Optional<OrderCreationResultDto> autoAcceptResult = this.autoAcceptOrders(orderCreateDto, locale);
-      if (autoAcceptResult.isPresent()) {
-        logger.debug(autoAcceptResult.get());
-        return autoAcceptResult.get().getCreatedOrderId();
-      }
-    Integer orderId = this.createOrder(orderCreateDto, CREATE);
-    if (orderId <= 0) {
-      throw new NotCreatableOrderException(messageSource.getMessage("dberror.text", null, locale));
-    }
-    return orderId;
-  }
-  
-  
-  @Override
-  @Transactional(rollbackFor = {Exception.class})
-  public int createOrder(OrderCreateDto orderCreateDto, OrderActionEnum action) {
-    ProfileData profileData = new ProfileData(200);
-    try {
-      String description = transactionDescription.get(null, action);
-      int createdOrderId;
-      int outWalletId;
-      BigDecimal outAmount;
-      if (orderCreateDto.getOperationType() == OperationType.BUY) {
-        outWalletId = orderCreateDto.getWalletIdCurrencyConvert();
-        outAmount = orderCreateDto.getTotalWithComission();
-      } else {
-        outWalletId = orderCreateDto.getWalletIdCurrencyBase();
-        outAmount = orderCreateDto.getAmount();
-      }
-      if (walletService.ifEnoughMoney(outWalletId, outAmount)) {
-        profileData.setTime1();
-        ExOrder exOrder = new ExOrder(orderCreateDto);
-        OrderBaseType orderBaseType = orderCreateDto.getOrderBaseType();
-        if (orderBaseType == null) {
-          CurrencyPairType type = exOrder.getCurrencyPair().getPairType();
-          orderBaseType = type == CurrencyPairType.ICO ? OrderBaseType.ICO : OrderBaseType.LIMIT;
-          exOrder.setOrderBaseType(orderBaseType);
-        }
-        TransactionSourceType sourceType;
-        switch (orderBaseType) {
-          case STOP_LIMIT: {
-            createdOrderId = stopOrderService.createOrder(exOrder);
-            sourceType = TransactionSourceType.STOP_ORDER;
-            break;
-          }
-          case ICO: {
-            if (orderCreateDto.getOperationType() == OperationType.BUY) {
-              return 0;
-            }
-          }
-          default: {
-            createdOrderId = orderDao.createOrder(exOrder);
-            sourceType = TransactionSourceType.ORDER;
-          }
-        }
-        if (createdOrderId > 0) {
-          profileData.setTime2();
-          exOrder.setId(createdOrderId);
-          WalletTransferStatus result = walletService.walletInnerTransfer(
-                  outWalletId,
-                  outAmount.negate(),
-                  sourceType,
-                  exOrder.getId(),
-                  description);
-          profileData.setTime3();
-          if (result != WalletTransferStatus.SUCCESS) {
-            throw new OrderCreationException(result.toString());
-          }
-          setStatus(createdOrderId, OrderStatus.OPENED, exOrder.getOrderBaseType());
-          profileData.setTime4();
-        }
-        eventPublisher.publishEvent(new CreateOrderEvent(exOrder));
-        return createdOrderId;
+    @Override
+    @Transactional
+    public Integer createOrderByStopOrder(OrderCreateDto orderCreateDto, OrderActionEnum action, Locale locale) {
+        Optional<OrderCreationResultDto> autoAcceptResult = this.autoAcceptOrders(orderCreateDto, locale);
+        if (autoAcceptResult.isPresent()) {
+            logger.debug(autoAcceptResult.get());
+            return autoAcceptResult.get().getCreatedOrderId();
+        }
+        Integer orderId = this.createOrder(orderCreateDto, CREATE);
+        if (orderId <= 0) {
+            throw new NotCreatableOrderException(messageSource.getMessage("dberror.text", null, locale));
+        }
+        return orderId;
+    }
+
+
+    @Override
+    @Transactional(rollbackFor = {Exception.class})
+    public int createOrder(OrderCreateDto orderCreateDto, OrderActionEnum action) {
+        ProfileData profileData = new ProfileData(200);
+        try {
+            String description = transactionDescription.get(null, action);
+            int createdOrderId;
+            int outWalletId;
+            BigDecimal outAmount;
+            if (orderCreateDto.getOperationType() == OperationType.BUY) {
+                outWalletId = orderCreateDto.getWalletIdCurrencyConvert();
+                outAmount = orderCreateDto.getTotalWithComission();
+            } else {
+                outWalletId = orderCreateDto.getWalletIdCurrencyBase();
+                outAmount = orderCreateDto.getAmount();
+            }
+            if (walletService.ifEnoughMoney(outWalletId, outAmount)) {
+                profileData.setTime1();
+                ExOrder exOrder = new ExOrder(orderCreateDto);
+                OrderBaseType orderBaseType = orderCreateDto.getOrderBaseType();
+                if (orderBaseType == null) {
+                    CurrencyPairType type = exOrder.getCurrencyPair().getPairType();
+                    orderBaseType = type == CurrencyPairType.ICO ? OrderBaseType.ICO : OrderBaseType.LIMIT;
+                    exOrder.setOrderBaseType(orderBaseType);
+                }
+                TransactionSourceType sourceType;
+                switch (orderBaseType) {
+                    case STOP_LIMIT: {
+                        createdOrderId = stopOrderService.createOrder(exOrder);
+                        sourceType = TransactionSourceType.STOP_ORDER;
+                        break;
+                    }
+                    case ICO: {
+                        if (orderCreateDto.getOperationType() == OperationType.BUY) {
+                            return 0;
+                        }
+                    }
+                    default: {
+                        createdOrderId = orderDao.createOrder(exOrder);
+                        sourceType = TransactionSourceType.ORDER;
+                    }
+                }
+                if (createdOrderId > 0) {
+                    profileData.setTime2();
+                    exOrder.setId(createdOrderId);
+                    WalletTransferStatus result = walletService.walletInnerTransfer(
+                            outWalletId,
+                            outAmount.negate(),
+                            sourceType,
+                            exOrder.getId(),
+                            description);
+                    profileData.setTime3();
+                    if (result != WalletTransferStatus.SUCCESS) {
+                        throw new OrderCreationException(result.toString());
+                    }
+                    setStatus(createdOrderId, OrderStatus.OPENED, exOrder.getOrderBaseType());
+                    profileData.setTime4();
+                }
+                eventPublisher.publishEvent(new CreateOrderEvent(exOrder));
+                return createdOrderId;
 
-      } else {
-        //this exception will be caught in controller, populated  with message text  and thrown further
-        throw new NotEnoughUserWalletMoneyException("");
-      }
-    } finally {
-      profileData.checkAndLog("slow creation order: "+orderCreateDto+" profile: "+profileData);
-    }
-  }
+            } else {
+                //this exception will be caught in controller, populated  with message text  and thrown further
+                throw new NotEnoughUserWalletMoneyException("");
+            }
+        } finally {
+            profileData.checkAndLog("slow creation order: " + orderCreateDto + " profile: " + profileData);
+        }
+    }
 
-  @Override
-  @Transactional
-  public void postBotOrderToDb(OrderCreateDto orderCreateDto) {
-    ExOrder exOrder = new ExOrder(orderCreateDto);
-    exOrder.setUserAcceptorId(orderCreateDto.getUserId());
-    orderDao.postAcceptedOrderToDB(exOrder);
-    eventPublisher.publishEvent(new AcceptOrderEvent(exOrder));
-  }
+    @Override
+    @Transactional
+    public void postBotOrderToDb(OrderCreateDto orderCreateDto) {
+        ExOrder exOrder = new ExOrder(orderCreateDto);
+        exOrder.setUserAcceptorId(orderCreateDto.getUserId());
+        orderDao.postAcceptedOrderToDB(exOrder);
+        eventPublisher.publishEvent(new AcceptOrderEvent(exOrder));
+    }
 
 
-  @Override
-  @Transactional
-  public OrderCreateDto prepareOrderRest(OrderCreationParamsDto orderCreationParamsDto, String userEmail, Locale locale, OrderBaseType orderBaseType) {
-    CurrencyPair activeCurrencyPair = currencyService.findCurrencyPairById(orderCreationParamsDto.getCurrencyPairId());
-    OrderCreateDto orderCreateDto = prepareNewOrder(activeCurrencyPair, orderCreationParamsDto.getOrderType(),
-            userEmail, orderCreationParamsDto.getAmount(), orderCreationParamsDto.getRate(), orderBaseType);
-    log.debug("Order prepared" + orderCreateDto);
-    OrderValidationDto orderValidationDto = validateOrder(orderCreateDto);
-    Map<String, Object> errors = orderValidationDto.getErrors();
-    if (!errors.isEmpty()) {
-      errors.replaceAll((key, value) -> messageSource.getMessage(value.toString(), orderValidationDto.getErrorParams().get(key), locale));
-      throw new OrderParamsWrongException(errors.toString());
-    }
-    return orderCreateDto;
-  }
+    @Override
+    @Transactional
+    public OrderCreateDto prepareOrderRest(OrderCreationParamsDto parameters,
+                                           String userEmail,
+                                           Locale locale,
+                                           OrderBaseType baseType) {
+        final CurrencyPair activeCurrencyPair = currencyService.findCurrencyPairById(parameters.getCurrencyPairId());
+
+        final OrderCreateDto orderCreateDto = prepareNewOrder(activeCurrencyPair,
+                parameters.getOrderType(),
+                userEmail,
+                parameters.getAmount(),
+                parameters.getRate(),
+                baseType);
+
+        log.debug("Order prepared: {}", orderCreateDto);
+
+        OrderValidationDto orderValidationDto = validateOrder(orderCreateDto);
+        Map<String, Object> errors = orderValidationDto.getErrors();
+        if (!errors.isEmpty()) {
+            errors.replaceAll((key, value) -> messageSource.getMessage(value.toString(), orderValidationDto.getErrorParams().get(key), locale));
+            throw new OrderParamsWrongException(errors.toString());
+        }
+        return orderCreateDto;
+    }
 
 
-  @Override
-  @Transactional
-  public OrderCreationResultDto createPreparedOrderRest(OrderCreateDto orderCreateDto, Locale locale) {
-    Optional<OrderCreationResultDto> autoAcceptResult = autoAcceptOrders(orderCreateDto, locale);
-    log.info("Auto accept result: " + autoAcceptResult);
-    if (autoAcceptResult.isPresent()) {
-      return autoAcceptResult.get();
-    }
-    OrderCreationResultDto orderCreationResultDto = new OrderCreationResultDto();
+    @Override
+    @Transactional
+    public OrderCreationResultDto createPreparedOrderRest(OrderCreateDto orderCreateDto, Locale locale) {
+        Optional<OrderCreationResultDto> autoAcceptResult = autoAcceptOrders(orderCreateDto, locale);
+        log.info("Auto accept result: " + autoAcceptResult);
+        if (autoAcceptResult.isPresent()) {
+            return autoAcceptResult.get();
+        }
 
-    Integer createdOrderId = createOrder(orderCreateDto, CREATE);
-    if (createdOrderId <= 0) {
-      throw new NotCreatableOrderException(messageSource.getMessage("dberror.text", null, locale));
-    }
-    orderCreationResultDto.setCreatedOrderId(createdOrderId);
-    log.info("Order creation result result: " + autoAcceptResult);
-    return orderCreationResultDto;
-  }
+        final Integer createdOrderId = createOrder(orderCreateDto, CREATE);
+        if (createdOrderId <= 0) {
+            throw new NotCreatableOrderException(messageSource.getMessage("dberror.text", null, locale));
+        }
+        return OrderCreationResultDto.builder()
+                .createdOrderId(createdOrderId)
+                .build();
+    }
 
-
-  @Override
-  @Transactional
-  public OrderCreationResultDto prepareAndCreateOrderRest(String currencyPairName, OperationType orderType,
-                                                          BigDecimal amount, BigDecimal exrate, String userEmail) {
-      synchronized (restOrderCreationLock) {
-          log.info(String.format("Start creating order: %s %s amount %s rate %s", currencyPairName, orderType.name(), amount, exrate));
-          Locale locale = userService.getUserLocaleForMobile(userEmail);
-          CurrencyPair currencyPair = currencyService.getCurrencyPairByName(currencyPairName);
-          if (currencyPair.getPairType() != CurrencyPairType.MAIN) {
-            throw new NotCreatableOrderException("This pair available only through website");
-          }
-          OrderCreateDto orderCreateDto = prepareOrderRest(new OrderCreationParamsDto(currencyPair.getId(), orderType, amount, exrate), userEmail, locale, OrderBaseType.LIMIT);
-          return createPreparedOrderRest(orderCreateDto, locale);
-      }
-  }
+    @Transactional
+    @Override
+    public OrderCreationResultDto prepareAndCreateOrderRest(String currencyPairName,
+                                                            OperationType orderType,
+                                                            BigDecimal amount,
+                                                            BigDecimal exrate,
+                                                            String userEmail) {
+        synchronized (restOrderCreationLock) {
+            log.info("Start creating order: {} {} amount {} rate {}", currencyPairName, orderType.name(), amount, exrate);
+
+            final Locale locale = userService.getUserLocaleForMobile(userEmail);
+            final CurrencyPair currencyPair = currencyService.getCurrencyPairByName(currencyPairName);
+
+            if (currencyPair.getPairType() != CurrencyPairType.MAIN) {
+                throw new NotCreatableOrderException("This pair available only through website");
+            }
+            final OrderCreationParamsDto parameters = OrderCreationParamsDto.builder()
+                    .currencyPairId(currencyPair.getId())
+                    .orderType(orderType)
+                    .amount(amount)
+                    .rate(exrate)
+                    .build();
+            OrderCreateDto orderCreateDto = prepareOrderRest(parameters, userEmail, locale, OrderBaseType.LIMIT);
+            return createPreparedOrderRest(orderCreateDto, locale);
+        }
+    }
 
 
-  @Override
-  @Transactional(rollbackFor = {Exception.class})
-  public Optional<String> autoAccept(OrderCreateDto orderCreateDto, Locale locale) {
-    Optional<OrderCreationResultDto> autoAcceptResult = autoAcceptOrders(orderCreateDto, locale);
-    if (!autoAcceptResult.isPresent()) {
-      return Optional.empty();
-    }
-    OrderCreationResultDto orderCreationResultDto = autoAcceptResult.get();
-    StringBuilder successMessage = new StringBuilder("{\"result\":\"");
-    if (orderCreationResultDto.getAutoAcceptedQuantity() != null && orderCreationResultDto.getAutoAcceptedQuantity() > 0) {
-      successMessage.append(messageSource.getMessage("order.acceptsuccess",
-          new Integer[]{orderCreationResultDto.getAutoAcceptedQuantity()}, locale)).append("; ");
-    }
-    if (orderCreationResultDto.getPartiallyAcceptedAmount() != null) {
-      successMessage.append(messageSource.getMessage("orders.partialAccept.success", new Object[]{orderCreationResultDto.getPartiallyAcceptedAmount(),
-          orderCreationResultDto.getPartiallyAcceptedOrderFullAmount(), orderCreateDto.getCurrencyPair().getCurrency1().getName()}, locale));
-    }
-    if (orderCreationResultDto.getCreatedOrderId() != null) {
-      successMessage.append(messageSource.getMessage("createdorder.text", null, locale));
-    }
-    successMessage.append("\"}");
-    return Optional.of(successMessage.toString());
-  }
+    @Override
+    @Transactional(rollbackFor = {Exception.class})
+    public Optional<String> autoAccept(OrderCreateDto orderCreateDto, Locale locale) {
+        Optional<OrderCreationResultDto> autoAcceptResult = autoAcceptOrders(orderCreateDto, locale);
+        if (!autoAcceptResult.isPresent()) {
+            return Optional.empty();
+        }
+        OrderCreationResultDto orderCreationResultDto = autoAcceptResult.get();
+        StringBuilder successMessage = new StringBuilder("{\"result\":\"");
+        if (orderCreationResultDto.getAutoAcceptedQuantity() != null && orderCreationResultDto.getAutoAcceptedQuantity() > 0) {
+            successMessage.append(messageSource.getMessage("order.acceptsuccess",
+                    new Integer[]{orderCreationResultDto.getAutoAcceptedQuantity()}, locale)).append("; ");
+        }
+        if (orderCreationResultDto.getPartiallyAcceptedAmount() != null) {
+            successMessage.append(messageSource.getMessage("orders.partialAccept.success", new Object[]{orderCreationResultDto.getPartiallyAcceptedAmount(),
+                    orderCreationResultDto.getPartiallyAcceptedOrderFullAmount(), orderCreateDto.getCurrencyPair().getCurrency1().getName()}, locale));
+        }
+        if (orderCreationResultDto.getCreatedOrderId() != null) {
+            successMessage.append(messageSource.getMessage("createdorder.text", null, locale));
+        }
+        successMessage.append("\"}");
+        return Optional.of(successMessage.toString());
+    }
 
-  @Override
-  @Transactional(rollbackFor = Exception.class)
-  public Optional<OrderCreationResultDto> autoAcceptOrders(OrderCreateDto orderCreateDto, Locale locale) {
-      synchronized (autoAcceptLock) {
-          ProfileData profileData = new ProfileData(200);
-          try {
-              boolean acceptSameRoleOnly = userRoleService.isOrderAcceptionAllowedForUser(orderCreateDto.getUserId());
-              List<ExOrder> acceptableOrders = orderDao.selectTopOrders(orderCreateDto.getCurrencyPair().getId(), orderCreateDto.getExchangeRate(),
-                      OperationType.getOpposite(orderCreateDto.getOperationType()), acceptSameRoleOnly, userService.getUserRoleFromDB(orderCreateDto.getUserId()).getRole(), orderCreateDto.getOrderBaseType());
-              profileData.setTime1();
-              logger.debug("acceptableOrders - " + OperationType.getOpposite(orderCreateDto.getOperationType()) + " : " + acceptableOrders);
-              if (acceptableOrders.isEmpty()) {
-                  return Optional.empty();
-              }
-              BigDecimal cumulativeSum = BigDecimal.ZERO;
-              List<ExOrder> ordersForAccept = new ArrayList<>();
-              ExOrder orderForPartialAccept = null;
-              for (ExOrder order : acceptableOrders) {
-                  cumulativeSum = cumulativeSum.add(order.getAmountBase());
-                  if (orderCreateDto.getAmount().compareTo(cumulativeSum) > 0) {
-                      ordersForAccept.add(order);
-                  } else if (orderCreateDto.getAmount().compareTo(cumulativeSum) == 0) {
-                      ordersForAccept.add(order);
-                      break;
-                  } else {
-                      orderForPartialAccept = order;
-                      break;
-                  }
-              }
-              OrderCreationResultDto orderCreationResultDto = new OrderCreationResultDto();
+    @Override
+    @Transactional(rollbackFor = Exception.class)
+    public Optional<OrderCreationResultDto> autoAcceptOrders(OrderCreateDto orderCreateDto, Locale locale) {
+        synchronized (autoAcceptLock) {
+            ProfileData profileData = new ProfileData(200);
+            try {
+                boolean acceptSameRoleOnly = userRoleService.isOrderAcceptionAllowedForUser(orderCreateDto.getUserId());
+                List<ExOrder> acceptableOrders = orderDao.selectTopOrders(orderCreateDto.getCurrencyPair().getId(), orderCreateDto.getExchangeRate(),
+                        OperationType.getOpposite(orderCreateDto.getOperationType()), acceptSameRoleOnly, userService.getUserRoleFromDB(orderCreateDto.getUserId()).getCode(), orderCreateDto.getOrderBaseType());
+                profileData.setTime1();
+                logger.debug("acceptableOrders - " + OperationType.getOpposite(orderCreateDto.getOperationType()) + " : " + acceptableOrders);
+                if (acceptableOrders.isEmpty()) {
+                    return Optional.empty();
+                }
+                BigDecimal cumulativeSum = BigDecimal.ZERO;
+                List<ExOrder> ordersForAccept = new ArrayList<>();
+                ExOrder orderForPartialAccept = null;
+                for (ExOrder order : acceptableOrders) {
+                    cumulativeSum = cumulativeSum.add(order.getAmountBase());
+                    if (orderCreateDto.getAmount().compareTo(cumulativeSum) > 0) {
+                        ordersForAccept.add(order);
+                    } else if (orderCreateDto.getAmount().compareTo(cumulativeSum) == 0) {
+                        ordersForAccept.add(order);
+                        break;
+                    } else {
+                        orderForPartialAccept = order;
+                        break;
+                    }
+                }
+                OrderCreationResultDto.Builder builder = OrderCreationResultDto.builder();
 
-              if (ordersForAccept.size() > 0) {
-                  acceptOrdersList(orderCreateDto.getUserId(), ordersForAccept.stream().map(ExOrder::getId).collect(toList()), locale);
-                  orderCreationResultDto.setAutoAcceptedQuantity(ordersForAccept.size());
-              }
-              if (orderForPartialAccept != null) {
-                  BigDecimal partialAcceptResult = acceptPartially(orderCreateDto, orderForPartialAccept, cumulativeSum, locale);
-                  orderCreationResultDto.setPartiallyAcceptedAmount(partialAcceptResult);
-                  orderCreationResultDto.setPartiallyAcceptedOrderFullAmount(orderForPartialAccept.getAmountBase());
-              } else if (orderCreateDto.getAmount().compareTo(cumulativeSum) > 0 && orderCreateDto.getOrderBaseType() != OrderBaseType.ICO) {
-                  User user = userService.getUserById(orderCreateDto.getUserId());
-                  profileData.setTime2();
-                  OrderCreateDto remainderNew = prepareNewOrder(
-                          orderCreateDto.getCurrencyPair(),
-                          orderCreateDto.getOperationType(),
-                          user.getEmail(),
-                          orderCreateDto.getAmount().subtract(cumulativeSum),
-                          orderCreateDto.getExchangeRate(),
-                          orderCreateDto.getOrderBaseType());
-                  profileData.setTime3();
-                  Integer createdOrderId = createOrder(remainderNew, CREATE);
-                  profileData.setTime4();
-                  orderCreationResultDto.setCreatedOrderId(createdOrderId);
-              }
-              return Optional.of(orderCreationResultDto);
-          } finally {
-              profileData.checkAndLog("slow creation order: " + orderCreateDto + " profile: " + profileData);
-          }
-      }
+                if (ordersForAccept.size() > 0) {
+                    acceptOrdersList(orderCreateDto.getUserId(), ordersForAccept.stream().map(ExOrder::getId).collect(toList()), locale);
+                    builder.autoAcceptedQuantity(ordersForAccept.size());
+                }
+                if (orderForPartialAccept != null) {
+                    BigDecimal partialAcceptResult = acceptPartially(orderCreateDto, orderForPartialAccept, cumulativeSum, locale);
+                    builder.partiallyAcceptedAmount(partialAcceptResult);
+                    builder.partiallyAcceptedOrderFullAmount(orderForPartialAccept.getAmountBase());
+                } else if (orderCreateDto.getAmount().compareTo(cumulativeSum) > 0 && orderCreateDto.getOrderBaseType() != OrderBaseType.ICO) {
+                    User user = userService.getUserById(orderCreateDto.getUserId());
+                    profileData.setTime2();
+                    OrderCreateDto remainderNew = prepareNewOrder(
+                            orderCreateDto.getCurrencyPair(),
+                            orderCreateDto.getOperationType(),
+                            user.getEmail(),
+                            orderCreateDto.getAmount().subtract(cumulativeSum),
+                            orderCreateDto.getExchangeRate(),
+                            orderCreateDto.getOrderBaseType());
+                    profileData.setTime3();
+                    Integer createdOrderId = createOrder(remainderNew, CREATE);
+                    profileData.setTime4();
+                    builder.createdOrderId(createdOrderId);
+                }
+                return Optional.of(builder.build());
+            } finally {
+                profileData.checkAndLog("slow creation order: " + orderCreateDto + " profile: " + profileData);
+            }
+        }
 
-  }
+    }
 
 
-  private BigDecimal acceptPartially(OrderCreateDto newOrder, ExOrder orderForPartialAccept, BigDecimal cumulativeSum, Locale locale) {
-    deleteOrderForPartialAccept(orderForPartialAccept.getId());
-    BigDecimal amountForPartialAccept = newOrder.getAmount().subtract(cumulativeSum.subtract(orderForPartialAccept.getAmountBase()));
-    OrderCreateDto accepted = prepareNewOrder(newOrder.getCurrencyPair(), orderForPartialAccept.getOperationType(),
-        userService.getUserById(orderForPartialAccept.getUserId()).getEmail(), amountForPartialAccept,
-        orderForPartialAccept.getExRate(), orderForPartialAccept.getId(), newOrder.getOrderBaseType());
-    OrderCreateDto remainder = prepareNewOrder(newOrder.getCurrencyPair(), orderForPartialAccept.getOperationType(),
-        userService.getUserById(orderForPartialAccept.getUserId()).getEmail(), orderForPartialAccept.getAmountBase().subtract(amountForPartialAccept),
-        orderForPartialAccept.getExRate(), orderForPartialAccept.getId(), newOrder.getOrderBaseType());
-    int acceptedId = createOrder(accepted, CREATE);
-    createOrder(remainder, CREATE_SPLIT);
-    acceptOrder(newOrder.getUserId(), acceptedId, locale, false);
+    private BigDecimal acceptPartially(OrderCreateDto newOrder, ExOrder orderForPartialAccept, BigDecimal cumulativeSum, Locale locale) {
+        deleteOrderForPartialAccept(orderForPartialAccept.getId());
+        BigDecimal amountForPartialAccept = newOrder.getAmount().subtract(cumulativeSum.subtract(orderForPartialAccept.getAmountBase()));
+        OrderCreateDto accepted = prepareNewOrder(newOrder.getCurrencyPair(), orderForPartialAccept.getOperationType(),
+                userService.getUserById(orderForPartialAccept.getUserId()).getEmail(), amountForPartialAccept,
+                orderForPartialAccept.getExRate(), orderForPartialAccept.getId(), newOrder.getOrderBaseType());
+        OrderCreateDto remainder = prepareNewOrder(newOrder.getCurrencyPair(), orderForPartialAccept.getOperationType(),
+                userService.getUserById(orderForPartialAccept.getUserId()).getEmail(), orderForPartialAccept.getAmountBase().subtract(amountForPartialAccept),
+                orderForPartialAccept.getExRate(), orderForPartialAccept.getId(), newOrder.getOrderBaseType());
+        int acceptedId = createOrder(accepted, CREATE);
+        createOrder(remainder, CREATE_SPLIT);
+        acceptOrder(newOrder.getUserId(), acceptedId, locale, false);
    /* TODO temporary disable
     notificationService.createLocalizedNotification(orderForPartialAccept.getUserId(), NotificationEvent.ORDER,
         "orders.partialAccept.title", "orders.partialAccept.yourOrder",
         new Object[]{orderForPartialAccept.getId(), amountForPartialAccept.toString(),
             orderForPartialAccept.getAmountBase().toString(), newOrder.getCurrencyPair().getCurrency1().getName()});*/
-    return amountForPartialAccept;
-  }
+        return amountForPartialAccept;
+    }
 
 
-  @Override
-  public List<OrderWideListDto> getMyOrdersWithState(CacheData cacheData,
-                                                     String email, CurrencyPair currencyPair, OrderStatus status,
-                                                     OperationType operationType,
-                                                     String scope, Integer offset, Integer limit, Locale locale) {
-    List<OrderWideListDto> result = orderDao.getMyOrdersWithState(userService.getIdByEmail(email), currencyPair, status, operationType, scope, offset, limit, locale);
-    if (Cache.checkCache(cacheData, result)) {
-      result = new ArrayList<OrderWideListDto>() {{
-        add(new OrderWideListDto(false));
-      }};
-    }
-    return result;
-  }
+    @Override
+    public List<OrderWideListDto> getMyOrdersWithState(CacheData cacheData,
+                                                       String email, CurrencyPair currencyPair, OrderStatus status,
+                                                       OperationType operationType,
+                                                       String scope, Integer offset, Integer limit, Locale locale) {
+        List<OrderWideListDto> result = orderDao.getMyOrdersWithState(userService.getIdByEmail(email), currencyPair, status, operationType, scope, offset, limit, locale);
+        if (Cache.checkCache(cacheData, result)) {
+            result = new ArrayList<OrderWideListDto>() {{
+                add(new OrderWideListDto(false));
+            }};
+        }
+        return result;
+    }
 
-  @Override
-  public OrderCreateDto getMyOrderById(int orderId) {
-    return orderDao.getMyOrderById(orderId);
-  }
+    @Override
+    public OrderCreateDto getMyOrderById(int orderId) {
+        return orderDao.getMyOrderById(orderId);
+    }
 
-  @Transactional(readOnly = true)
-  public ExOrder getOrderById(int orderId) {
-    return orderDao.getOrderById(orderId);
-  }
+    @Transactional(readOnly = true)
+    public ExOrder getOrderById(int orderId) {
+        return orderDao.getOrderById(orderId);
+    }
 
-  @Transactional
-  public boolean setStatus(int orderId, OrderStatus status, OrderBaseType orderBaseType) {
-    switch (orderBaseType) {
-      case STOP_LIMIT: {
-        return stopOrderService.setStatus(orderId, status);
-      }
-      default: {
-        return this.setStatus(orderId, status);
-      }
-    }
-  }
+    @Transactional
+    public boolean setStatus(int orderId, OrderStatus status, OrderBaseType orderBaseType) {
+        switch (orderBaseType) {
+            case STOP_LIMIT: {
+                return stopOrderService.setStatus(orderId, status);
+            }
+            default: {
+                return this.setStatus(orderId, status);
+            }
+        }
+    }
 
-  @Transactional(propagation = Propagation.NESTED)
-  public boolean setStatus(int orderId, OrderStatus status) {
-    return orderDao.setStatus(orderId, status);
-  }
+    @Transactional(propagation = Propagation.NESTED)
+    public boolean setStatus(int orderId, OrderStatus status) {
+        return orderDao.setStatus(orderId, status);
+    }
 
 
-  @Override
-  @Transactional
-  public void acceptOrder(String userEmail, Integer orderId) {
-    Locale locale = userService.getUserLocaleForMobile(userEmail);
-    Integer userId = userService.getIdByEmail(userEmail);
-    acceptOrdersList(userId, Collections.singletonList(orderId), locale);
-  }
+    @Override
+    @Transactional
+    public void acceptOrder(String userEmail, Integer orderId) {
+        Locale locale = userService.getUserLocaleForMobile(userEmail);
+        Integer userId = userService.getIdByEmail(userEmail);
+        acceptOrdersList(userId, Collections.singletonList(orderId), locale);
+    }
 
-  @Transactional(rollbackFor = {Exception.class})
-  public void acceptOrdersList(int userAcceptorId, List<Integer> ordersList, Locale locale) {
-    if (orderDao.lockOrdersListForAcception(ordersList)) {
-      for (Integer orderId : ordersList) {
-        acceptOrder(userAcceptorId, orderId, locale);
-      }
-    } else {
-      throw new OrderAcceptionException(messageSource.getMessage("order.lockerror", null, locale));
-    }
-  }
+    @Transactional(rollbackFor = {Exception.class})
+    public void acceptOrdersList(int userAcceptorId, List<Integer> ordersList, Locale locale) {
+        if (orderDao.lockOrdersListForAcception(ordersList)) {
+            for (Integer orderId : ordersList) {
+                acceptOrder(userAcceptorId, orderId, locale);
+            }
+        } else {
+            throw new OrderAcceptionException(messageSource.getMessage("order.lockerror", null, locale));
+        }
+    }
 
-  @Transactional(rollbackFor = {Exception.class})
-  void acceptOrder(int userAcceptorId, int orderId, Locale locale) {
-    acceptOrder(userAcceptorId, orderId, locale, true);
+    @Transactional(rollbackFor = {Exception.class})
+    void acceptOrder(int userAcceptorId, int orderId, Locale locale) {
+        acceptOrder(userAcceptorId, orderId, locale, true);
 
-  }
-  
-  @Override
-  @Transactional(rollbackFor = {Exception.class})
-  public void acceptOrderByAdmin(String acceptorEmail, Integer orderId, Locale locale) {
-    Integer userId = userService.getIdByEmail(acceptorEmail);
-    acceptOrdersList(userId, Collections.singletonList(orderId), locale);
-  }
+    }
+
+    @Override
+    @Transactional(rollbackFor = {Exception.class})
+    public void acceptOrderByAdmin(String acceptorEmail, Integer orderId, Locale locale) {
+        Integer userId = userService.getIdByEmail(acceptorEmail);
+        acceptOrdersList(userId, Collections.singletonList(orderId), locale);
+    }
 
 
-  @Override
-  @Transactional(rollbackFor = {Exception.class})
-  public void acceptManyOrdersByAdmin(String acceptorEmail, List<Integer> orderIds, Locale locale) {
-    Integer userId = userService.getIdByEmail(acceptorEmail);
-    acceptOrdersList(userId, orderIds, locale);
-  }
+    @Override
+    @Transactional(rollbackFor = {Exception.class})
+    public void acceptManyOrdersByAdmin(String acceptorEmail, List<Integer> orderIds, Locale locale) {
+        Integer userId = userService.getIdByEmail(acceptorEmail);
+        acceptOrdersList(userId, orderIds, locale);
+    }
 
 
-  private void acceptOrder(int userAcceptorId, int orderId, Locale locale, boolean sendNotification) {
-    try {
-      ExOrder exOrder = this.getOrderById(orderId);
+    private void acceptOrder(int userAcceptorId, int orderId, Locale locale, boolean sendNotification) {
+        try {
+            ExOrder exOrder = this.getOrderById(orderId);
 
-      checkAcceptPermissionForUser(userAcceptorId, exOrder.getUserId(), locale);
+            checkAcceptPermissionForUser(userAcceptorId, exOrder.getUserId(), locale);
 
-      WalletsForOrderAcceptionDto walletsForOrderAcceptionDto = walletService.getWalletsForOrderByOrderIdAndBlock(exOrder.getId(), userAcceptorId);
-      String descriptionForCreator = transactionDescription.get(OrderStatus.convert(walletsForOrderAcceptionDto.getOrderStatusId()), ACCEPTED);
-      String descriptionForAcceptor = transactionDescription.get(OrderStatus.convert(walletsForOrderAcceptionDto.getOrderStatusId()), ACCEPT);
-      /**/
-      if (walletsForOrderAcceptionDto.getOrderStatusId() != 2) {
-        throw new AlreadyAcceptedOrderException(messageSource.getMessage("order.alreadyacceptederror", null, locale));
-      }
-      /**/
-      int createdWalletId;
-      if (exOrder.getOperationType() == OperationType.BUY) {
-        if (walletsForOrderAcceptionDto.getUserCreatorInWalletId() == 0) {
-          createdWalletId = walletService.createNewWallet(new Wallet(walletsForOrderAcceptionDto.getCurrencyBase(), userService.getUserById(exOrder.getUserId()), new BigDecimal(0)));
-          if (createdWalletId == 0) {
-            throw new WalletCreationException(messageSource.getMessage("order.createwalleterror", new Object[]{exOrder.getUserId()}, locale));
-          }
-          walletsForOrderAcceptionDto.setUserCreatorInWalletId(createdWalletId);
-        }
-        if (walletsForOrderAcceptionDto.getUserAcceptorInWalletId() == 0) {
-          createdWalletId = walletService.createNewWallet(new Wallet(walletsForOrderAcceptionDto.getCurrencyConvert(), userService.getUserById(userAcceptorId), new BigDecimal(0)));
-          if (createdWalletId == 0) {
-            throw new WalletCreationException(messageSource.getMessage("order.createwalleterror", new Object[]{userAcceptorId}, locale));
-          }
-          walletsForOrderAcceptionDto.setUserAcceptorInWalletId(createdWalletId);
-        }
-      }
-      if (exOrder.getOperationType() == OperationType.SELL) {
-        if (walletsForOrderAcceptionDto.getUserCreatorInWalletId() == 0) {
-          createdWalletId = walletService.createNewWallet(new Wallet(walletsForOrderAcceptionDto.getCurrencyConvert(), userService.getUserById(exOrder.getUserId()), new BigDecimal(0)));
-          if (createdWalletId == 0) {
-            throw new WalletCreationException(messageSource.getMessage("order.createwalleterror", new Object[]{exOrder.getUserId()}, locale));
-          }
-          walletsForOrderAcceptionDto.setUserCreatorInWalletId(createdWalletId);
-        }
-        if (walletsForOrderAcceptionDto.getUserAcceptorInWalletId() == 0) {
-          createdWalletId = walletService.createNewWallet(new Wallet(walletsForOrderAcceptionDto.getCurrencyBase(), userService.getUserById(userAcceptorId), new BigDecimal(0)));
-          if (createdWalletId == 0) {
-            throw new WalletCreationException(messageSource.getMessage("order.createwalleterror", new Object[]{userAcceptorId}, locale));
-          }
-          walletsForOrderAcceptionDto.setUserAcceptorInWalletId(createdWalletId);
-        }
-      }
+            WalletsForOrderAcceptionDto walletsForOrderAcceptionDto = walletService.getWalletsForOrderByOrderIdAndBlock(exOrder.getId(), userAcceptorId);
+            String descriptionForCreator = transactionDescription.get(OrderStatus.convert(walletsForOrderAcceptionDto.getOrderStatusId()), ACCEPTED);
+            String descriptionForAcceptor = transactionDescription.get(OrderStatus.convert(walletsForOrderAcceptionDto.getOrderStatusId()), ACCEPT);
+            /**/
+            if (walletsForOrderAcceptionDto.getOrderStatusId() != 2) {
+                throw new AlreadyAcceptedOrderException(messageSource.getMessage("order.alreadyacceptederror", null, locale));
+            }
+            /**/
+            int createdWalletId;
+            if (exOrder.getOperationType() == OperationType.BUY) {
+                if (walletsForOrderAcceptionDto.getUserCreatorInWalletId() == 0) {
+                    createdWalletId = walletService.createNewWallet(new Wallet(walletsForOrderAcceptionDto.getCurrencyBase(), userService.getUserById(exOrder.getUserId()), new BigDecimal(0)));
+                    if (createdWalletId == 0) {
+                        throw new WalletCreationException(messageSource.getMessage("order.createwalleterror", new Object[]{exOrder.getUserId()}, locale));
+                    }
+                    walletsForOrderAcceptionDto.setUserCreatorInWalletId(createdWalletId);
+                }
+                if (walletsForOrderAcceptionDto.getUserAcceptorInWalletId() == 0) {
+                    createdWalletId = walletService.createNewWallet(new Wallet(walletsForOrderAcceptionDto.getCurrencyConvert(), userService.getUserById(userAcceptorId), new BigDecimal(0)));
+                    if (createdWalletId == 0) {
+                        throw new WalletCreationException(messageSource.getMessage("order.createwalleterror", new Object[]{userAcceptorId}, locale));
+                    }
+                    walletsForOrderAcceptionDto.setUserAcceptorInWalletId(createdWalletId);
+                }
+            }
+            if (exOrder.getOperationType() == OperationType.SELL) {
+                if (walletsForOrderAcceptionDto.getUserCreatorInWalletId() == 0) {
+                    createdWalletId = walletService.createNewWallet(new Wallet(walletsForOrderAcceptionDto.getCurrencyConvert(), userService.getUserById(exOrder.getUserId()), new BigDecimal(0)));
+                    if (createdWalletId == 0) {
+                        throw new WalletCreationException(messageSource.getMessage("order.createwalleterror", new Object[]{exOrder.getUserId()}, locale));
+                    }
+                    walletsForOrderAcceptionDto.setUserCreatorInWalletId(createdWalletId);
+                }
+                if (walletsForOrderAcceptionDto.getUserAcceptorInWalletId() == 0) {
+                    createdWalletId = walletService.createNewWallet(new Wallet(walletsForOrderAcceptionDto.getCurrencyBase(), userService.getUserById(userAcceptorId), new BigDecimal(0)));
+                    if (createdWalletId == 0) {
+                        throw new WalletCreationException(messageSource.getMessage("order.createwalleterror", new Object[]{userAcceptorId}, locale));
+                    }
+                    walletsForOrderAcceptionDto.setUserAcceptorInWalletId(createdWalletId);
+                }
+            }
             /**/
             /*calculate convert currency amount for creator - simply take stored amount from order*/
-      BigDecimal amountWithComissionForCreator = getAmountWithComissionForCreator(exOrder);
-      Commission comissionForCreator = new Commission();
-      comissionForCreator.setId(exOrder.getComissionId());
+            BigDecimal amountWithComissionForCreator = getAmountWithComissionForCreator(exOrder);
+            Commission comissionForCreator = new Commission();
+            comissionForCreator.setId(exOrder.getComissionId());
             /*calculate convert currency amount for acceptor - calculate at the current commission rate*/
-      OperationType operationTypeForAcceptor = exOrder.getOperationType() == OperationType.BUY ? OperationType.SELL : OperationType.BUY;
-      Commission comissionForAcceptor = commissionDao.getCommission(operationTypeForAcceptor, userService.getUserRoleFromDB(userAcceptorId));
-      BigDecimal comissionRateForAcceptor = comissionForAcceptor.getValue();
-      BigDecimal amountComissionForAcceptor = BigDecimalProcessing.doAction(exOrder.getAmountConvert(), comissionRateForAcceptor, ActionType.MULTIPLY_PERCENT);
-      BigDecimal amountWithComissionForAcceptor;
-      if (exOrder.getOperationType() == OperationType.BUY) {
-        amountWithComissionForAcceptor = BigDecimalProcessing.doAction(exOrder.getAmountConvert(), amountComissionForAcceptor, ActionType.SUBTRACT);
-      } else {
-        amountWithComissionForAcceptor = BigDecimalProcessing.doAction(exOrder.getAmountConvert(), amountComissionForAcceptor, ActionType.ADD);
-      }
+            OperationType operationTypeForAcceptor = exOrder.getOperationType() == OperationType.BUY ? OperationType.SELL : OperationType.BUY;
+            Commission comissionForAcceptor = commissionDao.getCommission(operationTypeForAcceptor, userService.getUserRoleFromDB(userAcceptorId));
+            BigDecimal comissionRateForAcceptor = comissionForAcceptor.getValue();
+            BigDecimal amountComissionForAcceptor = BigDecimalProcessing.doAction(exOrder.getAmountConvert(), comissionRateForAcceptor, ActionType.MULTIPLY_PERCENT);
+            BigDecimal amountWithComissionForAcceptor;
+            if (exOrder.getOperationType() == OperationType.BUY) {
+                amountWithComissionForAcceptor = BigDecimalProcessing.doAction(exOrder.getAmountConvert(), amountComissionForAcceptor, ActionType.SUBTRACT);
+            } else {
+                amountWithComissionForAcceptor = BigDecimalProcessing.doAction(exOrder.getAmountConvert(), amountComissionForAcceptor, ActionType.ADD);
+            }
             /*determine the IN and OUT amounts for creator and acceptor*/
-      BigDecimal creatorForOutAmount = null;
-      BigDecimal creatorForInAmount = null;
-      BigDecimal acceptorForOutAmount = null;
-      BigDecimal acceptorForInAmount = null;
-      BigDecimal commissionForCreatorOutWallet = null;
-      BigDecimal commissionForCreatorInWallet = null;
-      BigDecimal commissionForAcceptorOutWallet = null;
-      BigDecimal commissionForAcceptorInWallet = null;
-      if (exOrder.getOperationType() == OperationType.BUY) {
-        commissionForCreatorOutWallet = exOrder.getCommissionFixedAmount();
-        commissionForCreatorInWallet = BigDecimal.ZERO;
-        commissionForAcceptorOutWallet = BigDecimal.ZERO;
-        commissionForAcceptorInWallet = amountComissionForAcceptor;
+            BigDecimal creatorForOutAmount = null;
+            BigDecimal creatorForInAmount = null;
+            BigDecimal acceptorForOutAmount = null;
+            BigDecimal acceptorForInAmount = null;
+            BigDecimal commissionForCreatorOutWallet = null;
+            BigDecimal commissionForCreatorInWallet = null;
+            BigDecimal commissionForAcceptorOutWallet = null;
+            BigDecimal commissionForAcceptorInWallet = null;
+            if (exOrder.getOperationType() == OperationType.BUY) {
+                commissionForCreatorOutWallet = exOrder.getCommissionFixedAmount();
+                commissionForCreatorInWallet = BigDecimal.ZERO;
+                commissionForAcceptorOutWallet = BigDecimal.ZERO;
+                commissionForAcceptorInWallet = amountComissionForAcceptor;
                 /**/
-        creatorForOutAmount = amountWithComissionForCreator;
-        creatorForInAmount = exOrder.getAmountBase();
-        acceptorForOutAmount = exOrder.getAmountBase();
-        acceptorForInAmount = amountWithComissionForAcceptor;
-      }
-      if (exOrder.getOperationType() == OperationType.SELL) {
-        commissionForCreatorOutWallet = BigDecimal.ZERO;
-        commissionForCreatorInWallet = exOrder.getCommissionFixedAmount();
-        commissionForAcceptorOutWallet = amountComissionForAcceptor;
-        commissionForAcceptorInWallet = BigDecimal.ZERO;
+                creatorForOutAmount = amountWithComissionForCreator;
+                creatorForInAmount = exOrder.getAmountBase();
+                acceptorForOutAmount = exOrder.getAmountBase();
+                acceptorForInAmount = amountWithComissionForAcceptor;
+            }
+            if (exOrder.getOperationType() == OperationType.SELL) {
+                commissionForCreatorOutWallet = BigDecimal.ZERO;
+                commissionForCreatorInWallet = exOrder.getCommissionFixedAmount();
+                commissionForAcceptorOutWallet = amountComissionForAcceptor;
+                commissionForAcceptorInWallet = BigDecimal.ZERO;
                 /**/
-        creatorForOutAmount = exOrder.getAmountBase();
-        creatorForInAmount = amountWithComissionForCreator;
-        acceptorForOutAmount = amountWithComissionForAcceptor;
-        acceptorForInAmount = exOrder.getAmountBase();
-      }
-      WalletOperationData walletOperationData;
-      WalletTransferStatus walletTransferStatus;
-      String exceptionMessage = "";
+                creatorForOutAmount = exOrder.getAmountBase();
+                creatorForInAmount = amountWithComissionForCreator;
+                acceptorForOutAmount = amountWithComissionForAcceptor;
+                acceptorForInAmount = exOrder.getAmountBase();
+            }
+            WalletOperationData walletOperationData;
+            WalletTransferStatus walletTransferStatus;
+            String exceptionMessage = "";
             /**/
             /*for creator OUT*/
-      walletOperationData = new WalletOperationData();
-      walletService.walletInnerTransfer(
-          walletsForOrderAcceptionDto.getUserCreatorOutWalletId(),
-          creatorForOutAmount,
-          TransactionSourceType.ORDER,
-          exOrder.getId(),
-          descriptionForCreator);
-      walletOperationData.setOperationType(OperationType.OUTPUT);
-      walletOperationData.setWalletId(walletsForOrderAcceptionDto.getUserCreatorOutWalletId());
-      walletOperationData.setAmount(creatorForOutAmount);
-      walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
-      walletOperationData.setCommission(comissionForCreator);
-      walletOperationData.setCommissionAmount(commissionForCreatorOutWallet);
-      walletOperationData.setSourceType(TransactionSourceType.ORDER);
-      walletOperationData.setSourceId(exOrder.getId());
-      walletOperationData.setDescription(descriptionForCreator);
-      walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
-      if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
-        exceptionMessage = getWalletTransferExceptionMessage(walletTransferStatus, "order.notenoughreservedmoneyforcreator", locale);
-        if (walletTransferStatus == WalletTransferStatus.CAUSED_NEGATIVE_BALANCE) {
-          throw new InsufficientCostsForAcceptionException(exceptionMessage);
-        }
-        throw new OrderAcceptionException(exceptionMessage);
-      }
-             /*for acceptor OUT*/
-      walletOperationData = new WalletOperationData();
-      walletOperationData.setOperationType(OperationType.OUTPUT);
-      walletOperationData.setWalletId(walletsForOrderAcceptionDto.getUserAcceptorOutWalletId());
-      walletOperationData.setAmount(acceptorForOutAmount);
-      walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
-      walletOperationData.setCommission(comissionForAcceptor);
-      walletOperationData.setCommissionAmount(commissionForAcceptorOutWallet);
-      walletOperationData.setSourceType(TransactionSourceType.ORDER);
-      walletOperationData.setSourceId(exOrder.getId());
-      walletOperationData.setDescription(descriptionForAcceptor);
-      walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
-      if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
-        exceptionMessage = getWalletTransferExceptionMessage(walletTransferStatus, "order.notenoughmoneyforacceptor", locale);
-        if (walletTransferStatus == WalletTransferStatus.CAUSED_NEGATIVE_BALANCE) {
-          throw new InsufficientCostsForAcceptionException(exceptionMessage);
-        }
-        throw new OrderAcceptionException(exceptionMessage);
-      }
+            walletOperationData = new WalletOperationData();
+            walletService.walletInnerTransfer(
+                    walletsForOrderAcceptionDto.getUserCreatorOutWalletId(),
+                    creatorForOutAmount,
+                    TransactionSourceType.ORDER,
+                    exOrder.getId(),
+                    descriptionForCreator);
+            walletOperationData.setOperationType(OperationType.OUTPUT);
+            walletOperationData.setWalletId(walletsForOrderAcceptionDto.getUserCreatorOutWalletId());
+            walletOperationData.setAmount(creatorForOutAmount);
+            walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
+            walletOperationData.setCommission(comissionForCreator);
+            walletOperationData.setCommissionAmount(commissionForCreatorOutWallet);
+            walletOperationData.setSourceType(TransactionSourceType.ORDER);
+            walletOperationData.setSourceId(exOrder.getId());
+            walletOperationData.setDescription(descriptionForCreator);
+            walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
+            if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
+                exceptionMessage = getWalletTransferExceptionMessage(walletTransferStatus, "order.notenoughreservedmoneyforcreator", locale);
+                if (walletTransferStatus == WalletTransferStatus.CAUSED_NEGATIVE_BALANCE) {
+                    throw new InsufficientCostsForAcceptionException(exceptionMessage);
+                }
+                throw new OrderAcceptionException(exceptionMessage);
+            }
+            /*for acceptor OUT*/
+            walletOperationData = new WalletOperationData();
+            walletOperationData.setOperationType(OperationType.OUTPUT);
+            walletOperationData.setWalletId(walletsForOrderAcceptionDto.getUserAcceptorOutWalletId());
+            walletOperationData.setAmount(acceptorForOutAmount);
+            walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
+            walletOperationData.setCommission(comissionForAcceptor);
+            walletOperationData.setCommissionAmount(commissionForAcceptorOutWallet);
+            walletOperationData.setSourceType(TransactionSourceType.ORDER);
+            walletOperationData.setSourceId(exOrder.getId());
+            walletOperationData.setDescription(descriptionForAcceptor);
+            walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
+            if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
+                exceptionMessage = getWalletTransferExceptionMessage(walletTransferStatus, "order.notenoughmoneyforacceptor", locale);
+                if (walletTransferStatus == WalletTransferStatus.CAUSED_NEGATIVE_BALANCE) {
+                    throw new InsufficientCostsForAcceptionException(exceptionMessage);
+                }
+                throw new OrderAcceptionException(exceptionMessage);
+            }
             /*for creator IN*/
-      walletOperationData = new WalletOperationData();
-      walletOperationData.setOperationType(OperationType.INPUT);
-      walletOperationData.setWalletId(walletsForOrderAcceptionDto.getUserCreatorInWalletId());
-      walletOperationData.setAmount(creatorForInAmount);
-      walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
-      walletOperationData.setCommission(comissionForCreator);
-      walletOperationData.setCommissionAmount(commissionForCreatorInWallet);
-      walletOperationData.setSourceType(TransactionSourceType.ORDER);
-      walletOperationData.setSourceId(exOrder.getId());
-      walletOperationData.setDescription(descriptionForCreator);
-      walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
-      if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
-        exceptionMessage = getWalletTransferExceptionMessage(walletTransferStatus, "orders.acceptsaveerror", locale);
-        throw new OrderAcceptionException(exceptionMessage);
-      }
+            walletOperationData = new WalletOperationData();
+            walletOperationData.setOperationType(OperationType.INPUT);
+            walletOperationData.setWalletId(walletsForOrderAcceptionDto.getUserCreatorInWalletId());
+            walletOperationData.setAmount(creatorForInAmount);
+            walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
+            walletOperationData.setCommission(comissionForCreator);
+            walletOperationData.setCommissionAmount(commissionForCreatorInWallet);
+            walletOperationData.setSourceType(TransactionSourceType.ORDER);
+            walletOperationData.setSourceId(exOrder.getId());
+            walletOperationData.setDescription(descriptionForCreator);
+            walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
+            if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
+                exceptionMessage = getWalletTransferExceptionMessage(walletTransferStatus, "orders.acceptsaveerror", locale);
+                throw new OrderAcceptionException(exceptionMessage);
+            }
 
             /*for acceptor IN*/
-      walletOperationData = new WalletOperationData();
-      walletOperationData.setOperationType(OperationType.INPUT);
-      walletOperationData.setWalletId(walletsForOrderAcceptionDto.getUserAcceptorInWalletId());
-      walletOperationData.setAmount(acceptorForInAmount);
-      walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
-      walletOperationData.setCommission(comissionForAcceptor);
-      walletOperationData.setCommissionAmount(commissionForAcceptorInWallet);
-      walletOperationData.setSourceType(TransactionSourceType.ORDER);
-      walletOperationData.setSourceId(exOrder.getId());
-      walletOperationData.setDescription(descriptionForAcceptor);
-      walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
-      if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
-        exceptionMessage = getWalletTransferExceptionMessage(walletTransferStatus, "orders.acceptsaveerror", locale);
-        throw new OrderAcceptionException(exceptionMessage);
-      }
+            walletOperationData = new WalletOperationData();
+            walletOperationData.setOperationType(OperationType.INPUT);
+            walletOperationData.setWalletId(walletsForOrderAcceptionDto.getUserAcceptorInWalletId());
+            walletOperationData.setAmount(acceptorForInAmount);
+            walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
+            walletOperationData.setCommission(comissionForAcceptor);
+            walletOperationData.setCommissionAmount(commissionForAcceptorInWallet);
+            walletOperationData.setSourceType(TransactionSourceType.ORDER);
+            walletOperationData.setSourceId(exOrder.getId());
+            walletOperationData.setDescription(descriptionForAcceptor);
+            walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
+            if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
+                exceptionMessage = getWalletTransferExceptionMessage(walletTransferStatus, "orders.acceptsaveerror", locale);
+                throw new OrderAcceptionException(exceptionMessage);
+            }
             /**/
-      CompanyWallet companyWallet = new CompanyWallet();
-      companyWallet.setId(walletsForOrderAcceptionDto.getCompanyWalletCurrencyConvert());
-      companyWallet.setBalance(walletsForOrderAcceptionDto.getCompanyWalletCurrencyConvertBalance());
-      companyWallet.setCommissionBalance(walletsForOrderAcceptionDto.getCompanyWalletCurrencyConvertCommissionBalance());
-      companyWalletService.deposit(companyWallet, new BigDecimal(0), exOrder.getCommissionFixedAmount().add(amountComissionForAcceptor));
+            CompanyWallet companyWallet = new CompanyWallet();
+            companyWallet.setId(walletsForOrderAcceptionDto.getCompanyWalletCurrencyConvert());
+            companyWallet.setBalance(walletsForOrderAcceptionDto.getCompanyWalletCurrencyConvertBalance());
+            companyWallet.setCommissionBalance(walletsForOrderAcceptionDto.getCompanyWalletCurrencyConvertCommissionBalance());
+            companyWalletService.deposit(companyWallet, new BigDecimal(0), exOrder.getCommissionFixedAmount().add(amountComissionForAcceptor));
             /**/
-      exOrder.setStatus(OrderStatus.CLOSED);
-      exOrder.setDateAcception(LocalDateTime.now());
-      exOrder.setUserAcceptorId(userAcceptorId);
-      final Currency currency = currencyService.findCurrencyPairById(exOrder.getCurrencyPairId())
-          .getCurrency2();
+            exOrder.setStatus(OrderStatus.CLOSED);
+            exOrder.setDateAcception(LocalDateTime.now());
+            exOrder.setUserAcceptorId(userAcceptorId);
+            final Currency currency = currencyService.findCurrencyPairById(exOrder.getCurrencyPairId())
+                    .getCurrency2();
 
-      /** TODO: 6/7/16 Temporarily disable the referral program
-       * referralService.processReferral(exOrder, exOrder.getCommissionFixedAmount(), currency.getId(), exOrder.getUserId()); //Processing referral for Order Creator
-       * referralService.processReferral(exOrder, amountComissionForAcceptor, currency.getId(), exOrder.getUserAcceptorId()); //Processing referral for Order Acceptor
-       */
+            /** TODO: 6/7/16 Temporarily disable the referral program
+             * referralService.processReferral(exOrder, exOrder.getCommissionFixedAmount(), currency.getId(), exOrder.getUserId()); //Processing referral for Order Creator
+             * referralService.processReferral(exOrder, amountComissionForAcceptor, currency.getId(), exOrder.getUserAcceptorId()); //Processing referral for Order Acceptor
+             */
 
-      referralService.processReferral(exOrder, exOrder.getCommissionFixedAmount(), currency, exOrder.getUserId()); //Processing referral for Order Creator
-      referralService.processReferral(exOrder, amountComissionForAcceptor, currency, exOrder.getUserAcceptorId()); //Processing referral for Order Acceptor
+            referralService.processReferral(exOrder, exOrder.getCommissionFixedAmount(), currency, exOrder.getUserId()); //Processing referral for Order Creator
+            referralService.processReferral(exOrder, amountComissionForAcceptor, currency, exOrder.getUserAcceptorId()); //Processing referral for Order Acceptor
 
-      if (!updateOrder(exOrder)) {
-        throw new OrderAcceptionException(messageSource.getMessage("orders.acceptsaveerror", null, locale));
-      }
+            if (!updateOrder(exOrder)) {
+                throw new OrderAcceptionException(messageSource.getMessage("orders.acceptsaveerror", null, locale));
+            }
       /*if (sendNotification) {
         notificationService.createLocalizedNotification(exOrder.getUserId(), NotificationEvent.ORDER, "acceptordersuccess.title",
             "acceptorder.message", new Object[]{exOrder.getId()});
       }*/
 
-    /*  stopOrderService.onLimitOrderAccept(exOrder);*//*check stop-orders for process*/
-      /*action for refresh orders*/
-      eventPublisher.publishEvent(new AcceptOrderEvent(exOrder));
-    } catch (Exception e) {
-      logger.error("Error while accepting order with id = " + orderId + " exception: " + e.getLocalizedMessage());
-      throw e;
-    }
-  }
+            /*  stopOrderService.onLimitOrderAccept(exOrder);*//*check stop-orders for process*/
+            /*action for refresh orders*/
+            eventPublisher.publishEvent(new AcceptOrderEvent(exOrder));
+        } catch (Exception e) {
+            logger.error("Error while accepting order with id = " + orderId + " exception: " + e.getLocalizedMessage());
+            throw e;
+        }
+    }
 
-  private void checkAcceptPermissionForUser(Integer acceptorId, Integer creatorId, Locale locale) {
-    UserRole acceptorRole = userService.getUserRoleFromDB(acceptorId);
-    UserRole creatorRole = userService.getUserRoleFromDB(creatorId);
+    private void checkAcceptPermissionForUser(Integer acceptorId, Integer creatorId, Locale locale) {
+        UserRole acceptorRole = userService.getUserRoleFromDB(acceptorId);
+        UserRole creatorRole = userService.getUserRoleFromDB(creatorId);
 
-    UserRoleSettings creatorSettings = userRoleService.retrieveSettingsForRole(creatorRole.getRole());
-    if (creatorSettings.isBotAcceptionAllowedOnly() && acceptorRole != UserRole.BOT_TRADER) {
-      throw new AttemptToAcceptBotOrderException(messageSource.getMessage("orders.acceptsaveerror", null, locale));
-    }
-    if (userRoleService.isOrderAcceptionAllowedForUser(acceptorId)) {
-      if (acceptorRole != creatorRole) {
-        throw new OrderAcceptionException(messageSource.getMessage("order.accept.wrongRole", new Object[]{creatorRole.name()}, locale));
-      }
+        UserRoleSettings creatorSettings = userRoleService.retrieveSettingsForRole(creatorRole.getCode());
+        if (creatorSettings.isBotAcceptionAllowedOnly() && acceptorRole != UserRole.BOT_TRADER) {
+            throw new AttemptToAcceptBotOrderException(messageSource.getMessage("orders.acceptsaveerror", null, locale));
+        }
+        if (userRoleService.isOrderAcceptionAllowedForUser(acceptorId)) {
+            if (acceptorRole != creatorRole) {
+                throw new OrderAcceptionException(messageSource.getMessage("order.accept.wrongRole", new Object[]{creatorRole.name()}, locale));
+            }
 
-    }
+        }
 
 
-  }
+    }
 
-  private String getWalletTransferExceptionMessage(WalletTransferStatus status, String negativeBalanceMessageCode, Locale locale) {
-    String message = "";
-    switch (status) {
-      case CAUSED_NEGATIVE_BALANCE:
-        message = messageSource.getMessage(negativeBalanceMessageCode, null, locale);
-        break;
-      case CORRESPONDING_COMPANY_WALLET_NOT_FOUND:
-        message = messageSource.getMessage("orders.companyWalletNotFound", null, locale);
-        break;
-      case WALLET_NOT_FOUND:
-        message = messageSource.getMessage("orders.walletNotFound", null, locale);
-        break;
-      case WALLET_UPDATE_ERROR:
-        message = messageSource.getMessage("orders.walletUpdateError", null, locale);
-        break;
-      case TRANSACTION_CREATION_ERROR:
-        message = messageSource.getMessage("transaction.createerror", null, locale);
-        break;
-      default:
-        message = messageSource.getMessage("orders.acceptsaveerror", null, locale);
+    private String getWalletTransferExceptionMessage(WalletTransferStatus status, String negativeBalanceMessageCode, Locale locale) {
+        String message = "";
+        switch (status) {
+            case CAUSED_NEGATIVE_BALANCE:
+                message = messageSource.getMessage(negativeBalanceMessageCode, null, locale);
+                break;
+            case CORRESPONDING_COMPANY_WALLET_NOT_FOUND:
+                message = messageSource.getMessage("orders.companyWalletNotFound", null, locale);
+                break;
+            case WALLET_NOT_FOUND:
+                message = messageSource.getMessage("orders.walletNotFound", null, locale);
+                break;
+            case WALLET_UPDATE_ERROR:
+                message = messageSource.getMessage("orders.walletUpdateError", null, locale);
+                break;
+            case TRANSACTION_CREATION_ERROR:
+                message = messageSource.getMessage("transaction.createerror", null, locale);
+                break;
+            default:
+                message = messageSource.getMessage("orders.acceptsaveerror", null, locale);
 
-    }
-    return message;
-  }
+        }
+        return message;
+    }
 
 
-  private BigDecimal getAmountWithComissionForCreator(ExOrder exOrder) {
-    if (exOrder.getOperationType() == OperationType.SELL) {
-      return BigDecimalProcessing.doAction(exOrder.getAmountConvert(), exOrder.getCommissionFixedAmount(), ActionType.SUBTRACT);
-    } else {
-      return BigDecimalProcessing.doAction(exOrder.getAmountConvert(), exOrder.getCommissionFixedAmount(), ActionType.ADD);
-    }
-  }
+    private BigDecimal getAmountWithComissionForCreator(ExOrder exOrder) {
+        if (exOrder.getOperationType() == OperationType.SELL) {
+            return BigDecimalProcessing.doAction(exOrder.getAmountConvert(), exOrder.getCommissionFixedAmount(), ActionType.SUBTRACT);
+        } else {
+            return BigDecimalProcessing.doAction(exOrder.getAmountConvert(), exOrder.getCommissionFixedAmount(), ActionType.ADD);
+        }
+    }
 
-  @Override
-  @Transactional
-  public void cancelOrder(Integer orderId, String currentUserEmail) {
-    ExOrder exOrder = getOrderById(orderId);
-    String creatorEmail = userService.getEmailById(exOrder.getUserId());
-    if (!currentUserEmail.equals(creatorEmail)) {
-      throw new IncorrectCurrentUserException(String.format("creator %s, current user %s", creatorEmail, currentUserEmail));
-    }
-    Locale locale = userService.getUserLocaleForMobile(currentUserEmail);
-    cancellOrder(exOrder, locale);
-  }
+    @Override
+    @Transactional
+    public void cancelOrder(Integer orderId, String currentUserEmail) {
+        ExOrder exOrder = getOrderById(orderId);
+        String creatorEmail = userService.getEmailById(exOrder.getUserId());
+        if (!currentUserEmail.equals(creatorEmail)) {
+            throw new IncorrectCurrentUserException(String.format("creator %s, current user %s", creatorEmail, currentUserEmail));
+        }
+        Locale locale = userService.getUserLocaleForMobile(currentUserEmail);
+        cancellOrder(exOrder, locale);
+    }
 
-  @Transactional(rollbackFor = {Exception.class})
-  @Override
-  public boolean cancellOrder(ExOrder exOrder, Locale locale) {
-    try {
-      WalletsForOrderCancelDto walletsForOrderCancelDto = walletService.getWalletForOrderByOrderIdAndOperationTypeAndBlock(
-          exOrder.getId(),
-          exOrder.getOperationType());
-      OrderStatus currentStatus = OrderStatus.convert(walletsForOrderCancelDto.getOrderStatusId());
-      if (currentStatus != OrderStatus.OPENED) {
-        throw new OrderAcceptionException(messageSource.getMessage("order.cannotcancel", null, locale));
-      }
-      String description = transactionDescription.get(currentStatus, CANCEL);
-      WalletTransferStatus transferResult = walletService.walletInnerTransfer(
-          walletsForOrderCancelDto.getWalletId(),
-          walletsForOrderCancelDto.getReservedAmount(),
-          TransactionSourceType.ORDER,
-          exOrder.getId(),
-          description);
-      if (transferResult != WalletTransferStatus.SUCCESS) {
-        throw new OrderCancellingException(transferResult.toString());
-      }
+    @Transactional(rollbackFor = {Exception.class})
+    @Override
+    public boolean cancellOrder(ExOrder exOrder, Locale locale) {
+        try {
+            WalletsForOrderCancelDto walletsForOrderCancelDto = walletService.getWalletForOrderByOrderIdAndOperationTypeAndBlock(
+                    exOrder.getId(),
+                    exOrder.getOperationType());
+            OrderStatus currentStatus = OrderStatus.convert(walletsForOrderCancelDto.getOrderStatusId());
+            if (currentStatus != OrderStatus.OPENED) {
+                throw new OrderAcceptionException(messageSource.getMessage("order.cannotcancel", null, locale));
+            }
+            String description = transactionDescription.get(currentStatus, CANCEL);
+            WalletTransferStatus transferResult = walletService.walletInnerTransfer(
+                    walletsForOrderCancelDto.getWalletId(),
+                    walletsForOrderCancelDto.getReservedAmount(),
+                    TransactionSourceType.ORDER,
+                    exOrder.getId(),
+                    description);
+            if (transferResult != WalletTransferStatus.SUCCESS) {
+                throw new OrderCancellingException(transferResult.toString());
+            }
 
-      boolean result = setStatus(exOrder.getId(), OrderStatus.CANCELLED);
-      if (result) {
-        eventPublisher.publishEvent(new CancelOrderEvent(exOrder, false));
-      }
-      return result;
-    } catch (Exception e) {
-      logger.error("Error while cancelling order " + exOrder.getId() + " , " + e.getLocalizedMessage());
-      throw e;
-    }
-  }
+            boolean result = setStatus(exOrder.getId(), OrderStatus.CANCELLED);
+            if (result) {
+                eventPublisher.publishEvent(new CancelOrderEvent(exOrder, false));
+            }
+            return result;
+        } catch (Exception e) {
+            logger.error("Error while cancelling order " + exOrder.getId() + " , " + e.getLocalizedMessage());
+            throw e;
+        }
+    }
 
 
-  private String getStatusString(OrderStatus status, Locale ru) {
-    String statusString = null;
-    switch (status) {
-      case INPROCESS:
-        statusString = messageSource.getMessage("orderstatus.inprocess", null, ru);
-        break;
-      case OPENED:
-        statusString = messageSource.getMessage("orderstatus.opened", null, ru);
-        break;
-      case CLOSED:
-        statusString = messageSource.getMessage("orderstatus.closed", null, ru);
-        break;
-    }
-    return statusString;
-  }
+    private String getStatusString(OrderStatus status, Locale ru) {
+        String statusString = null;
+        switch (status) {
+            case INPROCESS:
+                statusString = messageSource.getMessage("orderstatus.inprocess", null, ru);
+                break;
+            case OPENED:
+                statusString = messageSource.getMessage("orderstatus.opened", null, ru);
+                break;
+            case CLOSED:
+                statusString = messageSource.getMessage("orderstatus.closed", null, ru);
+                break;
+        }
+        return statusString;
+    }
 
-  @Transactional(propagation = Propagation.NESTED)
-  @Override
-  public boolean updateOrder(ExOrder exOrder) {
-    return orderDao.updateOrder(exOrder);
-  }
+    @Transactional(propagation = Propagation.NESTED)
+    @Override
+    public boolean updateOrder(ExOrder exOrder) {
+        return orderDao.updateOrder(exOrder);
+    }
 
 
-  public List<CoinmarketApiDto> getCoinmarketData(String currencyPairName, BackDealInterval backDealInterval) {
-    final List<CoinmarketApiDto> result = orderDao.getCoinmarketData(currencyPairName);
-    List<CurrencyPair> currencyPairList = currencyService.getAllCurrencyPairs(CurrencyPairType.ALL);
-    result.addAll(currencyPairList.stream()
-        .filter(e -> (StringUtils.isEmpty(currencyPairName) || e.getName().equals(currencyPairName))
-            && result.stream().noneMatch(r -> r.getCurrency_pair_name().equals(e.getName())))
-        .map(CoinmarketApiDto::new)
-        .collect(toList()));
-    return result;
-  }
+    public List<CoinmarketApiDto> getCoinmarketData(String currencyPairName, BackDealInterval backDealInterval) {
+        final List<CoinmarketApiDto> result = orderDao.getCoinmarketData(currencyPairName);
+        List<CurrencyPair> currencyPairList = currencyService.getAllCurrencyPairs(CurrencyPairType.ALL);
+        result.addAll(currencyPairList.stream()
+                .filter(e -> (StringUtils.isEmpty(currencyPairName) || e.getName().equals(currencyPairName))
+                        && result.stream().noneMatch(r -> r.getCurrency_pair_name().equals(e.getName())))
+                .map(CoinmarketApiDto::new)
+                .collect(toList()));
+        return result;
+    }
 
-  @Override
-  public List<CoinmarketApiDto> getCoinmarketDataForActivePairs(String currencyPairName, BackDealInterval backDealInterval) {
-    return orderDao.getCoinmarketData(currencyPairName);
-  }
+    @Override
+    public List<CoinmarketApiDto> getCoinmarketDataForActivePairs(String currencyPairName, BackDealInterval backDealInterval) {
+        return orderDao.getCoinmarketData(currencyPairName);
+    }
 
-  @Override
-  public List<CoinmarketApiDto> getDailyCoinmarketData(String currencyPairName) {
-    if (StringUtils.isEmpty(currencyPairName) && coinmarketCachedData != null && !coinmarketCachedData.isEmpty()) {
-      return coinmarketCachedData;
-    } else {
-      return getCoinmarketDataForActivePairs(currencyPairName, new BackDealInterval("24 HOUR"));
-    }
-  }
+    @Override
+    public List<CoinmarketApiDto> getDailyCoinmarketData(String currencyPairName) {
+        if (StringUtils.isEmpty(currencyPairName) && coinmarketCachedData != null && !coinmarketCachedData.isEmpty()) {
+            return coinmarketCachedData;
+        } else {
+            return getCoinmarketDataForActivePairs(currencyPairName, new BackDealInterval("24 HOUR"));
+        }
+    }
 
-  @Override
-  public List<CoinmarketApiDto> getHourlyCoinmarketData(String currencyPairName) {
-    return getCoinmarketDataForActivePairs(currencyPairName, new BackDealInterval("1 HOUR"));
-  }
+    @Override
+    public List<CoinmarketApiDto> getHourlyCoinmarketData(String currencyPairName) {
+        return getCoinmarketDataForActivePairs(currencyPairName, new BackDealInterval("1 HOUR"));
+    }
 
 
-  @Override
-  public OrderInfoDto getOrderInfo(int orderId, Locale locale) {
-    return orderDao.getOrderInfo(orderId, locale);
-  }
+    @Override
+    public OrderInfoDto getOrderInfo(int orderId, Locale locale) {
+        return orderDao.getOrderInfo(orderId, locale);
+    }
 
-  @Override
-  public AdminOrderInfoDto getAdminOrderInfo(int orderId, Locale locale) {
-    AdminOrderInfoDto dto = new AdminOrderInfoDto(this.getOrderInfo(orderId, locale));
-    setIsOrderAcceptableAndNotifications(dto, locale);
-    return dto;
-  }
+    @Override
+    public AdminOrderInfoDto getAdminOrderInfo(int orderId, Locale locale) {
+        AdminOrderInfoDto dto = new AdminOrderInfoDto(this.getOrderInfo(orderId, locale));
+        setIsOrderAcceptableAndNotifications(dto, locale);
+        return dto;
+    }
 
-  private void setIsOrderAcceptableAndNotifications(AdminOrderInfoDto dto, Locale locale) {
-    UserRole orderCreatorRole = userService.getUserRoleFromDB(dto.getOrderInfo().getOrderCreatorEmail());
-    UserRole userRole = userService.getUserRoleFromSecurityContext();
-    if (orderCreatorRole.getRole() == UserRole.TRADER.getRole() &&
-            userRoleService.getRealUserRoleIdByBusinessRoleList(BusinessUserRoleEnum.ADMIN).contains(userRole.getRole())) {
-        dto.setNotification(messageSource.getMessage("admin.orders.accept.warning", null, locale));
-        dto.setAcceptable(true);
-    } else if (userRole.getRole() == UserRole.TRADER.getRole() && orderCreatorRole.getRole() != UserRole.TRADER.getRole()) {
-      dto.setAcceptable(false);
-      dto.setNotification(messageSource.getMessage("admin.orders.cantaccept", null, locale));
-    } else {
-      dto.setAcceptable(true);
-    }
-  }
+    private void setIsOrderAcceptableAndNotifications(AdminOrderInfoDto dto, Locale locale) {
+        UserRole orderCreatorRole = userService.getUserRoleFromDB(dto.getOrderInfo().getOrderCreatorEmail());
+        UserRole userRole = userService.getUserRoleFromSecurityContext();
+        if (orderCreatorRole.getCode() == UserRole.TRADER.getCode() &&
+                userRoleService.getRealUserRoleIdByBusinessRoleList(BusinessUserRoleEnum.ADMIN).contains(userRole.getCode())) {
+            dto.setNotification(messageSource.getMessage("admin.orders.accept.warning", null, locale));
+            dto.setAcceptable(true);
+        } else if (userRole.getCode() == UserRole.TRADER.getCode() && orderCreatorRole.getCode() != UserRole.TRADER.getCode()) {
+            dto.setAcceptable(false);
+            dto.setNotification(messageSource.getMessage("admin.orders.cantaccept", null, locale));
+        } else {
+            dto.setAcceptable(true);
+        }
+    }
 
-  @Override
-  @Transactional(rollbackFor = {Exception.class})
-  public void deleteManyOrdersByAdmin(List<Integer> orderIds) {
-    orderIds.forEach(this::deleteOrderByAdmin);
-  }
+    @Override
+    @Transactional(rollbackFor = {Exception.class})
+    public void deleteManyOrdersByAdmin(List<Integer> orderIds) {
+        orderIds.forEach(this::deleteOrderByAdmin);
+    }
 
-  @Transactional(rollbackFor = {Exception.class})
-  @Override
-  public Integer deleteOrderByAdmin(int orderId) {
-    OrderCreateDto order = orderDao.getMyOrderById(orderId);
-    OrderRoleInfoForDelete orderRoleInfo = orderDao.getOrderRoleInfo(orderId);
-    if (orderRoleInfo.mayDeleteWithoutProcessingTransactions()) {
-      setStatus(orderId, OrderStatus.DELETED);
-      return 1;
-    }
+    @Transactional(rollbackFor = {Exception.class})
+    @Override
+    public Integer deleteOrderByAdmin(int orderId) {
+        OrderCreateDto order = orderDao.getMyOrderById(orderId);
+        OrderRoleInfoForDelete orderRoleInfo = orderDao.getOrderRoleInfo(orderId);
+        if (orderRoleInfo.mayDeleteWithoutProcessingTransactions()) {
+            setStatus(orderId, OrderStatus.DELETED);
+            return 1;
+        }
 
-    Object result = deleteOrder(orderId, OrderStatus.DELETED, DELETE);
-    if (result instanceof OrderDeleteStatus) {
-      if ((OrderDeleteStatus) result == OrderDeleteStatus.NOT_FOUND) {
-        return 0;
-      }
-      throw new OrderDeletingException(((OrderDeleteStatus) result).toString());
-    }
-    notificationService.notifyUser(order.getUserId(), NotificationEvent.ORDER,
-        "deleteOrder.notificationTitle", "deleteOrder.notificationMessage", new Object[]{order.getOrderId()});
-    return (Integer) result;
-  }
+        Object result = deleteOrder(orderId, OrderStatus.DELETED, DELETE);
+        if (result instanceof OrderDeleteStatus) {
+            if ((OrderDeleteStatus) result == OrderDeleteStatus.NOT_FOUND) {
+                return 0;
+            }
+            throw new OrderDeletingException(((OrderDeleteStatus) result).toString());
+        }
+        notificationService.notifyUser(order.getUserId(), NotificationEvent.ORDER,
+                "deleteOrder.notificationTitle", "deleteOrder.notificationMessage", new Object[]{order.getOrderId()});
+        return (Integer) result;
+    }
 
-  @Override
-  @Transactional(rollbackFor = {Exception.class})
-  public Integer deleteOrderForPartialAccept(int orderId) {
-    Object result = deleteOrder(orderId, OrderStatus.SPLIT_CLOSED, DELETE_SPLIT);
-    if (result instanceof OrderDeleteStatus) {
-      throw new OrderDeletingException(((OrderDeleteStatus) result).toString());
-    }
-    return (Integer) result;
-  }
+    @Override
+    @Transactional(rollbackFor = {Exception.class})
+    public Integer deleteOrderForPartialAccept(int orderId) {
+        Object result = deleteOrder(orderId, OrderStatus.SPLIT_CLOSED, DELETE_SPLIT);
+        if (result instanceof OrderDeleteStatus) {
+            throw new OrderDeletingException(((OrderDeleteStatus) result).toString());
+        }
+        return (Integer) result;
+    }
 
 
-  @Override
-  public Integer searchOrderByAdmin(Integer currencyPair, String orderType, String orderDate, BigDecimal orderRate, BigDecimal orderVolume) {
-    Integer ot = OperationType.valueOf(orderType).getType();
-    return orderDao.searchOrderByAdmin(currencyPair, ot, orderDate, orderRate, orderVolume);
-  }
+    @Override
+    public Integer searchOrderByAdmin(Integer currencyPair, String orderType, String orderDate, BigDecimal orderRate, BigDecimal orderVolume) {
+        Integer ot = OperationType.valueOf(orderType).getCode();
+        return orderDao.searchOrderByAdmin(currencyPair, ot, orderDate, orderRate, orderVolume);
+    }
 
-  @Override
-  public List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriod(CacheData cacheData,
-                                                                 String email,
-                                                                 BackDealInterval backDealInterval,
-                                                                 Integer limit, CurrencyPair currencyPair, Locale locale) {
+    @Override
+    public List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriod(CacheData cacheData,
+                                                                   String email,
+                                                                   BackDealInterval backDealInterval,
+                                                                   Integer limit, CurrencyPair currencyPair, Locale locale) {
     /*Boolean evictEhCache = cacheData.getForceUpdate() && false;
     List<OrderAcceptedHistoryDto> result = serviceCacheableProxy.getOrderAcceptedForPeriod(
         email,
@@ -1283,182 +1398,184 @@
         e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
       });
     }*/
-    List<OrderAcceptedHistoryDto> result = orderDao.getOrderAcceptedForPeriod(email, backDealInterval, limit, currencyPair);
-    result = result.stream()
-            .map(OrderAcceptedHistoryDto::new)
-            .collect(toList());
-    result.forEach(e -> {
-      e.setRate(BigDecimalProcessing.formatLocale(e.getRate(), locale, true));
-      e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
-    });
-    return result;
-  }
+        List<OrderAcceptedHistoryDto> result = orderDao.getOrderAcceptedForPeriod(email, backDealInterval, limit, currencyPair);
+        result = result.stream()
+                .map(OrderAcceptedHistoryDto::new)
+                .collect(toList());
+        result.forEach(e -> {
+            e.setRate(BigDecimalProcessing.formatLocale(e.getRate(), locale, true));
+            e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
+        });
+        return result;
+    }
 
-  @Override
-  public List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriodEx(String email,
-                                                                   BackDealInterval backDealInterval,
-                                                                   Integer limit, CurrencyPair currencyPair, Locale locale) {
-    List<OrderAcceptedHistoryDto> result = orderDao.getOrderAcceptedForPeriod(email, backDealInterval, limit, currencyPair);
-    result = result.stream()
-              .map(OrderAcceptedHistoryDto::new)
-              .collect(toList());
-      result.forEach(e -> {
-        e.setRate(BigDecimalProcessing.formatLocale(e.getRate(), locale, true));
-        e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
-      });
-    return result;
-  }
+    @Override
+    public List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriodEx(String email,
+                                                                     BackDealInterval backDealInterval,
+                                                                     Integer limit, CurrencyPair currencyPair, Locale locale) {
+        List<OrderAcceptedHistoryDto> result = orderDao.getOrderAcceptedForPeriod(email, backDealInterval, limit, currencyPair);
+        result = result.stream()
+                .map(OrderAcceptedHistoryDto::new)
+                .collect(toList());
+        result.forEach(e -> {
+            e.setRate(BigDecimalProcessing.formatLocale(e.getRate(), locale, true));
+            e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
+        });
+        return result;
+    }
 
-  @Transactional(readOnly = true)
-  @Override
-  public OrderCommissionsDto getCommissionForOrder() {
-    return orderDao.getCommissionForOrder(userService.getUserRoleFromSecurityContext());
-  }
+    @Transactional(readOnly = true)
+    @Override
+    public OrderCommissionsDto getCommissionForOrder() {
+        return orderDao.getCommissionForOrder(userService.getUserRoleFromSecurityContext());
+    }
 
-  @Transactional(transactionManager = "slaveTxManager", readOnly = true)
-  @Override
-  public CommissionsDto getAllCommissions() {
-    UserRole userRole = userService.getUserRoleFromSecurityContext();
-    return orderDao.getAllCommissions(userRole);
-  }
+    @Transactional(transactionManager = "slaveTxManager", readOnly = true)
+    @Override
+    public CommissionsDto getAllCommissions() {
+        UserRole userRole = userService.getUserRoleFromSecurityContext();
+        return orderDao.getAllCommissions(userRole);
+    }
 
 
-  @Override
-  public List<OrderListDto> getAllBuyOrders(CacheData cacheData,
-                                            CurrencyPair currencyPair, Locale locale, Boolean orderRoleFilterEnabled) {
-    Boolean evictEhCache = cacheData.getForceUpdate();
-    UserRole filterRole = orderRoleFilterEnabled ? userService.getUserRoleFromSecurityContext() : null;
-    List<OrderListDto> result = aggregateOrders(serviceCacheableProxy.getAllBuyOrders(currencyPair, filterRole, evictEhCache), OperationType.BUY, evictEhCache);
-    result = new ArrayList<>(result);
-    if (Cache.checkCache(cacheData, result)) {
-      result = new ArrayList<OrderListDto>() {{
-        add(new OrderListDto(false));
-      }};
-    } else {
-      result = result.stream()
-          .map(OrderListDto::new).sorted(new Comparator<OrderListDto>() {
-                @Override
-                public int compare(OrderListDto o1, OrderListDto o2) {
-                  return Double.valueOf(o2.getExrate()).compareTo(Double.valueOf(o1.getExrate()));
-                }
-              })
-          .collect(toList());
-      result.forEach(e -> {
-        e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
-        e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
-        e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
-      });
-    }
-    return result;
-  }
+    @Override
+    public List<OrderListDto> getAllBuyOrders(CacheData cacheData,
+                                              CurrencyPair currencyPair, Locale locale, Boolean orderRoleFilterEnabled) {
+        Boolean evictEhCache = cacheData.getForceUpdate();
+        UserRole filterRole = orderRoleFilterEnabled ? userService.getUserRoleFromSecurityContext() : null;
+        List<OrderListDto> result = aggregateOrders(serviceCacheableProxy.getAllBuyOrders(currencyPair, filterRole, evictEhCache), OperationType.BUY, evictEhCache);
+        result = new ArrayList<>(result);
+        if (Cache.checkCache(cacheData, result)) {
+            result = new ArrayList<OrderListDto>() {{
+                add(new OrderListDto(false));
+            }};
+        } else {
+            result = result.stream()
+                    .map(OrderListDto::new).sorted(new Comparator<OrderListDto>() {
+                        @Override
+                        public int compare(OrderListDto o1, OrderListDto o2) {
+                            return Double.valueOf(o2.getExrate()).compareTo(Double.valueOf(o1.getExrate()));
+                        }
+                    })
+                    .collect(toList());
+            result.forEach(e -> {
+                e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
+                e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
+                e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
+            });
+        }
+        return result;
+    }
 
 
-  @Override
-  public List<OrderListDto> getAllBuyOrdersEx(CurrencyPair currencyPair, Locale locale, UserRole userRole) {
-    List<OrderListDto> result = aggregateOrders(orderDao.getOrdersBuyForCurrencyPair(currencyPair, userRole), OperationType.BUY, true);
-    result = new ArrayList<>(result);
-    result = result.stream()
-              .map(OrderListDto::new).sorted(new Comparator<OrderListDto>() {
-                @Override
-                public int compare(OrderListDto o1, OrderListDto o2) {
-                  return Double.valueOf(o2.getExrate()).compareTo(Double.valueOf(o1.getExrate()));
-                }
-              })
-              .collect(toList());
-      result.forEach(e -> {
-        e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
-        e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
-        e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
-      });
-    return result;
-  }
+    @Override
+    public List<OrderListDto> getAllBuyOrdersEx(CurrencyPair currencyPair, Locale locale, UserRole userRole) {
+        List<OrderListDto> result = aggregateOrders(orderDao.getOrdersBuyForCurrencyPair(currencyPair, userRole), OperationType.BUY, true);
+        result = new ArrayList<>(result);
+        result = result.stream()
+                .map(OrderListDto::new).sorted(new Comparator<OrderListDto>() {
+                    @Override
+                    public int compare(OrderListDto o1, OrderListDto o2) {
+                        return Double.valueOf(o2.getExrate()).compareTo(Double.valueOf(o1.getExrate()));
+                    }
+                })
+                .collect(toList());
+        result.forEach(e -> {
+            e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
+            e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
+            e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
+        });
+        return result;
+    }
 
-  @Override
-  public List<OrderListDto> getAllSellOrdersEx(CurrencyPair currencyPair, Locale locale, UserRole userRole) {
-    List<OrderListDto> result = aggregateOrders(orderDao.getOrdersSellForCurrencyPair(currencyPair, userRole), OperationType.SELL, true);
-    result = new ArrayList<>(result);
-    result = result.stream()
-            .map(OrderListDto::new).sorted(new Comparator<OrderListDto>() {
-              @Override
-              public int compare(OrderListDto o1, OrderListDto o2) {
-                return Double.valueOf(o1.getExrate()).compareTo(Double.valueOf(o2.getExrate()));
-              }
-            })
-            .collect(toList());
-    result.forEach(e -> {
-      e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
-      e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
-      e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
-    });
-    return result;
-  }
+    @Override
+    public List<OrderListDto> getAllSellOrdersEx(CurrencyPair currencyPair, Locale locale, UserRole userRole) {
+        List<OrderListDto> result = aggregateOrders(orderDao.getOrdersSellForCurrencyPair(currencyPair, userRole), OperationType.SELL, true);
+        result = new ArrayList<>(result);
+        result = result.stream()
+                .map(OrderListDto::new).sorted(new Comparator<OrderListDto>() {
+                    @Override
+                    public int compare(OrderListDto o1, OrderListDto o2) {
+                        return Double.valueOf(o1.getExrate()).compareTo(Double.valueOf(o2.getExrate()));
+                    }
+                })
+                .collect(toList());
+        result.forEach(e -> {
+            e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
+            e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
+            e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
+        });
+        return result;
+    }
 
 
-  @Override
-  public List<OrderListDto> getAllSellOrders(CacheData cacheData,
-                                             CurrencyPair currencyPair, Locale locale, Boolean orderRoleFilterEnabled) {
-    Boolean evictEhCache = cacheData.getForceUpdate();
-    UserRole filterRole = orderRoleFilterEnabled ? userService.getUserRoleFromSecurityContext() : null;
-    List<OrderListDto> result = aggregateOrders(serviceCacheableProxy.getAllSellOrders(currencyPair, filterRole, evictEhCache), OperationType.SELL, evictEhCache);
-    result = new ArrayList<>(result);
-    if (Cache.checkCache(cacheData, result)) {
-      result = new ArrayList<OrderListDto>() {{
-        add(new OrderListDto(false));
-      }};
-    } else {
-      result = result.stream()
-          .map(OrderListDto::new).sorted(new Comparator<OrderListDto>() {
-                @Override
-                public int compare(OrderListDto o1, OrderListDto o2) {
-                  return Double.valueOf(o1.getExrate()).compareTo(Double.valueOf(o2.getExrate()));
-                }
-              })
-          .collect(toList());
-      result.forEach(e -> {
-        e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
-        e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
-        e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
-      });
-    }
-    return result;
-  }
+    @Override
+    public List<OrderListDto> getAllSellOrders(CacheData cacheData,
+                                               CurrencyPair currencyPair, Locale locale, Boolean orderRoleFilterEnabled) {
+        Boolean evictEhCache = cacheData.getForceUpdate();
+        UserRole filterRole = orderRoleFilterEnabled ? userService.getUserRoleFromSecurityContext() : null;
+        List<OrderListDto> result = aggregateOrders(serviceCacheableProxy.getAllSellOrders(currencyPair, filterRole, evictEhCache), OperationType.SELL, evictEhCache);
+        result = new ArrayList<>(result);
+        if (Cache.checkCache(cacheData, result)) {
+            result = new ArrayList<OrderListDto>() {{
+                add(new OrderListDto(false));
+            }};
+        } else {
+            result = result.stream()
+                    .map(OrderListDto::new).sorted(new Comparator<OrderListDto>() {
+                        @Override
+                        public int compare(OrderListDto o1, OrderListDto o2) {
+                            return Double.valueOf(o1.getExrate()).compareTo(Double.valueOf(o2.getExrate()));
+                        }
+                    })
+                    .collect(toList());
+            result.forEach(e -> {
+                e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
+                e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
+                e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
+            });
+        }
+        return result;
+    }
 
-  private List<OrderListDto> aggregateOrders(List<OrderListDto> historyDtos, OperationType operationType, boolean forceUpdate) {
-    List<OrderListDto> resultList = new ArrayList<>();
-    Map<String, List<OrderListDto>> map =
-            historyDtos.stream().collect(Collectors.groupingBy(OrderListDto::getExrate));
-    map.forEach((k,v)-> {
-      BigDecimal amountBase = new BigDecimal(0);
-      BigDecimal amountConverted = new BigDecimal(0);
-      StringJoiner ordersIds = new StringJoiner(" ");
-      for (OrderListDto order : v) {
-        amountBase = amountBase.add(new BigDecimal(order.getAmountBase()));
-        amountConverted = amountConverted.add(new BigDecimal(order.getAmountConvert()));
-        ordersIds.add(String.valueOf(order.getId()));
-      }
-      resultList.add(new OrderListDto(ordersIds.toString(), k, amountBase.toString(),
-              amountConverted.toString(), operationType, forceUpdate));
-    });
-    return resultList;
-  }
+    private List<OrderListDto> aggregateOrders(List<OrderListDto> historyDtos, OperationType operationType, boolean forceUpdate) {
+        List<OrderListDto> resultList = new ArrayList<>();
+        Map<String, List<OrderListDto>> map =
+                historyDtos.stream().collect(Collectors.groupingBy(OrderListDto::getExrate));
+        map.forEach((k, v) -> {
+            BigDecimal amountBase = new BigDecimal(0);
+            BigDecimal amountConverted = new BigDecimal(0);
+            StringJoiner ordersIds = new StringJoiner(" ");
+            for (OrderListDto order : v) {
+                amountBase = amountBase.add(new BigDecimal(order.getAmountBase()));
+                amountConverted = amountConverted.add(new BigDecimal(order.getAmountConvert()));
+                ordersIds.add(String.valueOf(order.getId()));
+            }
+            resultList.add(new OrderListDto(ordersIds.toString(), k, amountBase.toString(),
+                    amountConverted.toString(), operationType, forceUpdate));
+        });
+        return resultList;
+    }
 
-  @Transactional(readOnly = true)
-  @Override
-  public WalletsAndCommissionsForOrderCreationDto getWalletAndCommission(String email, Currency currency,
-                                                                         OperationType operationType) {
-    UserRole userRole = null;
-    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
-    if (authentication == null) {
-      userRole = userService.getUserRoleFromDB(email);
-    } else {
-      userRole = userService.getUserRoleFromSecurityContext();
-    }
-    return orderDao.getWalletAndCommission(email, currency, operationType, userRole);
-  }
+    @Transactional(readOnly = true)
+    @Override
+    public WalletsAndCommissionsForOrderCreationDto getWalletAndCommission(String email,
+                                                                           Currency currency,
+                                                                           OperationType operationType) {
+        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
+
+        UserRole userRole;
+        if (isNull(authentication)) {
+            userRole = userService.getUserRoleFromDB(email);
+        } else {
+            userRole = userService.getUserRoleFromSecurityContext();
+        }
+        return orderDao.getWalletAndCommission(email, currency, operationType, userRole);
+    }
 
-  public void setMessageSource(final MessageSource messageSource) {
-    this.messageSource = messageSource;
-  }
+    public void setMessageSource(final MessageSource messageSource) {
+        this.messageSource = messageSource;
+    }
 
 
     @Override
@@ -1472,418 +1589,425 @@
         return output;
     }
 
-  @Override
-  public List<OrderWideListDto> getUsersOrdersWithStateForAdmin(String email, CurrencyPair currencyPair, OrderStatus status,
-                                                                OperationType operationType,
-                                                                Integer offset, Integer limit, Locale locale) {
-    List<OrderWideListDto> result = orderDao.getMyOrdersWithState(userService.getIdByEmail(email), currencyPair, status, operationType, SCOPE, offset, limit, locale);
+    @Override
+    public List<OrderWideListDto> getUsersOrdersWithStateForAdmin(String email, CurrencyPair currencyPair, OrderStatus status,
+                                                                  OperationType operationType,
+                                                                  Integer offset, Integer limit, Locale locale) {
+        List<OrderWideListDto> result = orderDao.getMyOrdersWithState(userService.getIdByEmail(email), currencyPair, status, operationType, SCOPE, offset, limit, locale);
 
-    return result;
-  }
+        return result;
+    }
 
-  @Override
-  public List<OrderWideListDto> getMyOrdersWithState(String email, CurrencyPair currencyPair, OrderStatus status,
-                                                     OperationType operationType, String scope,
-                                                     Integer offset, Integer limit, Locale locale) {
-    return orderDao.getMyOrdersWithState(userService.getIdByEmail(email), currencyPair, status, operationType, scope, offset, limit, locale);
-  }
+    @Override
+    public List<OrderWideListDto> getMyOrdersWithState(String email, CurrencyPair currencyPair, OrderStatus status,
+                                                       OperationType operationType, String scope,
+                                                       Integer offset, Integer limit, Locale locale) {
+        return orderDao.getMyOrdersWithState(userService.getIdByEmail(email), currencyPair, status, operationType, scope, offset, limit, locale);
+    }
 
-  @Override
-  public List<OrderWideListDto> getMyOrdersWithState(String email, CurrencyPair currencyPair, List<OrderStatus> statuses,
-                                                     OperationType operationType,
-                                                     Integer offset, Integer limit, Locale locale) {
-    return orderDao.getMyOrdersWithState(userService.getIdByEmail(email), currencyPair, statuses, operationType, null, offset, limit, locale);
-  }
+    @Override
+    public List<OrderWideListDto> getMyOrdersWithState(String email, CurrencyPair currencyPair, List<OrderStatus> statuses,
+                                                       OperationType operationType,
+                                                       Integer offset, Integer limit, Locale locale) {
+        return orderDao.getMyOrdersWithState(userService.getIdByEmail(email), currencyPair, statuses, operationType, null, offset, limit, locale);
+    }
 
 
-  @Override
-  public List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriod(String email,
-                                                                 BackDealInterval backDealInterval,
-                                                                 Integer limit, CurrencyPair currencyPair, Locale locale) {
-    List<OrderAcceptedHistoryDto> result = orderDao.getOrderAcceptedForPeriod(email, backDealInterval, limit, currencyPair);
-    result.forEach(e -> {
-      e.setRate(BigDecimalProcessing.formatLocale(e.getRate(), locale, true));
-      e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
-    });
-    return result;
-  }
+    @Override
+    public List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriod(String email,
+                                                                   BackDealInterval backDealInterval,
+                                                                   Integer limit, CurrencyPair currencyPair, Locale locale) {
+        List<OrderAcceptedHistoryDto> result = orderDao.getOrderAcceptedForPeriod(email, backDealInterval, limit, currencyPair);
+        result.forEach(e -> {
+            e.setRate(BigDecimalProcessing.formatLocale(e.getRate(), locale, true));
+            e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
+        });
+        return result;
+    }
 
 
-  @Override
-  public List<OrderListDto> getAllBuyOrders(CurrencyPair currencyPair, Locale locale) {
-    List<OrderListDto> result = orderDao.getOrdersBuyForCurrencyPair(currencyPair, null);
-    result.forEach(e -> {
-      e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
-      e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
-      e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
-    });
-    return result;
-  }
+    @Override
+    public List<OrderListDto> getAllBuyOrders(CurrencyPair currencyPair, Locale locale) {
+        List<OrderListDto> result = orderDao.getOrdersBuyForCurrencyPair(currencyPair, null);
+        result.forEach(e -> {
+            e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
+            e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
+            e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
+        });
+        return result;
+    }
 
 
-  @Override
-  public List<OrderListDto> getAllSellOrders(CurrencyPair currencyPair, Locale locale) {
-    List<OrderListDto> result = orderDao.getOrdersSellForCurrencyPair(currencyPair, null);
-    result.forEach(e -> {
-      e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
-      e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
-      e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
-    });
-    return result;
-  }
+    @Override
+    public List<OrderListDto> getAllSellOrders(CurrencyPair currencyPair, Locale locale) {
+        List<OrderListDto> result = orderDao.getOrdersSellForCurrencyPair(currencyPair, null);
+        result.forEach(e -> {
+            e.setExrate(BigDecimalProcessing.formatLocale(e.getExrate(), locale, 2));
+            e.setAmountBase(BigDecimalProcessing.formatLocale(e.getAmountBase(), locale, true));
+            e.setAmountConvert(BigDecimalProcessing.formatLocale(e.getAmountConvert(), locale, true));
+        });
+        return result;
+    }
 
 
-  @Transactional
-  Object deleteOrder(int orderId, OrderStatus newOrderStatus, OrderActionEnum action) {
-    List<OrderDetailDto> list = walletService.getOrderRelatedDataAndBlock(orderId);
-    if (list.isEmpty()) {
-      return OrderDeleteStatus.NOT_FOUND;
-    }
-    int processedRows = 1;
-    /**/
-    OrderStatus currentOrderStatus = list.get(0).getOrderStatus();
-    String description = transactionDescription.get(currentOrderStatus, action);
-    /**/
-    if (!setStatus(orderId, newOrderStatus)){
-      return OrderDeleteStatus.ORDER_UPDATE_ERROR;
-    }
-     /**/
-    for (OrderDetailDto orderDetailDto : list) {
-      if (currentOrderStatus == OrderStatus.CLOSED) {
-        if (orderDetailDto.getCompanyCommission().compareTo(BigDecimal.ZERO) != 0) {
-          Integer companyWalletId = orderDetailDto.getCompanyWalletId();
-          if (companyWalletId != 0 && !companyWalletService.substractCommissionBalanceById(companyWalletId, orderDetailDto.getCompanyCommission())) {
-            return OrderDeleteStatus.COMPANY_WALLET_UPDATE_ERROR;
-          }
-        }
-        /**/
-        WalletOperationData walletOperationData = new WalletOperationData();
-        OperationType operationType = null;
-        if (orderDetailDto.getTransactionType() == OperationType.OUTPUT) {
-          operationType = OperationType.INPUT;
-        } else if (orderDetailDto.getTransactionType() == OperationType.INPUT) {
-          operationType = OperationType.OUTPUT;
-        }
-        if (operationType != null) {
-          walletOperationData.setOperationType(operationType);
-          walletOperationData.setWalletId(orderDetailDto.getUserWalletId());
-          walletOperationData.setAmount(orderDetailDto.getTransactionAmount());
-          walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
-          Commission commission = commissionDao.getDefaultCommission(OperationType.STORNO);
-          walletOperationData.setCommission(commission);
-          walletOperationData.setCommissionAmount(commission.getValue());
-          walletOperationData.setSourceType(TransactionSourceType.ORDER);
-          walletOperationData.setSourceId(orderId);
-          walletOperationData.setDescription(description);
-          WalletTransferStatus walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
-          if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
-            return OrderDeleteStatus.TRANSACTION_CREATE_ERROR;
-          }
-        }
-        log.debug("rows before refs {}", processedRows);
-        int processedRefRows = this.unprocessReferralTransactionByOrder(orderDetailDto.getOrderId(), description);
-        processedRows = processedRefRows + processedRows;
-        log.debug("rows after refs {}", processedRows);
-        /**/
-        if (!transactionService.setStatusById(
-            orderDetailDto.getTransactionId(),
-            TransactionStatus.DELETED.getStatus())) {
-          return OrderDeleteStatus.TRANSACTION_UPDATE_ERROR;
-        }
-        /**/
-        processedRows++;
-      } else if (currentOrderStatus == OrderStatus.OPENED) {
-        WalletTransferStatus walletTransferStatus = walletService.walletInnerTransfer(
-            orderDetailDto.getOrderCreatorReservedWalletId(),
-            orderDetailDto.getOrderCreatorReservedAmount(),
-            TransactionSourceType.ORDER,
-            orderId,
-            description);
-        if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
-          return OrderDeleteStatus.TRANSACTION_CREATE_ERROR;
-        }
-        /**/
-        if (!transactionService.setStatusById(
-            orderDetailDto.getTransactionId(),
-            TransactionStatus.DELETED.getStatus())) {
-          return OrderDeleteStatus.TRANSACTION_UPDATE_ERROR;
-        }
-      }
-    }
-    if (currentOrderStatus.equals(OrderStatus.OPENED)) {
-        eventPublisher.publishEvent(new CancelOrderEvent(getOrderById(orderId), true));
-    }
-    return processedRows;
-  }
+    @Transactional
+    Object deleteOrder(int orderId, OrderStatus newOrderStatus, OrderActionEnum action) {
+        List<OrderDetailDto> list = walletService.getOrderRelatedDataAndBlock(orderId);
+        if (list.isEmpty()) {
+            return OrderDeleteStatus.NOT_FOUND;
+        }
+        int processedRows = 1;
+        /**/
+        OrderStatus currentOrderStatus = list.get(0).getOrderStatus();
+        String description = transactionDescription.get(currentOrderStatus, action);
+        /**/
+        if (!setStatus(orderId, newOrderStatus)) {
+            return OrderDeleteStatus.ORDER_UPDATE_ERROR;
+        }
+        /**/
+        for (OrderDetailDto orderDetailDto : list) {
+            if (currentOrderStatus == OrderStatus.CLOSED) {
+                if (orderDetailDto.getCompanyCommission().compareTo(BigDecimal.ZERO) != 0) {
+                    Integer companyWalletId = orderDetailDto.getCompanyWalletId();
+                    if (companyWalletId != 0 && !companyWalletService.substractCommissionBalanceById(companyWalletId, orderDetailDto.getCompanyCommission())) {
+                        return OrderDeleteStatus.COMPANY_WALLET_UPDATE_ERROR;
+                    }
+                }
+                /**/
+                WalletOperationData walletOperationData = new WalletOperationData();
+                OperationType operationType = null;
+                if (orderDetailDto.getTransactionType() == OperationType.OUTPUT) {
+                    operationType = OperationType.INPUT;
+                } else if (orderDetailDto.getTransactionType() == OperationType.INPUT) {
+                    operationType = OperationType.OUTPUT;
+                }
+                if (operationType != null) {
+                    walletOperationData.setOperationType(operationType);
+                    walletOperationData.setWalletId(orderDetailDto.getUserWalletId());
+                    walletOperationData.setAmount(orderDetailDto.getTransactionAmount());
+                    walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
+                    Commission commission = commissionDao.getDefaultCommission(OperationType.STORNO);
+                    walletOperationData.setCommission(commission);
+                    walletOperationData.setCommissionAmount(commission.getValue());
+                    walletOperationData.setSourceType(TransactionSourceType.ORDER);
+                    walletOperationData.setSourceId(orderId);
+                    walletOperationData.setDescription(description);
+                    WalletTransferStatus walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
+                    if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
+                        return OrderDeleteStatus.TRANSACTION_CREATE_ERROR;
+                    }
+                }
+                log.debug("rows before refs {}", processedRows);
+                int processedRefRows = this.unprocessReferralTransactionByOrder(orderDetailDto.getOrderId(), description);
+                processedRows = processedRefRows + processedRows;
+                log.debug("rows after refs {}", processedRows);
+                /**/
+                if (!transactionService.setStatusById(
+                        orderDetailDto.getTransactionId(),
+                        TransactionStatus.DELETED.getStatus())) {
+                    return OrderDeleteStatus.TRANSACTION_UPDATE_ERROR;
+                }
+                /**/
+                processedRows++;
+            } else if (currentOrderStatus == OrderStatus.OPENED) {
+                WalletTransferStatus walletTransferStatus = walletService.walletInnerTransfer(
+                        orderDetailDto.getOrderCreatorReservedWalletId(),
+                        orderDetailDto.getOrderCreatorReservedAmount(),
+                        TransactionSourceType.ORDER,
+                        orderId,
+                        description);
+                if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
+                    return OrderDeleteStatus.TRANSACTION_CREATE_ERROR;
+                }
+                /**/
+                if (!transactionService.setStatusById(
+                        orderDetailDto.getTransactionId(),
+                        TransactionStatus.DELETED.getStatus())) {
+                    return OrderDeleteStatus.TRANSACTION_UPDATE_ERROR;
+                }
+            }
+        }
+        if (currentOrderStatus.equals(OrderStatus.OPENED)) {
+            eventPublisher.publishEvent(new CancelOrderEvent(getOrderById(orderId), true));
+        }
+        return processedRows;
+    }
 
 
-  private int unprocessReferralTransactionByOrder(int orderId, String description) {
-    List<Transaction> transactions = transactionService.getPayedRefTransactionsByOrderId(orderId);
-    for (Transaction transaction : transactions) {
-      WalletTransferStatus walletTransferStatus = null;
-      try {
-        WalletOperationData walletOperationData = new WalletOperationData();
-        walletOperationData.setWalletId(transaction.getUserWallet().getId());
-        walletOperationData.setAmount(transaction.getAmount());
-        walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
-        walletOperationData.setCommission(transaction.getCommission());
-        walletOperationData.setCommissionAmount(transaction.getCommissionAmount());
-        walletOperationData.setSourceType(TransactionSourceType.REFERRAL);
-        walletOperationData.setSourceId(transaction.getSourceId());
-        walletOperationData.setDescription(description);
-        walletOperationData.setOperationType(OperationType.OUTPUT);
-        walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
-        referralService.setRefTransactionStatus(ReferralTransactionStatusEnum.DELETED, transaction.getSourceId());
-        companyWalletService.substractCommissionBalanceById(transaction.getCompanyWallet().getId(), transaction.getAmount().negate());
-      } catch (Exception e) {
-        log.error("error unprocess ref transactions" + e);
-      }
-      log.debug("status " + walletTransferStatus);
-      if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
-        throw new RuntimeException("can't unprocess referral transaction for order " + orderId);
-      }
-    }
-    log.debug("end unprocess refs ");
-    return transactions.size();
-  }
+    private int unprocessReferralTransactionByOrder(int orderId, String description) {
+        List<Transaction> transactions = transactionService.getPayedRefTransactionsByOrderId(orderId);
+        for (Transaction transaction : transactions) {
+            WalletTransferStatus walletTransferStatus = null;
+            try {
+                WalletOperationData walletOperationData = new WalletOperationData();
+                walletOperationData.setWalletId(transaction.getUserWallet().getId());
+                walletOperationData.setAmount(transaction.getAmount());
+                walletOperationData.setBalanceType(WalletOperationData.BalanceType.ACTIVE);
+                walletOperationData.setCommission(transaction.getCommission());
+                walletOperationData.setCommissionAmount(transaction.getCommissionAmount());
+                walletOperationData.setSourceType(TransactionSourceType.REFERRAL);
+                walletOperationData.setSourceId(transaction.getSourceId());
+                walletOperationData.setDescription(description);
+                walletOperationData.setOperationType(OperationType.OUTPUT);
+                walletTransferStatus = walletService.walletBalanceChange(walletOperationData);
+                referralService.setRefTransactionStatus(ReferralTransactionStatusEnum.DELETED, transaction.getSourceId());
+                companyWalletService.substractCommissionBalanceById(transaction.getCompanyWallet().getId(), transaction.getAmount().negate());
+            } catch (Exception e) {
+                log.error("error unprocess ref transactions" + e);
+            }
+            log.debug("status " + walletTransferStatus);
+            if (walletTransferStatus != WalletTransferStatus.SUCCESS) {
+                throw new RuntimeException("can't unprocess referral transaction for order " + orderId);
+            }
+        }
+        log.debug("end unprocess refs ");
+        return transactions.size();
+    }
 
-  @Override
-  public List<UserSummaryOrdersByCurrencyPairsDto> getUserSummaryOrdersByCurrencyPairList(Integer requesterUserId, String startDate, String endDate, List<Integer> roles) {
-    return orderDao.getUserSummaryOrdersByCurrencyPairList(requesterUserId, startDate, endDate, roles);
-  }
+    @Override
+    public List<UserSummaryOrdersByCurrencyPairsDto> getUserSummaryOrdersByCurrencyPairList(Integer requesterUserId, String startDate, String endDate, List<Integer> roles) {
+        return orderDao.getUserSummaryOrdersByCurrencyPairList(requesterUserId, startDate, endDate, roles);
+    }
 
 
-  @Override
-  public String getOrdersForRefresh(Integer pairId, OperationType operationType, UserRole userRole) {
-    CurrencyPair cp = currencyService.findCurrencyPairById(pairId);
-    List<OrderListDto> dtos;
-    switch (operationType) {
-      case BUY: {
-        dtos = getAllBuyOrdersEx(cp, Locale.ENGLISH, userRole);
-        break;
-      }
-      case SELL: {
-        dtos = getAllSellOrdersEx(cp, Locale.ENGLISH, userRole);
-        break;
-      }
-      default: return null;
-    }
-    try {
-      return objectMapper.writeValueAsString(new OrdersListWrapper(dtos, operationType.name(), pairId));
-    } catch (JsonProcessingException e) {
-      log.error(e);
-      return null;
-    }
-  }
+    @Override
+    public String getOrdersForRefresh(Integer pairId, OperationType operationType, UserRole userRole) {
+        CurrencyPair cp = currencyService.findCurrencyPairById(pairId);
+        List<OrderListDto> dtos;
+        switch (operationType) {
+            case BUY: {
+                dtos = getAllBuyOrdersEx(cp, Locale.ENGLISH, userRole);
+                break;
+            }
+            case SELL: {
+                dtos = getAllSellOrdersEx(cp, Locale.ENGLISH, userRole);
+                break;
+            }
+            default:
+                return null;
+        }
+        try {
+            return objectMapper.writeValueAsString(new OrdersListWrapper(dtos, operationType.name(), pairId));
+        } catch (JsonProcessingException e) {
+            log.error(e);
+            return null;
+        }
+    }
 
 
-  @Override
-  public String getTradesForRefresh(Integer pairId, String email, RefreshObjectsEnum refreshObjectEnum) {
-    CurrencyPair cp = currencyService.findCurrencyPairById(pairId);
-    List<OrderAcceptedHistoryDto> dtos = this.getOrderAcceptedForPeriodEx(email,
-            new BackDealInterval("24 HOUR"),
-            100,
-            cp,
-            Locale.ENGLISH);
-    try {
-      return new JSONArray(){{put(objectMapper.writeValueAsString(new OrdersListWrapper(dtos, refreshObjectEnum.name(), pairId)));}}.toString();
-    } catch (JsonProcessingException e) {
-      log.error(e);
-      return null;
-    }
-  }
+    @Override
+    public String getTradesForRefresh(Integer pairId, String email, RefreshObjectsEnum refreshObjectEnum) {
+        CurrencyPair cp = currencyService.findCurrencyPairById(pairId);
+        List<OrderAcceptedHistoryDto> dtos = this.getOrderAcceptedForPeriodEx(email,
+                new BackDealInterval("24 HOUR"),
+                100,
+                cp,
+                Locale.ENGLISH);
+        try {
+            return new JSONArray() {{
+                put(objectMapper.writeValueAsString(new OrdersListWrapper(dtos, refreshObjectEnum.name(), pairId)));
+            }}.toString();
+        } catch (JsonProcessingException e) {
+            log.error(e);
+            return null;
+        }
+    }
 
-  @Override
-  public String getAllAndMyTradesForInit(int pairId, Principal principal) throws JsonProcessingException {
-    CurrencyPair cp = currencyService.findCurrencyPairById(pairId);
-    List<OrderAcceptedHistoryDto> dtos = this.getOrderAcceptedForPeriodEx(null,
-            new BackDealInterval("24 HOUR"),
-            100,
-            cp,
-            Locale.ENGLISH);
-    JSONArray jsonArray = new JSONArray(){{
-      put(objectMapper.writeValueAsString(new OrdersListWrapper(dtos, RefreshObjectsEnum.ALL_TRADES.name(), pairId)));
-    }};
-    if (principal != null) {
-      List<OrderAcceptedHistoryDto> myDtos = this.getOrderAcceptedForPeriodEx(principal.getName(),
-              new BackDealInterval("24 HOUR"),
-              100,
-              cp,
-              Locale.ENGLISH);
-      jsonArray.put(objectMapper.writeValueAsString(new OrdersListWrapper(myDtos, RefreshObjectsEnum.MY_TRADES.name(), pairId)));
-    }
-    return jsonArray.toString();
-  }
+    @Override
+    public String getAllAndMyTradesForInit(int pairId, Principal principal) throws JsonProcessingException {
+        CurrencyPair cp = currencyService.findCurrencyPairById(pairId);
+        List<OrderAcceptedHistoryDto> dtos = this.getOrderAcceptedForPeriodEx(null,
+                new BackDealInterval("24 HOUR"),
+                100,
+                cp,
+                Locale.ENGLISH);
+        JSONArray jsonArray = new JSONArray() {{
+            put(objectMapper.writeValueAsString(new OrdersListWrapper(dtos, RefreshObjectsEnum.ALL_TRADES.name(), pairId)));
+        }};
+        if (principal != null) {
+            List<OrderAcceptedHistoryDto> myDtos = this.getOrderAcceptedForPeriodEx(principal.getName(),
+                    new BackDealInterval("24 HOUR"),
+                    100,
+                    cp,
+                    Locale.ENGLISH);
+            jsonArray.put(objectMapper.writeValueAsString(new OrdersListWrapper(myDtos, RefreshObjectsEnum.MY_TRADES.name(), pairId)));
+        }
+        return jsonArray.toString();
+    }
 
-  @Override
-  @Transactional(readOnly = true)
-  public Optional<BigDecimal> getLastOrderPriceByCurrencyPairAndOperationType(CurrencyPair currencyPair, OperationType operationType) {
-    return orderDao.getLastOrderPriceByCurrencyPairAndOperationType(currencyPair.getId(), operationType.getType());
-  }
+    @Override
+    @Transactional(readOnly = true)
+    public Optional<BigDecimal> getLastOrderPriceByCurrencyPairAndOperationType(CurrencyPair currencyPair, OperationType operationType) {
+        return orderDao.getLastOrderPriceByCurrencyPairAndOperationType(currencyPair.getId(), operationType.getCode());
+    }
 
-  @Transactional(transactionManager = "slaveTxManager")
-  @Override
-  public String getChartData(Integer currencyPairId, final BackDealInterval backDealInterval) {
-    CurrencyPair cp = currencyService.findCurrencyPairById(currencyPairId);
-    List<CandleChartItemDto> rows = this.getDataForCandleChart(cp, backDealInterval);
-    ArrayList<List> arrayListMain = new ArrayList<>();
+    @Transactional(transactionManager = "slaveTxManager")
+    @Override
+    public String getChartData(Integer currencyPairId, final BackDealInterval backDealInterval) {
+        CurrencyPair cp = currencyService.findCurrencyPairById(currencyPairId);
+        List<CandleChartItemDto> rows = this.getDataForCandleChart(cp, backDealInterval);
+        ArrayList<List> arrayListMain = new ArrayList<>();
         /*in first row return backDealInterval - to synchronize period menu with it*/
-    arrayListMain.add(new ArrayList<Object>() {{
-      add(backDealInterval);
-    }});
-    for (CandleChartItemDto candle : rows) {
-      ArrayList<Object> arrayList = new ArrayList<>();
-                /*values*/
-      arrayList.add(candle.getBeginDate().toString());
-      arrayList.add(candle.getEndDate().toString());
-      arrayList.add(candle.getOpenRate());
-      arrayList.add(candle.getCloseRate());
-      arrayList.add(candle.getLowRate());
-      arrayList.add(candle.getHighRate());
-      arrayList.add(candle.getBaseVolume());
-      arrayListMain.add(arrayList);
-    }
-    try {
-      return objectMapper.writeValueAsString(new OrdersListWrapper(arrayListMain,
-              backDealInterval.getInterval(), currencyPairId));
-    } catch (JsonProcessingException e) {
-      log.error(e);
-      return null;
-    }
-  }
+        arrayListMain.add(new ArrayList<Object>() {{
+            add(backDealInterval);
+        }});
+        for (CandleChartItemDto candle : rows) {
+            ArrayList<Object> arrayList = new ArrayList<>();
+            /*values*/
+            arrayList.add(candle.getBeginDate().toString());
+            arrayList.add(candle.getEndDate().toString());
+            arrayList.add(candle.getOpenRate());
+            arrayList.add(candle.getCloseRate());
+            arrayList.add(candle.getLowRate());
+            arrayList.add(candle.getHighRate());
+            arrayList.add(candle.getBaseVolume());
+            arrayListMain.add(arrayList);
+        }
+        try {
+            return objectMapper.writeValueAsString(new OrdersListWrapper(arrayListMain,
+                    backDealInterval.getInterval(), currencyPairId));
+        } catch (JsonProcessingException e) {
+            log.error(e);
+            return null;
+        }
+    }
 
-  @Override
-  public String getAllCurrenciesStatForRefresh(RefreshObjectsEnum refreshObjectsEnum) {
-    OrdersListWrapper wrapper = new OrdersListWrapper(this.getOrdersStatisticByPairsEx(refreshObjectsEnum),
-                                                      refreshObjectsEnum.name());
-    try {
-      return new JSONArray(){{put(objectMapper.writeValueAsString(wrapper));}}.toString();
-    } catch (JsonProcessingException e) {
-      log.error(e);
-      return null;
-    }
-  }
+    @Override
+    public String getAllCurrenciesStatForRefresh(RefreshObjectsEnum refreshObjectsEnum) {
+        OrdersListWrapper wrapper = new OrdersListWrapper(this.getOrdersStatisticByPairsEx(refreshObjectsEnum),
+                refreshObjectsEnum.name());
+        try {
+            return new JSONArray() {{
+                put(objectMapper.writeValueAsString(wrapper));
+            }}.toString();
+        } catch (JsonProcessingException e) {
+            log.error(e);
+            return null;
+        }
+    }
 
-  @Override
-  public String getAllCurrenciesStatForRefreshForAllPairs() {
-    OrdersListWrapper wrapper = new OrdersListWrapper(this.processStatistic(exchangeRatesHolder.getAllRates()),
-            RefreshObjectsEnum.CURRENCIES_STATISTIC.name());
-    try {
-      return new JSONArray(){{put(objectMapper.writeValueAsString(wrapper));}}.toString();
-    } catch (JsonProcessingException e) {
-      log.error(e);
-      return null;
-    }
-  }
+    @Override
+    public String getAllCurrenciesStatForRefreshForAllPairs() {
+        OrdersListWrapper wrapper = new OrdersListWrapper(this.processStatistic(exchangeRatesHolder.getAllRates()),
+                RefreshObjectsEnum.CURRENCIES_STATISTIC.name());
+        try {
+            return new JSONArray() {{
+                put(objectMapper.writeValueAsString(wrapper));
+            }}.toString();
+        } catch (JsonProcessingException e) {
+            log.error(e);
+            return null;
+        }
+    }
 
-  @Override
-  public Map<RefreshObjectsEnum, String> getSomeCurrencyStatForRefresh(List<Integer> currencyIds) {
-    System.out.println("curencies for refresh size " + currencyIds.size());
-    List<ExOrderStatisticsShortByPairsDto> dtos = this.getStatForSomeCurrencies(currencyIds);
-    List<ExOrderStatisticsShortByPairsDto> icos = dtos.stream().filter(p->p.getType() == CurrencyPairType.ICO).collect(toList());
-    List<ExOrderStatisticsShortByPairsDto> mains = dtos.stream().filter(p->p.getType() == CurrencyPairType.MAIN).collect(toList());
-    Map<RefreshObjectsEnum, String> res = new HashMap<>();
-    if (!icos.isEmpty()) {
-      OrdersListWrapper wrapper = new OrdersListWrapper(icos, RefreshObjectsEnum.ICO_CURRENCY_STATISTIC.name());
-      res.put(RefreshObjectsEnum.ICO_CURRENCY_STATISTIC, new JSONArray(){{
-        try {
-          put(objectMapper.writeValueAsString(wrapper));
-        } catch (JsonProcessingException e) {
-          logger.error(e);
-        }
-      }}.toString());
-    }
-    if (!mains.isEmpty()) {
-      OrdersListWrapper wrapper = new OrdersListWrapper(mains, RefreshObjectsEnum.MAIN_CURRENCY_STATISTIC.name());
-      res.put(RefreshObjectsEnum.MAIN_CURRENCY_STATISTIC, new JSONArray(){{
-        try {
-          put(objectMapper.writeValueAsString(wrapper));
-        } catch (JsonProcessingException e) {
-          log.error(e);
-        }
-      }}.toString());
-    }
-    return res;
-  }
+    @Override
+    public Map<RefreshObjectsEnum, String> getSomeCurrencyStatForRefresh(List<Integer> currencyIds) {
+        System.out.println("curencies for refresh size " + currencyIds.size());
+        List<ExOrderStatisticsShortByPairsDto> dtos = this.getStatForSomeCurrencies(currencyIds);
+        List<ExOrderStatisticsShortByPairsDto> icos = dtos.stream().filter(p -> p.getType() == CurrencyPairType.ICO).collect(toList());
+        List<ExOrderStatisticsShortByPairsDto> mains = dtos.stream().filter(p -> p.getType() == CurrencyPairType.MAIN).collect(toList());
+        Map<RefreshObjectsEnum, String> res = new HashMap<>();
+        if (!icos.isEmpty()) {
+            OrdersListWrapper wrapper = new OrdersListWrapper(icos, RefreshObjectsEnum.ICO_CURRENCY_STATISTIC.name());
+            res.put(RefreshObjectsEnum.ICO_CURRENCY_STATISTIC, new JSONArray() {{
+                try {
+                    put(objectMapper.writeValueAsString(wrapper));
+                } catch (JsonProcessingException e) {
+                    logger.error(e);
+                }
+            }}.toString());
+        }
+        if (!mains.isEmpty()) {
+            OrdersListWrapper wrapper = new OrdersListWrapper(mains, RefreshObjectsEnum.MAIN_CURRENCY_STATISTIC.name());
+            res.put(RefreshObjectsEnum.MAIN_CURRENCY_STATISTIC, new JSONArray() {{
+                try {
+                    put(objectMapper.writeValueAsString(wrapper));
+                } catch (JsonProcessingException e) {
+                    log.error(e);
+                }
+            }}.toString());
+        }
+        return res;
+    }
 
-  @Override
-  public List<CurrencyPairTurnoverReportDto> getCurrencyPairTurnoverForPeriod(LocalDateTime startTime, LocalDateTime endTime,
-                                                                              List<Integer> userRoleIdList) {
-    return orderDao.getCurrencyPairTurnoverForPeriod(startTime, endTime, userRoleIdList);
-  }
+    @Override
+    public List<CurrencyPairTurnoverReportDto> getCurrencyPairTurnoverForPeriod(LocalDateTime startTime, LocalDateTime endTime,
+                                                                                List<Integer> userRoleIdList) {
+        return orderDao.getCurrencyPairTurnoverForPeriod(startTime, endTime, userRoleIdList);
+    }
 
-  @Override
-  public List<OrdersCommissionSummaryDto> getOrderCommissionsByPairsForPeriod(LocalDateTime startTime, LocalDateTime endTime,
-                                                                              List<Integer> userRoleIdList) {
-    return orderDao.getOrderCommissionsByPairsForPeriod(startTime, endTime, userRoleIdList);
-  }
+    @Override
+    public List<OrdersCommissionSummaryDto> getOrderCommissionsByPairsForPeriod(LocalDateTime startTime, LocalDateTime endTime,
+                                                                                List<Integer> userRoleIdList) {
+        return orderDao.getOrderCommissionsByPairsForPeriod(startTime, endTime, userRoleIdList);
+    }
 
-  //wolper 23.04.18
-  //Returns the list of the latest exchange rates for each currency to USD
-  @Override
-  public Map<Integer, RatesUSDForReportDto> getRatesToUSDForReport() {
-    return orderDao.getRatesToUSDForReport().stream().collect(Collectors.toMap(RatesUSDForReportDto::getId, Function.identity()));
-  }
+    //wolper 23.04.18
+    //Returns the list of the latest exchange rates for each currency to USD
+    @Override
+    public Map<Integer, RatesUSDForReportDto> getRatesToUSDForReport() {
+        return orderDao.getRatesToUSDForReport().stream().collect(Collectors.toMap(RatesUSDForReportDto::getId, Function.identity()));
+    }
 
 
-  //wolper 24.04.18
-  //Returns the list of the latest exchange rates for each currency to USD
-  @Override
-  @Transactional(transactionManager = "slaveTxManager", readOnly = true)
-  public Map<String, RatesUSDForReportDto> getRatesToUSDForReportByCurName() {
-    return orderDao.getRatesToUSDForReport().stream().collect(Collectors.toMap(RatesUSDForReportDto::getName, Function.identity()));
-  }
+    //wolper 24.04.18
+    //Returns the list of the latest exchange rates for each currency to USD
+    @Override
+    @Transactional(transactionManager = "slaveTxManager", readOnly = true)
+    public Map<String, RatesUSDForReportDto> getRatesToUSDForReportByCurName() {
+        return orderDao.getRatesToUSDForReport().stream().collect(Collectors.toMap(RatesUSDForReportDto::getName, Function.identity()));
+    }
 
-  private List<ExOrderStatisticsShortByPairsDto> processStatistic(List<ExOrderStatisticsShortByPairsDto> orders) {
-    Locale locale = Locale.ENGLISH;
-    orders = orders.stream()
-            .map(ExOrderStatisticsShortByPairsDto::new)
-            .collect(toList());
-    orders.forEach(e -> {
-      BigDecimal lastRate = new BigDecimal(e.getLastOrderRate());
-      BigDecimal predLastRate = e.getPredLastOrderRate() == null ? lastRate : new BigDecimal(e.getPredLastOrderRate());
-      e.setLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(lastRate, locale, 12));
-      e.setPredLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(predLastRate, locale, 12));
-      BigDecimal percentChange = null;
-      if (predLastRate.compareTo(BigDecimal.ZERO) == 0) {
-        percentChange = BigDecimal.ZERO;
-      }  else {
-        percentChange = BigDecimalProcessing.doAction(predLastRate, lastRate, ActionType.PERCENT_GROWTH);
-      }
-      e.setPercentChange(BigDecimalProcessing.formatLocaleFixedDecimal(percentChange, locale, 2));
-    });
-    return orders;
-  }
+    private List<ExOrderStatisticsShortByPairsDto> processStatistic(List<ExOrderStatisticsShortByPairsDto> orders) {
+        Locale locale = Locale.ENGLISH;
+        orders = orders.stream()
+                .map(ExOrderStatisticsShortByPairsDto::new)
+                .collect(toList());
+        orders.forEach(e -> {
+            BigDecimal lastRate = new BigDecimal(e.getLastOrderRate());
+            BigDecimal predLastRate = e.getPredLastOrderRate() == null ? lastRate : new BigDecimal(e.getPredLastOrderRate());
+            e.setLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(lastRate, locale, 12));
+            e.setPredLastOrderRate(BigDecimalProcessing.formatLocaleFixedSignificant(predLastRate, locale, 12));
+            BigDecimal percentChange = null;
+            if (predLastRate.compareTo(BigDecimal.ZERO) == 0) {
+                percentChange = BigDecimal.ZERO;
+            } else {
+                percentChange = BigDecimalProcessing.doAction(predLastRate, lastRate, ActionType.PERCENT_GROWTH);
+            }
+            e.setPercentChange(BigDecimalProcessing.formatLocaleFixedDecimal(percentChange, locale, 2));
+        });
+        return orders;
+    }
 
 
-  @Override
-  public Map<OrderType, List<OrderBookItem>> getOrderBook(String currencyPairName, @Nullable OrderType orderType) {
-    Integer currencyPairId = currencyService.findCurrencyPairIdByName(currencyPairName);
-    if (orderType != null) {
-      return Collections.singletonMap(orderType, orderDao.getOrderBookItemsForType(currencyPairId, orderType));
-    } else {
-      Map<OrderType, List<OrderBookItem>> result = orderDao.getOrderBookItems(currencyPairId)
-              .stream().collect(Collectors.groupingBy(OrderBookItem::getOrderType));
-      result.forEach((key, value) -> value.sort(Comparator.comparing(OrderBookItem::getRate, key.getBenefitRateComparator())));
-      return result;
-    }
+    @Override
+    public Map<OrderType, List<OrderBookItem>> getOrderBook(String currencyPairName, @Nullable OrderType orderType) {
+        Integer currencyPairId = currencyService.findCurrencyPairIdByName(currencyPairName);
+        if (orderType != null) {
+            return Collections.singletonMap(orderType, orderDao.getOrderBookItemsForType(currencyPairId, orderType));
+        } else {
+            Map<OrderType, List<OrderBookItem>> result = orderDao.getOrderBookItems(currencyPairId)
+                    .stream().collect(Collectors.groupingBy(OrderBookItem::getOrderType));
+            result.forEach((key, value) -> value.sort(Comparator.comparing(OrderBookItem::getRate, key.getBenefitRateComparator())));
+            return result;
+        }
 
-  }
+    }
 
-  @Override
-  public List<OrderHistoryItem> getRecentOrderHistory(String currencyPairName, String period) {
-    Integer currencyPairId = currencyService.findCurrencyPairIdByName(currencyPairName);
-    OrderHistoryPeriod historyPeriod = OrderHistoryPeriod.fromLowerCaseString(period);
-    return orderDao.getRecentOrderHistory(currencyPairId, historyPeriod.getInterval());
-  }
+    @Override
+    public List<OrderHistoryItem> getRecentOrderHistory(String currencyPairName, String period) {
+        Integer currencyPairId = currencyService.findCurrencyPairIdByName(currencyPairName);
+        OrderHistoryPeriod historyPeriod = OrderHistoryPeriod.fromLowerCaseString(period);
+        return orderDao.getRecentOrderHistory(currencyPairId, historyPeriod.getInterval());
+    }
 
-  @Override
-  public List<UserOrdersDto> getUserOpenOrders(@Nullable String currencyPairName) {
-    Integer userId = userService.getIdByEmail(userService.getUserEmailFromSecurityContext());
-    Integer currencyPairId = currencyPairName == null ? null : currencyService.findCurrencyPairIdByName(currencyPairName);
-    return orderDao.getUserOpenOrders(userId, currencyPairId);
+    @Override
+    public List<UserOrdersDto> getUserOpenOrders(@Nullable String currencyPairName) {
+        Integer userId = userService.getIdByEmail(userService.getUserEmailFromSecurityContext());
+        Integer currencyPairId = currencyPairName == null ? null : currencyService.findCurrencyPairIdByName(currencyPairName);
+        return orderDao.getUserOpenOrders(userId, currencyPairId);
 
-  }
+    }
 
     @Override
     public List<UserOrdersDto> getUserOrdersHistory(@Nullable String currencyPairName,
@@ -1896,11 +2020,11 @@
 
     }
 
-  @Override
-  public List<OpenOrderDto> getOpenOrders(String currencyPairName, OrderType orderType) {
-    Integer currencyPairId = currencyService.findCurrencyPairIdByName(currencyPairName);
-    return orderDao.getOpenOrders(currencyPairId, orderType);
-  }
+    @Override
+    public List<OpenOrderDto> getOpenOrders(String currencyPairName, OrderType orderType) {
+        Integer currencyPairId = currencyService.findCurrencyPairIdByName(currencyPairName);
+        return orderDao.getOpenOrders(currencyPairId, orderType);
+    }
 }
 
 
Index: Service/src/main/java/me/exrates/service/impl/ReportServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/impl/ReportServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/impl/ReportServiceImpl.java	(revision Shelved Version)
@@ -300,7 +300,7 @@
                                                                                 List<UserRole> roleList) {
     Preconditions.checkArgument(!roleList.isEmpty(), "At least one role must be specified");
     return orderService.getCurrencyPairTurnoverForPeriod(startTime, endTime, roleList.stream()
-            .map(UserRole::getRole).collect(Collectors.toList()));
+            .map(UserRole::getCode).collect(Collectors.toList()));
   }
 
   @Override
@@ -308,7 +308,7 @@
                                                                               List<UserRole> roleList) {
     Preconditions.checkArgument(!roleList.isEmpty(), "At least one role must be specified");
     return orderService.getOrderCommissionsByPairsForPeriod(startTime, endTime, roleList.stream()
-            .map(UserRole::getRole).collect(Collectors.toList()));
+            .map(UserRole::getCode).collect(Collectors.toList()));
   }
 
   @Override
@@ -316,7 +316,7 @@
                                                                             List<UserRole> roleList) {
     Preconditions.checkArgument(!roleList.isEmpty(), "At least one role must be specified");
     List<CurrencyInputOutputSummaryDto> report = inputOutputService.getInputOutputSummary(startTime, endTime, roleList.stream()
-            .map(UserRole::getRole).collect(Collectors.toList()));
+            .map(UserRole::getCode).collect(Collectors.toList()));
     //wolper 24.04.19
     Map<Integer, RatesUSDForReportDto> rates = orderService.getRatesToUSDForReport();
     //
@@ -329,7 +329,7 @@
                                                                             List<UserRole> roleList) {
     Preconditions.checkArgument(!roleList.isEmpty(), "At least one role must be specified");
     List<InputOutputCommissionSummaryDto> report = inputOutputService.getInputOutputSummaryWithCommissions(startTime, endTime, roleList.stream()
-            .map(UserRole::getRole).collect(Collectors.toList()));
+            .map(UserRole::getCode).collect(Collectors.toList()));
     //wolper 24.04.19
     Map<Integer, RatesUSDForReportDto> rates = orderService.getRatesToUSDForReport();
     report.stream().forEach(s-> s.setRateToUSD(rates.get(s.getCurId())==null?BigDecimal.ZERO:rates.get(s.getCurId()).getRate()));
Index: Service/src/main/java/me/exrates/service/impl/TransferServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/impl/TransferServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/impl/TransferServiceImpl.java	(revision Shelved Version)
@@ -41,6 +41,7 @@
 import static me.exrates.model.enums.WalletTransferStatus.SUCCESS;
 import static me.exrates.model.enums.invoice.InvoiceActionTypeEnum.*;
 import static me.exrates.model.enums.invoice.InvoiceOperationDirection.TRANSFER_VOUCHER;
+import static me.exrates.service.converters.BigDecimalConverter.convertToString;
 
 /**
  * created by ValkSam
@@ -119,7 +120,7 @@
       profileData.setTime2();
       BigDecimal newAmount = walletService.getWalletABalance(request.getUserWalletId());
       String currency = request.getCurrencyName();
-      String balance = currency + " " + currencyService.amountToString(newAmount, currency);
+      String balance = currency + " " + convertToString(newAmount, currency);
       Map<String, Object> result = new HashMap<>();
       result.put("message", notification);
       result.put("balance", balance);
Index: Service/src/main/java/me/exrates/service/impl/UserRoleServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/impl/UserRoleServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/impl/UserRoleServiceImpl.java	(revision Shelved Version)
@@ -33,7 +33,7 @@
   @Transactional(readOnly = true)
   public List<Integer> getRealUserRoleIdByBusinessRoleList(BusinessUserRoleEnum businessUserRoleEnum) {
     return getRealUserRoleByBusinessRoleList(businessUserRoleEnum).stream()
-        .map(e -> e.getRole())
+        .map(e -> e.getCode())
         .collect(Collectors.toList());
   }
 
@@ -65,7 +65,7 @@
   @Transactional(readOnly = true)
   public List<Integer> getRealUserRoleIdByGroupRoleList(GroupUserRoleEnum groupUserRoleEnum) {
     return getRealUserRoleByGroupRoleList(groupUserRoleEnum).stream()
-        .map(e -> e.getRole())
+        .map(e -> e.getCode())
         .collect(Collectors.toList());
   }
 
Index: Service/src/main/java/me/exrates/service/impl/WalletServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/impl/WalletServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/impl/WalletServiceImpl.java	(revision Shelved Version)
@@ -442,7 +442,7 @@
 
   @Override
   public List<UserRoleTotalBalancesReportDto<UserRole>> getWalletBalancesSummaryByRoles(List<UserRole> roles) {
-    return walletDao.getWalletBalancesSummaryByRoles(roles.stream().map(UserRole::getRole).collect(Collectors.toList()))
+    return walletDao.getWalletBalancesSummaryByRoles(roles.stream().map(UserRole::getCode).collect(Collectors.toList()))
             .stream()
             //wolper 19.04.18
             .collect(Collectors.groupingBy(UserRoleBalanceDto::getCurAndId)).entrySet().stream()
Index: Service/src/main/java/me/exrates/service/impl/WithdrawServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/impl/WithdrawServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/impl/WithdrawServiceImpl.java	(revision Shelved Version)
@@ -45,6 +45,7 @@
 import static me.exrates.model.enums.invoice.InvoiceActionTypeEnum.*;
 import static me.exrates.model.enums.invoice.InvoiceOperationDirection.WITHDRAW;
 import static me.exrates.model.vo.WalletOperationData.BalanceType.ACTIVE;
+import static me.exrates.service.converters.BigDecimalConverter.convertToString;
 
 /**
  * created by ValkSam
@@ -151,7 +152,7 @@
       profileData.setTime2();
       BigDecimal newAmount = walletService.getWalletABalance(request.getUserWalletId());
       String currency = request.getCurrencyName();
-      String balance = currency + " " + currencyService.amountToString(newAmount, currency);
+      String balance = currency + " " + convertToString(newAmount, currency);
       Map<String, String> result = new HashMap<>();
       result.put("message", notification);
       result.put("balance", balance);
Index: Service/src/main/java/me/exrates/service/notifications/SmsNotificatorServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/notifications/SmsNotificatorServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/notifications/SmsNotificatorServiceImpl.java	(revision Shelved Version)
@@ -10,21 +10,15 @@
 import me.exrates.model.vo.WalletOperationData;
 import me.exrates.service.*;
 import me.exrates.service.exception.*;
-import me.exrates.service.notifications.sms.Sms1s2uService;
 import me.exrates.service.notifications.sms.epochta.EpochtaApi;
 import me.exrates.service.notifications.sms.epochta.Phones;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.MessageSource;
-import org.springframework.context.NoSuchMessageException;
 import org.springframework.stereotype.Component;
 import org.springframework.transaction.annotation.Propagation;
 import org.springframework.transaction.annotation.Transactional;
 import org.springframework.util.StringUtils;
-import org.xml.sax.SAXException;
 
-import javax.servlet.http.HttpServletRequest;
-import javax.xml.parsers.ParserConfigurationException;
-import java.io.IOException;
 import java.math.BigDecimal;
 import java.util.*;
 
@@ -69,7 +63,7 @@
     @Transactional
     private String sendRegistrationMessageToUser(String userEmail, String message) {
         int userId = userService.getIdByEmail(userEmail);
-        int roleId = userService.getUserRoleFromDB(userId).getRole();
+        int roleId = userService.getUserRoleFromDB(userId).getCode();
         BigDecimal messagePrice = notificatorsService.getMessagePrice(getNotificationType().getCode(), roleId);
         SmsSubscriptionDto subscriptionDto = subscriptionDao.getByUserId(userService.getIdByEmail(userEmail));
         pay(
@@ -86,7 +80,7 @@
     @Override
     public String sendMessageToUser(String userEmail, String message, String subject) throws MessageUndeliweredException {
         int userId = userService.getIdByEmail(userEmail);
-        int roleId = userService.getUserRoleFromDB(userId).getRole();
+        int roleId = userService.getUserRoleFromDB(userId).getCode();
         BigDecimal messagePrice = notificatorsService.getMessagePrice(getNotificationType().getCode(), roleId);
         SmsSubscriptionDto subscriptionDto = subscriptionDao.getByUserId(userService.getIdByEmail(userEmail));
         pay(
@@ -155,7 +149,7 @@
         }
         subscriptionDto.setNewPrice(cost);
         UserRole role = userService.getUserRoleFromDB(subscriptionDto.getUserId());
-        BigDecimal feePercent = notificatorsService.getMessagePrice(getNotificationType().getCode(), role.getRole());
+        BigDecimal feePercent = notificatorsService.getMessagePrice(getNotificationType().getCode(), role.getCode());
         createOrUpdate(subscriptionDto);
         return doAction(cost, doAction(cost, feePercent, ActionType.MULTIPLY_PERCENT), ActionType.ADD);
     }
Index: Service/src/main/java/me/exrates/service/notifications/TelegramNotificatorServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/notifications/TelegramNotificatorServiceImpl.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/notifications/TelegramNotificatorServiceImpl.java	(revision Shelved Version)
@@ -151,7 +151,7 @@
                                  String description) {
         int userId = userService.getIdByEmail(userEmail);
         UserRole role = userService.getUserRoleFromDB(userEmail);
-        BigDecimal fee = notificatorsService.getSubscriptionPrice(getNotificationType().getCode(), role.getRole());
+        BigDecimal fee = notificatorsService.getSubscriptionPrice(getNotificationType().getCode(), role.getCode());
         if (fee.compareTo(BigDecimal.ZERO) <= 0) {
             return BigDecimal.ZERO;
         }
Index: Service/src/main/java/me/exrates/service/util/OpenApiUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/util/OpenApiUtils.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/util/OpenApiUtils.java	(revision Local Version)
@@ -1,20 +0,0 @@
-package me.exrates.service.util;
-
-import me.exrates.service.exception.api.InvalidCurrencyPairFormatException;
-
-import java.util.function.Predicate;
-import java.util.regex.Pattern;
-
-public class OpenApiUtils {
-
-    private static final Predicate<String> currencyPairNamePattern = Pattern.compile("^[a-z0-9]{2,8}_[a-z0-9]{2,8}$").asPredicate();
-
-    public static String formatCurrencyPairNameParam(String currencyPair) {
-        if (!currencyPairNamePattern.test(currencyPair)) {
-            throw new InvalidCurrencyPairFormatException(currencyPair);
-        }
-        return currencyPair.replace('_', '/').toUpperCase();
-    }
-
-
-}
Index: Service/src/main/java/me/exrates/service/util/RestApiUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/util/RestApiUtils.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/util/RestApiUtils.java	(revision Shelved Version)
@@ -6,12 +6,8 @@
 import java.util.Base64;
 import java.util.Map;
 
-/**
- * Created by OLEG on 01.09.2016.
- */
 public class RestApiUtils {
 
-
     public static String decodePassword(String password, String keyString) {
         final byte[] txt = Base64.getDecoder().decode(password);
         final byte[] key = keyString.getBytes();
@@ -21,16 +17,4 @@
         }
         return new String(result);
     }
-
-    public static String retrieveParamFormBody(Map<String, String> body, String paramName, boolean required) {
-        String paramValue = body.get(paramName);
-        if (required && StringUtils.isEmpty(paramValue)) {
-            throw new MissingBodyParamException("Param " + paramName + " missing");
-        }
-        return paramValue;
-    }
-
-    public static String constructAbsoluteURI(String host, String port, String endpoint) {
-        return String.join("", host, ":", port, endpoint);
-    }
 }
Index: Service/src/main/java/me/exrates/service/vo/ProfileData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/vo/ProfileData.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/vo/ProfileData.java	(revision Shelved Version)
@@ -4,9 +4,6 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-/**
- * Created by ValkSam
- */
 @Getter
 public class ProfileData {
   private static final Logger profileLog = LogManager.getLogger("profile");
Index: Service/src/main/java/me/exrates/service/CurrencyService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/CurrencyService.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/CurrencyService.java	(revision Shelved Version)
@@ -9,16 +9,18 @@
 import me.exrates.model.dto.mobileApiDto.TransferLimitDto;
 import me.exrates.model.dto.mobileApiDto.dashboard.CurrencyPairWithLimitsDto;
 import me.exrates.model.dto.openAPI.CurrencyPairInfoItem;
-import me.exrates.model.enums.*;
+import me.exrates.model.enums.CurrencyPairType;
+import me.exrates.model.enums.MerchantProcessType;
+import me.exrates.model.enums.OperationType;
+import me.exrates.model.enums.OrderType;
+import me.exrates.model.enums.UserCommentTopicEnum;
+import me.exrates.model.enums.UserRole;
 import me.exrates.model.enums.invoice.InvoiceOperationDirection;
 
 import java.math.BigDecimal;
 import java.util.List;
 import java.util.Set;
 
-/**
- * @author Denis Savin (pilgrimm333@gmail.com)
- */
 public interface CurrencyService {
 
     String getCurrencyName(int currencyId);
@@ -31,67 +33,79 @@
 
     List<Currency> findAllCurrencies();
 
-  void updateCurrencyLimit(int currencyId, OperationType operationType, String roleName, BigDecimal minAmount, Integer maxDailyRequest);
+    void updateCurrencyLimit(int currencyId,
+                             OperationType operationType,
+                             String roleName,
+                             BigDecimal minAmount,
+                             Integer maxDailyRequest);
 
-    List<CurrencyLimit> retrieveCurrencyLimitsForRole(String roleName, OperationType operationType);
+    List<CurrencyLimit> getCurrencyLimitsForRole(String roleName,
+                                                 OperationType operationType);
 
-    BigDecimal retrieveMinLimitForRoleAndCurrency(UserRole userRole, OperationType operationType, Integer currencyId);
+    BigDecimal getMinLimitForRoleAndCurrency(UserRole userRole,
+                                             OperationType operationType,
+                                             Integer currencyId);
 
     List<CurrencyPair> getAllCurrencyPairs(CurrencyPairType type);
 
     List<CurrencyPair> getAllCurrencyPairsInAlphabeticOrder(CurrencyPairType type);
 
-  CurrencyPair findCurrencyPairById(int currencyPairId);
+    CurrencyPair findCurrencyPairById(int currencyPairId);
 
-    String amountToString(BigDecimal amount, String currency);
-
-    int resolvePrecision(String currency);
-
-    int resolvePrecisionByOperationType(final String currency, OperationType operationType);
-
-    List<TransferLimitDto> retrieveMinTransferLimits(List<Integer> currencyIds);
+    List<TransferLimitDto> getMinTransferLimits(List<Integer> currencyIds);
 
     List<UserCurrencyOperationPermissionDto> getCurrencyOperationPermittedForRefill(String userEmail);
 
     List<UserCurrencyOperationPermissionDto> getCurrencyOperationPermittedForWithdraw(String userEmail);
 
-  List<UserCurrencyOperationPermissionDto> findWithOperationPermissionByUserAndDirection(Integer userId, InvoiceOperationDirection operationDirection);
+    List<UserCurrencyOperationPermissionDto> findWithOperationPermissionByUserAndDirection(Integer userId,
+                                                                                           InvoiceOperationDirection operationDirection);
 
-  Set<String> getCurrencyPermittedNameList(String userEmail);
+    Set<String> getCurrencyPermittedNameList(String userEmail);
 
-  List<UserCurrencyOperationPermissionDto> getCurrencyPermittedOperationList(Integer userId);
+    List<UserCurrencyOperationPermissionDto> getCurrencyPermittedOperationList(Integer userId);
 
-  Set<String> getCurrencyPermittedNameList(Integer userId);
-  
-  List<String> getWarningForCurrency(Integer currencyId, UserCommentTopicEnum currencyWarningTopicEnum);
+    Set<String> getCurrencyPermittedNameList(Integer userId);
+
+    List<String> getWarningForCurrency(Integer currencyId,
+                                       UserCommentTopicEnum currencyWarningTopicEnum);
 
     List<String> getWarningsByTopic(UserCommentTopicEnum currencyWarningTopicEnum);
 
-    List<String> getWarningForMerchant(Integer merchantId, UserCommentTopicEnum currencyWarningTopicEnum);
+    List<String> getWarningForMerchant(Integer merchantId,
+                                       UserCommentTopicEnum currencyWarningTopicEnum);
 
     Currency getById(int id);
-  
-  CurrencyPairLimitDto findLimitForRoleByCurrencyPairAndType(Integer currencyPairId, OperationType operationType);
-  
-  List<CurrencyPairLimitDto> findAllCurrencyLimitsForRoleAndType(String roleName, OrderType orderType);
-  
-  void updateCurrencyPairLimit(Integer currencyPairId, OrderType orderType, String roleName, BigDecimal minRate, BigDecimal maxRate, BigDecimal minAmount, BigDecimal maxAmount);
-  
-  List<CurrencyPairWithLimitsDto> findCurrencyPairsWithLimitsForUser();
+
+    CurrencyPairLimitDto findLimitForRoleByCurrencyPairAndType(Integer currencyPairId,
+                                                               OperationType operationType);
+
+    List<CurrencyPairLimitDto> findAllCurrencyLimitsForRoleAndType(String roleName,
+                                                                   OrderType orderType);
+
+    void updateCurrencyPairLimit(Integer currencyPairId,
+                                 OrderType orderType,
+                                 String roleName,
+                                 BigDecimal minRate,
+                                 BigDecimal maxRate,
+                                 BigDecimal minAmount,
+                                 BigDecimal maxAmount);
+
+    List<CurrencyPairWithLimitsDto> findCurrencyPairsWithLimitsForUser();
 
-  List<Currency> findAllCurrenciesWithHidden();
+    List<Currency> findAllCurrenciesWithHidden();
 
-  BigDecimal computeRandomizedAddition(Integer currencyId, OperationType operationType);
+    BigDecimal computeRandomizedAddition(Integer currencyId, OperationType operationType);
 
-  MerchantCurrencyScaleDto getCurrencyScaleByCurrencyId(Integer currencyId);
+    MerchantCurrencyScaleDto getCurrencyScaleByCurrencyId(Integer currencyId);
 
-  CurrencyPair getCurrencyPairByName(String pairName);
+    CurrencyPair getCurrencyPairByName(String pairName);
 
-  Integer findCurrencyPairIdByName(String pairName);
+    Integer findCurrencyPairIdByName(String pairName);
 
-  List<Currency> findAllCurrenciesByProcessType(MerchantProcessType processType);
+    List<Currency> findAllCurrenciesByProcessType(MerchantProcessType processType);
 
-  List<CurrencyPair> findPermitedCurrencyPairs(CurrencyPairType ico);
+    List<CurrencyPair> findPermittedCurrencyPairs(CurrencyPairType ico);
 
     CurrencyPair getNotHiddenCurrencyPairByName(String currencyPair);
 
Index: Service/src/main/java/me/exrates/service/OrderService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Service/src/main/java/me/exrates/service/OrderService.java	(revision Local Version)
+++ Service/src/main/java/me/exrates/service/OrderService.java	(revision Shelved Version)
@@ -6,7 +6,21 @@
 import me.exrates.model.ExOrder;
 import me.exrates.model.chart.ChartResolution;
 import me.exrates.model.chart.ChartTimeFrame;
-import me.exrates.model.dto.*;
+import me.exrates.model.dto.AdminOrderInfoDto;
+import me.exrates.model.dto.CandleChartItemDto;
+import me.exrates.model.dto.CoinmarketApiDto;
+import me.exrates.model.dto.CurrencyPairTurnoverReportDto;
+import me.exrates.model.dto.ExOrderStatisticsDto;
+import me.exrates.model.dto.OrderBasicInfoDto;
+import me.exrates.model.dto.OrderCommissionsDto;
+import me.exrates.model.dto.OrderCreateDto;
+import me.exrates.model.dto.OrderCreationResultDto;
+import me.exrates.model.dto.OrderInfoDto;
+import me.exrates.model.dto.OrderValidationDto;
+import me.exrates.model.dto.OrdersCommissionSummaryDto;
+import me.exrates.model.dto.RatesUSDForReportDto;
+import me.exrates.model.dto.UserSummaryOrdersByCurrencyPairsDto;
+import me.exrates.model.dto.WalletsAndCommissionsForOrderCreationDto;
 import me.exrates.model.dto.dataTable.DataTable;
 import me.exrates.model.dto.dataTable.DataTableParams;
 import me.exrates.model.dto.filterData.AdminOrderFilterData;
@@ -20,7 +34,13 @@
 import me.exrates.model.dto.openAPI.OrderBookItem;
 import me.exrates.model.dto.openAPI.OrderHistoryItem;
 import me.exrates.model.dto.openAPI.UserOrdersDto;
-import me.exrates.model.enums.*;
+import me.exrates.model.enums.OperationType;
+import me.exrates.model.enums.OrderActionEnum;
+import me.exrates.model.enums.OrderBaseType;
+import me.exrates.model.enums.OrderStatus;
+import me.exrates.model.enums.OrderType;
+import me.exrates.model.enums.RefreshObjectsEnum;
+import me.exrates.model.enums.UserRole;
 import me.exrates.model.vo.BackDealInterval;
 import me.exrates.model.vo.CacheData;
 import org.springframework.transaction.annotation.Transactional;
@@ -36,163 +56,183 @@
 
 public interface OrderService {
 
-
     List<ExOrderStatisticsShortByPairsDto> getOrdersStatisticByPairsEx(RefreshObjectsEnum refreshObjectsEnum);
 
     List<ExOrderStatisticsShortByPairsDto> getStatForSomeCurrencies(List<Integer> pairsIds);
 
     List<ExOrderStatisticsShortByPairsDto> getOrdersStatisticByPairsSessionless(Locale locale);
 
-  OrderCreateDto prepareNewOrder(CurrencyPair activeCurrencyPair, OperationType orderType, String userEmail, BigDecimal amount, BigDecimal rate, OrderBaseType baseType);
-  
-  OrderCreateDto prepareNewOrder(CurrencyPair activeCurrencyPair, OperationType orderType, String userEmail, BigDecimal amount, BigDecimal rate, Integer sourceId, OrderBaseType baseType);
-  
-  OrderValidationDto validateOrder(OrderCreateDto orderCreateDto);
+    OrderCreateDto prepareNewOrder(CurrencyPair activeCurrencyPair,
+                                   OperationType orderType,
+                                   String userEmail,
+                                   BigDecimal amount,
+                                   BigDecimal rate,
+                                   OrderBaseType baseType);
+
+    OrderCreateDto prepareNewOrder(CurrencyPair activeCurrencyPair,
+                                   OperationType orderType,
+                                   String userEmail,
+                                   BigDecimal amount,
+                                   BigDecimal rate,
+                                   Integer sourceId,
+                                   OrderBaseType baseType);
+
+    OrderValidationDto validateOrder(OrderCreateDto orderCreateDto);
 
-  @Transactional
-  String createOrder(OrderCreateDto orderCreateDto, OrderActionEnum action, Locale locale);
+    String createOrder(OrderCreateDto orderCreateDto,
+                       OrderActionEnum action,
+                       Locale locale);
 
-  @Transactional
-  Integer createOrderByStopOrder(OrderCreateDto orderCreateDto, OrderActionEnum action, Locale locale);
+    Integer createOrderByStopOrder(OrderCreateDto orderCreateDto,
+                                   OrderActionEnum action,
+                                   Locale locale);
 
-  /**
-   * Returns the ID of the newly created and saved in DB order
-   * Generates transaction of transferring money from active balance to reserved balance the corresponding wallet
-   *
-   * @param order OrderCreateDto, that passed from frontend and that will be converted to entity ExOrder to save in DB
-   * @return generated ID of the newly created order, or 0 if order was not be created
-   */
-  int createOrder(OrderCreateDto order, OrderActionEnum action);
+    /**
+     * Returns the ID of the newly created and saved in DB order
+     * Generates transaction of transferring money from active balance to reserved balance the corresponding wallet
+     *
+     * @param order OrderCreateDto, that passed from frontend and that will be converted to entity ExOrder to save in DB
+     * @return generated ID of the newly created order, or 0 if order was not be created
+     */
+    int createOrder(OrderCreateDto order, OrderActionEnum action);
 
-  @Transactional
     void postBotOrderToDb(OrderCreateDto orderCreateDto);
 
-  @Transactional
-  OrderCreateDto prepareOrderRest(OrderCreationParamsDto orderCreationParamsDto, String userEmail, Locale locale, OrderBaseType orderBaseType);
+    OrderCreateDto prepareOrderRest(OrderCreationParamsDto orderCreationParamsDto,
+                                    String userEmail,
+                                    Locale locale,
+                                    OrderBaseType orderBaseType);
 
-  @Transactional
-    OrderCreationResultDto createPreparedOrderRest(OrderCreateDto orderCreateDto, Locale locale);
+    OrderCreationResultDto createPreparedOrderRest(OrderCreateDto orderCreateDto,
+                                                   Locale locale);
 
-  @Transactional
-  OrderCreationResultDto prepareAndCreateOrderRest(String currencyPairName, OperationType orderType,
-                                                   BigDecimal amount, BigDecimal exrate, String userEmail);
+    OrderCreationResultDto prepareAndCreateOrderRest(String currencyPairName,
+                                                     OperationType orderType,
+                                                     BigDecimal amount,
+                                                     BigDecimal exrate,
+                                                     String userEmail);
 
-  Optional<String> autoAccept(OrderCreateDto orderCreateDto, Locale locale);
+    Optional<String> autoAccept(OrderCreateDto orderCreateDto, Locale locale);
 
-  Optional<OrderCreationResultDto> autoAcceptOrders(OrderCreateDto orderCreateDto, Locale locale);
+    Optional<OrderCreationResultDto> autoAcceptOrders(OrderCreateDto orderCreateDto, Locale locale);
 
-  /**
-   * TODO ADD JAVADOC
-   */
-  List<OrderWideListDto> getMyOrdersWithState(
-      CacheData cacheData,
-      String email, CurrencyPair currencyPair, OrderStatus status,
-      OperationType operationType,
-      String scope, Integer offset, Integer limit, Locale locale);
+    /**
+     * TODO ADD JAVADOC
+     */
+    List<OrderWideListDto> getMyOrdersWithState(
+            CacheData cacheData,
+            String email,
+            CurrencyPair currencyPair,
+            OrderStatus status,
+            OperationType operationType,
+            String scope,
+            Integer offset,
+            Integer limit,
+            Locale locale);
 
-  /**
-   * TODO ADD JAVADOC
-   */
-  public OrderCreateDto getMyOrderById(int orderId);
+    /**
+     * TODO ADD JAVADOC
+     */
+    public OrderCreateDto getMyOrderById(int orderId);
 
-  /**
-   * Returns entity ExOrder by its ID
-   *
-   * @param orderId
-   * @return entity ExOrder for found order, or null if order not found
-   */
-  ExOrder getOrderById(int orderId);
+    /**
+     * Returns entity ExOrder by its ID
+     *
+     * @param orderId
+     * @return entity ExOrder for found order, or null if order not found
+     */
+    ExOrder getOrderById(int orderId);
 
-  /**
-   * Sets new status for existing order with given ID.
-   *
-   * @param orderId
-   * @param status
-   * @return
-   */
-  boolean setStatus(int orderId, OrderStatus status);
+    /**
+     * Sets new status for existing order with given ID.
+     *
+     * @param orderId
+     * @param status
+     * @return
+     */
+    boolean setStatus(int orderId, OrderStatus status);
 
-  @Transactional
-  void acceptOrder(String userEmail, Integer orderId);
+    void acceptOrder(String userEmail, Integer orderId);
 
-  /**
-   * Accepts the list of orders
-   * The method <b>acceptOrdersList</b> is used to accept each orders from <b>ordersList</b>
-   * Before the method <b>acceptOrdersList</b will be called, this method tries to lock the <b>ordersList</b>
-   * If not success lock, the OrderAcceptionException will be thrown.
-   *
-   * @param userAcceptorId is ID of acceptor-user
-   * @param ordersList     is list the ID of order that must be accepted
-   * @param locale         is current locale. Used to generate messages
-   */
-  void acceptOrdersList(int userAcceptorId, List<Integer> ordersList, Locale locale);
+    /**
+     * Accepts the list of orders
+     * The method <b>acceptOrdersList</b> is used to accept each orders from <b>ordersList</b>
+     * Before the method <b>acceptOrdersList</b will be called, this method tries to lock the <b>ordersList</b>
+     * If not success lock, the OrderAcceptionException will be thrown.
+     *
+     * @param userAcceptorId is ID of acceptor-user
+     * @param ordersList     is list the ID of order that must be accepted
+     * @param locale         is current locale. Used to generate messages
+     */
+    void acceptOrdersList(int userAcceptorId, List<Integer> ordersList, Locale locale);
 
-  /**
-   * Accepts the order
-   * and generates set of transactions for creator-user and acceptor-user
-   * and modifies wallets for users and company
-   * If there were errors while accept, errors will be thrown:
-   * - NotEnoughUserWalletMoneyException
-   * - TransactionPersistException
-   * - OrderAcceptionException
-   *
-   * @param acceptorEmail  is email of acceptor-user
-   * @param orderId is ID of order that must be accepted
-   * @param locale  is current locale. Used to generate messages
-   */
-  /*void acceptOrder(int userId, int orderId, Locale locale);*/
-  
-  void acceptOrderByAdmin(String acceptorEmail, Integer orderId, Locale locale);
+    /**
+     * Accepts the order
+     * and generates set of transactions for creator-user and acceptor-user
+     * and modifies wallets for users and company
+     * If there were errors while accept, errors will be thrown:
+     * - NotEnoughUserWalletMoneyException
+     * - TransactionPersistException
+     * - OrderAcceptionException
+     *
+     * @param acceptorEmail is email of acceptor-user
+     * @param orderId       is ID of order that must be accepted
+     * @param locale        is current locale. Used to generate messages
+     */
+    /*void acceptOrder(int userId, int orderId, Locale locale);*/
+
+    void acceptOrderByAdmin(String acceptorEmail, Integer orderId, Locale locale);
 
     void acceptManyOrdersByAdmin(String acceptorEmail, List<Integer> orderIds, Locale locale);
 
-  @Transactional
-  void cancelOrder(Integer orderId, String currentUserEmail);
+    void cancelOrder(Integer orderId, String currentUserEmail);
 
-  /**
-   * Cancels the order and set status "CANCELLED"
-   * Only order with status "OPENED" can be cancelled
-   * This method for cancel order by creator-user
-   *
-   * @param exOrder is the entity ExOrder of order that must be cancelled
-   * @return "true" if the order can be cancelled and has been cancelled successfully, "false" in other cases
-   */
-  boolean cancellOrder(ExOrder exOrder, Locale locale);
+    /**
+     * Cancels the order and set status "CANCELLED"
+     * Only order with status "OPENED" can be cancelled
+     * This method for cancel order by creator-user
+     *
+     * @param exOrder is the entity ExOrder of order that must be cancelled
+     * @return "true" if the order can be cancelled and has been cancelled successfully, "false" in other cases
+     */
+    boolean cancellOrder(ExOrder exOrder, Locale locale);
 
-  /**
-   * Updates order's fields:
-   * - user_acceptor_id
-   * - status_id
-   * - date_acception
-   * Used while accepting process the order
-   *
-   * @param exOrder
-   * @return "true" if order was updated successfully, or "false" if not
-   */
-  boolean updateOrder(ExOrder exOrder);
+    /**
+     * Updates order's fields:
+     * - user_acceptor_id
+     * - status_id
+     * - date_acception
+     * Used while accepting process the order
+     *
+     * @param exOrder
+     * @return "true" if order was updated successfully, or "false" if not
+     */
+    boolean updateOrder(ExOrder exOrder);
 
-  /**
-   * Returns data for CoinMarketCap API
-   *
-   * @param currencyPairName
-   * @param backDealInterval
-   * @return list the CoinmarketApiDto, which consists info about currency pairs according to API
-   */
-  List<CoinmarketApiDto> getCoinmarketData(String currencyPairName, BackDealInterval backDealInterval);
+    /**
+     * Returns data for CoinMarketCap API
+     *
+     * @param currencyPairName
+     * @param backDealInterval
+     * @return list the CoinmarketApiDto, which consists info about currency pairs according to API
+     */
+    List<CoinmarketApiDto> getCoinmarketData(String currencyPairName,
+                                             BackDealInterval backDealInterval);
 
-  List<CoinmarketApiDto> getCoinmarketDataForActivePairs(String currencyPairName, BackDealInterval backDealInterval);
+    List<CoinmarketApiDto> getCoinmarketDataForActivePairs(String currencyPairName,
+                                                           BackDealInterval backDealInterval);
 
     List<CoinmarketApiDto> getDailyCoinmarketData(String currencyPairName);
 
     List<CoinmarketApiDto> getHourlyCoinmarketData(String currencyPairName);
 
     /**
-   * Returns detailed info about the order, including info from related transactions
-   *
-   * @param orderId is ID the order
-   * @return OrderInfoDto containing detailed info about the order
-   */
-  OrderInfoDto getOrderInfo(int orderId, Locale locale);
+     * Returns detailed info about the order, including info from related transactions
+     *
+     * @param orderId is ID the order
+     * @return OrderInfoDto containing detailed info about the order
+     */
+    OrderInfoDto getOrderInfo(int orderId, Locale locale);
 
     @Transactional
     AdminOrderInfoDto getAdminOrderInfo(int orderId, Locale locale);
@@ -201,202 +241,261 @@
 
     Object deleteOrderByAdmin(int orderId);
 
-  Object deleteOrderForPartialAccept(int orderId);
+    Object deleteOrderForPartialAccept(int orderId);
 
-  /**
-   * Searches order by its params:
-   *
-   * @param currencyPair
-   * @param orderType
-   * @param orderDate
-   * @param orderRate
-   * @param orderVolume
-   * @return ID the found order, or -1 if order with the parameters has not be found
-   */
-  Integer searchOrderByAdmin(Integer currencyPair, String orderType, String orderDate, BigDecimal orderRate, BigDecimal orderVolume);
+    /**
+     * Searches order by its params:
+     *
+     * @param currencyPair
+     * @param orderType
+     * @param orderDate
+     * @param orderRate
+     * @param orderVolume
+     * @return ID the found order, or -1 if order with the parameters has not be found
+     */
+    Integer searchOrderByAdmin(Integer currencyPair,
+                               String orderType,
+                               String orderDate,
+                               BigDecimal orderRate,
+                               BigDecimal orderVolume);
 
     List<BackDealInterval> getIntervals();
 
-  List<ChartTimeFrame> getChartTimeFrames();
+    List<ChartTimeFrame> getChartTimeFrames();
 
-  /**
-   * Returns object that contains data with statistics of orders for currencyPair.
-   * Statistics formed by data for certain period: from current moment to <i></>backDealInterval</i> back
-   *
-   * @param currencyPair
-   * @param backDealInterval is the length of interval
-   * @return statistics of orders for currencyPair
-   * @author ValkSam
-   */
-  ExOrderStatisticsDto getOrderStatistic(CurrencyPair currencyPair, BackDealInterval backDealInterval, Locale locale);
+    /**
+     * Returns object that contains data with statistics of orders for currencyPair.
+     * Statistics formed by data for certain period: from current moment to <i></>backDealInterval</i> back
+     *
+     * @param currencyPair
+     * @param backDealInterval is the length of interval
+     * @return statistics of orders for currencyPair
+     * @author ValkSam
+     */
+    ExOrderStatisticsDto getOrderStatistic(CurrencyPair currencyPair,
+                                           BackDealInterval backDealInterval,
+                                           Locale locale);
 
     @Transactional
-    List<CandleChartItemDto> getCachedDataForCandle(CurrencyPair currencyPair, ChartTimeFrame timeFrame);
+    List<CandleChartItemDto> getCachedDataForCandle(CurrencyPair currencyPair,
+                                                    ChartTimeFrame timeFrame);
 
     @Transactional
     List<CandleChartItemDto> getLastDataForCandleChart(Integer currencyPairId,
-                                                       LocalDateTime startTime, ChartResolution resolution);
+                                                       LocalDateTime startTime,
+                                                       ChartResolution resolution);
 
-    List<CandleChartItemDto> getDataForCandleChart(int pairId, ChartTimeFrame timeFrame);
+    List<CandleChartItemDto> getDataForCandleChart(int pairId,
+                                                   ChartTimeFrame timeFrame);
 
     @Transactional
-  List<CandleChartItemDto> getDataForCandleChart(CurrencyPair currencyPair, BackDealInterval interval, LocalDateTime startTime);
+    List<CandleChartItemDto> getDataForCandleChart(CurrencyPair currencyPair,
+                                                   BackDealInterval interval,
+                                                   LocalDateTime startTime);
 
-  /**
-   * Returns statistics of orders by currency pairs.
-   * Statistics contains last and pred last rates for each currency pair
-   *
-   * @return statistics of orders by currency pairs
-   * @author ValkSam
-   */
-  List<ExOrderStatisticsShortByPairsDto> getOrdersStatisticByPairs(CacheData cacheData, Locale locale);
+    /**
+     * Returns statistics of orders by currency pairs.
+     * Statistics contains last and pred last rates for each currency pair
+     *
+     * @return statistics of orders by currency pairs
+     * @author ValkSam
+     */
+    List<ExOrderStatisticsShortByPairsDto> getOrdersStatisticByPairs(CacheData cacheData,
+                                                                     Locale locale);
 
-  /**
-   * Returns data for candle chart for <i>currencyPair</i> for for period: from current moment to <i></>interval</i> back
-   *
-   * @param currencyPair
-   * @param interval
-   * @return data for candle chart
-   * @author ValkSam
-   */
-  List<CandleChartItemDto> getDataForCandleChart(CurrencyPair currencyPair, BackDealInterval interval);
+    /**
+     * Returns data for candle chart for <i>currencyPair</i> for for period: from current moment to <i></>interval</i> back
+     *
+     * @param currencyPair
+     * @param interval
+     * @return data for candle chart
+     * @author ValkSam
+     */
+    List<CandleChartItemDto> getDataForCandleChart(CurrencyPair currencyPair,
+                                                   BackDealInterval interval);
 
-  /**
-   * Returns data for area type chart for <i>currencyPair</i> for for period: from current moment to <i></>interval</i> back
-   *
-   * @param currencyPair
-   * @param interval
-   * @return data for area chart
-   * @author ValkSam
-   */
-  List<Map<String, Object>> getDataForAreaChart(CurrencyPair currencyPair, BackDealInterval interval);
+    /**
+     * Returns data for area type chart for <i>currencyPair</i> for for period: from current moment to <i></>interval</i> back
+     *
+     * @param currencyPair
+     * @param interval
+     * @return data for area chart
+     * @author ValkSam
+     */
+    List<Map<String, Object>> getDataForAreaChart(CurrencyPair currencyPair,
+                                                  BackDealInterval interval);
 
-  /**
-   * Returns data for the history of accepted orders
-   *
-   * @param backDealInterval
-   * @param limit
-   * @param locale
-   * @return
-   */
-  List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriod(CacheData cacheData, String email, BackDealInterval backDealInterval, Integer limit, CurrencyPair currencyPair, Locale locale);
+    /**
+     * Returns data for the history of accepted orders
+     *
+     * @param backDealInterval
+     * @param limit
+     * @param locale
+     * @return
+     */
+    List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriod(CacheData cacheData,
+                                                            String email,
+                                                            BackDealInterval backDealInterval,
+                                                            Integer limit,
+                                                            CurrencyPair currencyPair,
+                                                            Locale locale);
 
-  @Transactional
-  List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriodEx(String email,
-                                                            BackDealInterval backDealInterval,
-                                                            Integer limit, CurrencyPair currencyPair, Locale locale);
+    @Transactional
+    List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriodEx(String email,
+                                                              BackDealInterval backDealInterval,
+                                                              Integer limit,
+                                                              CurrencyPair currencyPair,
+                                                              Locale locale);
 
-  /**
-   * Returns SELL and BUY commissions for orders
-   *
-   * @return
-   */
-  OrderCommissionsDto getCommissionForOrder();
+    /**
+     * Returns SELL and BUY commissions for orders
+     *
+     * @return
+     */
+    OrderCommissionsDto getCommissionForOrder();
 
-  CommissionsDto getAllCommissions();
+    CommissionsDto getAllCommissions();
 
-  /**
-   * Returns list of Buy orders of status open
-   *
-   * @param currencyPair
-   * @param orderRoleFilterEnabled
-   * @return list of Buy orders
-   */
-  List<OrderListDto> getAllBuyOrders(CacheData cacheData, CurrencyPair currencyPair, Locale locale, Boolean orderRoleFilterEnabled);
+    /**
+     * Returns list of Buy orders of status open
+     *
+     * @param currencyPair
+     * @param orderRoleFilterEnabled
+     * @return list of Buy orders
+     */
+    List<OrderListDto> getAllBuyOrders(CacheData cacheData,
+                                       CurrencyPair currencyPair,
+                                       Locale locale,
+                                       Boolean orderRoleFilterEnabled);
 
     @Transactional(readOnly = true)
-    List<OrderListDto> getAllBuyOrdersEx(CurrencyPair currencyPair, Locale locale, UserRole userRole);
+    List<OrderListDto> getAllBuyOrdersEx(CurrencyPair currencyPair,
+                                         Locale locale,
+                                         UserRole userRole);
 
-  @Transactional(readOnly = true)
-  List<OrderListDto> getAllSellOrdersEx(CurrencyPair currencyPair, Locale locale, UserRole userRole);
+    @Transactional(readOnly = true)
+    List<OrderListDto> getAllSellOrdersEx(CurrencyPair currencyPair,
+                                          Locale locale,
+                                          UserRole userRole);
 
-  /**
-   * Returns list of Sell orders of status open, exclude the orders of current user
-   *
-   * @param currencyPair
-   * @param orderRoleFilterEnabled
-   * @return list of Sell orders
-   */
-  List<OrderListDto> getAllSellOrders(CacheData cacheData, CurrencyPair currencyPair, Locale locale, Boolean orderRoleFilterEnabled);
+    /**
+     * Returns list of Sell orders of status open, exclude the orders of current user
+     *
+     * @param currencyPair
+     * @param orderRoleFilterEnabled
+     * @return list of Sell orders
+     */
+    List<OrderListDto> getAllSellOrders(CacheData cacheData,
+                                        CurrencyPair currencyPair,
+                                        Locale locale,
+                                        Boolean orderRoleFilterEnabled);
 
-  /**
-   * Returns data of
-   * - userId by email,
-   * - wallet by currency id
-   * - commission by operation type
-   * Used for creation order with corresponding parameters
-   *
-   * @param email
-   * @param currency
-   * @param operationType
-   * @return
-   */
-  WalletsAndCommissionsForOrderCreationDto getWalletAndCommission(String email, Currency currency,
-                                                                  OperationType operationType);
+    /**
+     * Returns data of
+     * - userId by email,
+     * - wallet by currency id
+     * - commission by operation type
+     * Used for creation order with corresponding parameters
+     *
+     * @param email
+     * @param currency
+     * @param operationType
+     * @return
+     */
+    WalletsAndCommissionsForOrderCreationDto getWalletAndCommission(String email,
+                                                                    Currency currency,
+                                                                    OperationType operationType);
 
-  DataTable<List<OrderBasicInfoDto>> searchOrdersByAdmin(AdminOrderFilterData adminOrderFilterData, DataTableParams dataTableParams, Locale locale);
+    DataTable<List<OrderBasicInfoDto>> searchOrdersByAdmin(AdminOrderFilterData adminOrderFilterData,
+                                                           DataTableParams dataTableParams,
+                                                           Locale locale);
 
-  List<OrderWideListDto> getUsersOrdersWithStateForAdmin(String email, CurrencyPair currencyPair, OrderStatus status,
-                                                         OperationType operationType,
-                                                         Integer offset, Integer limit, Locale locale);
+    List<OrderWideListDto> getUsersOrdersWithStateForAdmin(String email,
+                                                           CurrencyPair currencyPair,
+                                                           OrderStatus status,
+                                                           OperationType operationType,
+                                                           Integer offset,
+                                                           Integer limit,
+                                                           Locale locale);
+
+    List<OrderWideListDto> getMyOrdersWithState(String email,
+                                                CurrencyPair currencyPair,
+                                                OrderStatus status,
+                                                OperationType operationType,
+                                                String scope,
+                                                Integer offset,
+                                                Integer limit,
+                                                Locale locale);
 
-  List<OrderWideListDto> getMyOrdersWithState(String email, CurrencyPair currencyPair, OrderStatus status,
-                                              OperationType operationType, String scope,
-                                              Integer offset, Integer limit, Locale locale);
-
-  List<OrderWideListDto> getMyOrdersWithState(String email, CurrencyPair currencyPair, List<OrderStatus> statuses,
-                                              OperationType operationType,
-                                              Integer offset, Integer limit, Locale locale);
+    List<OrderWideListDto> getMyOrdersWithState(String email,
+                                                CurrencyPair currencyPair,
+                                                List<OrderStatus> statuses,
+                                                OperationType operationType,
+                                                Integer offset,
+                                                Integer limit,
+                                                Locale locale);
 
-  List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriod(String email,
-                                                          BackDealInterval backDealInterval,
-                                                          Integer limit, CurrencyPair currencyPair, Locale locale);
+    List<OrderAcceptedHistoryDto> getOrderAcceptedForPeriod(String email,
+                                                            BackDealInterval backDealInterval,
+                                                            Integer limit,
+                                                            CurrencyPair currencyPair,
+                                                            Locale locale);
 
-  List<OrderListDto> getAllBuyOrders(CurrencyPair currencyPair, Locale locale);
+    List<OrderListDto> getAllBuyOrders(CurrencyPair currencyPair, Locale locale);
 
-  List<OrderListDto> getAllSellOrders(CurrencyPair currencyPair, Locale locale);
+    List<OrderListDto> getAllSellOrders(CurrencyPair currencyPair, Locale locale);
 
-  List<UserSummaryOrdersByCurrencyPairsDto> getUserSummaryOrdersByCurrencyPairList(Integer requesterUserId, String startDate, String endDate, List<Integer> roles);
+    List<UserSummaryOrdersByCurrencyPairsDto> getUserSummaryOrdersByCurrencyPairList(Integer requesterUserId,
+                                                                                     String startDate,
+                                                                                     String endDate,
+                                                                                     List<Integer> roles);
 
-  String getTradesForRefresh(Integer pairId, String email, RefreshObjectsEnum refreshObjectEnum);
+    String getTradesForRefresh(Integer pairId, String email, RefreshObjectsEnum refreshObjectEnum);
 
-    @Transactional(readOnly = true)
     String getAllAndMyTradesForInit(int pairId, Principal principal) throws JsonProcessingException;
 
-    Optional<BigDecimal> getLastOrderPriceByCurrencyPairAndOperationType(CurrencyPair currencyPair, OperationType operationType);
+    Optional<BigDecimal> getLastOrderPriceByCurrencyPairAndOperationType(CurrencyPair currencyPair,
+                                                                         OperationType operationType);
 
-  String getOrdersForRefresh(Integer pairId, OperationType operationType, UserRole userRole);
+    String getOrdersForRefresh(Integer pairId, OperationType operationType,
+                               UserRole userRole);
 
-  String getChartData(Integer currencyPairId, BackDealInterval backDealInterval);
+    String getChartData(Integer currencyPairId, BackDealInterval backDealInterval);
 
-  String getAllCurrenciesStatForRefresh(RefreshObjectsEnum refreshObjectsEnum);
+    String getAllCurrenciesStatForRefresh(RefreshObjectsEnum refreshObjectsEnum);
 
-  String getAllCurrenciesStatForRefreshForAllPairs();
+    String getAllCurrenciesStatForRefreshForAllPairs();
 
-  Map<RefreshObjectsEnum, String> getSomeCurrencyStatForRefresh(List<Integer> currencyId);
+    Map<RefreshObjectsEnum, String> getSomeCurrencyStatForRefresh(List<Integer> currencyId);
 
-    List<CurrencyPairTurnoverReportDto> getCurrencyPairTurnoverForPeriod(LocalDateTime startTime, LocalDateTime endTime,
+    List<CurrencyPairTurnoverReportDto> getCurrencyPairTurnoverForPeriod(LocalDateTime startTime,
+                                                                         LocalDateTime endTime,
                                                                          List<Integer> userRoleIdList);
 
-    List<OrdersCommissionSummaryDto> getOrderCommissionsByPairsForPeriod(LocalDateTime startTime, LocalDateTime endTime,
+    List<OrdersCommissionSummaryDto> getOrderCommissionsByPairsForPeriod(LocalDateTime startTime,
+                                                                         LocalDateTime endTime,
                                                                          List<Integer> userRoleIdList);
 
-  /**
-   * wolper 24.04.18
-   *  Returns the list of the latest exchange rates for each currency to USD
-   */
-  Map<Integer, RatesUSDForReportDto> getRatesToUSDForReport();
+    /**
+     * wolper 24.04.18
+     * Returns the list of the latest exchange rates for each currency to USD
+     */
+    Map<Integer, RatesUSDForReportDto> getRatesToUSDForReport();
 
-  Map<String, RatesUSDForReportDto> getRatesToUSDForReportByCurName();
+    Map<String, RatesUSDForReportDto> getRatesToUSDForReportByCurName();
 
-    Map<OrderType, List<OrderBookItem>> getOrderBook(String currencyPairName, @Nullable OrderType orderType);
+    Map<OrderType, List<OrderBookItem>> getOrderBook(String currencyPairName,
+                                                     @Nullable OrderType orderType);
 
-  List<OrderHistoryItem> getRecentOrderHistory(String currencyPairName, String period);
+    List<OrderHistoryItem> getRecentOrderHistory(String currencyPairName,
+                                                 String period);
 
     List<UserOrdersDto> getUserOpenOrders(@Nullable String currencyPairName);
 
     List<UserOrdersDto> getUserOrdersHistory(@Nullable String currencyPairName,
-                                             @Nullable Integer limit, @Nullable Integer offset);
+                                             @Nullable Integer limit,
+                                             @Nullable Integer offset);
 
-    List<OpenOrderDto> getOpenOrders(String currencyPairName, OrderType orderType);
+    List<OpenOrderDto> getOpenOrders(String currencyPairName,
+                                     OrderType orderType);
 }
